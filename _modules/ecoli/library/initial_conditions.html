

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ecoli.library.initial_conditions &mdash; Vivarium E. coli 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Vivarium E. coli
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../stores.html">Stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../composites.html">Composites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../experiments.html">Experiments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hpc.html">HPC Clusters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gcloud.html">Google Cloud</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ci.html">Continuous Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pycharm.html">PyCharm Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/api_ref.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Vivarium E. coli</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ecoli.library.initial_conditions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ecoli.library.initial_conditions</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions to initialize molecule states from sim_data.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.lib</span><span class="w"> </span><span class="kn">import</span> <span class="n">recfunctions</span> <span class="k">as</span> <span class="n">rfn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">unum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Unum</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">ecoli.library.schema</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">attrs</span><span class="p">,</span>
    <span class="n">bulk_name_to_idx</span><span class="p">,</span>
    <span class="n">counts</span><span class="p">,</span>
    <span class="n">MetadataArray</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ecoli.processes.polypeptide_elongation</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">calculate_trna_charging</span><span class="p">,</span>
    <span class="n">REMOVED_FROM_CHARGING</span><span class="p">,</span>
    <span class="n">MICROMOLAR_UNITS</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wholecell.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">units</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wholecell.utils.fitting</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">countsFromMassAndExpression</span><span class="p">,</span>
    <span class="n">masses_and_counts_for_homeostatic_target</span><span class="p">,</span>
    <span class="n">normalize</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">wholecell.utils.mc_complexation</span><span class="w"> </span><span class="kn">import</span> <span class="n">mccFormComplexesWithPrebuiltMatrices</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
        <span class="s2">&quot;Failed to import Cython module. Try running &#39;make clean compile&#39;.&quot;</span>
    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wholecell.utils.polymerize</span><span class="w"> </span><span class="kn">import</span> <span class="n">computeMassIncrease</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wholecell.utils.random</span><span class="w"> </span><span class="kn">import</span> <span class="n">stochasticRound</span>

<span class="n">RAND_MAX</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span>


<div class="viewcode-block" id="create_bulk_container">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.create_bulk_container">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_bulk_container</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">n_seeds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">ppgpp_regulation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">trna_attenuation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">mass_coeff</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">form_complexes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">old_condition</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span>
        <span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">condition</span>
        <span class="n">media_id</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">conditions</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">][</span><span class="s2">&quot;nutrients&quot;</span><span class="p">]</span>
        <span class="n">exchange_data</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">external_state</span><span class="o">.</span><span class="n">exchange_data_from_media</span><span class="p">(</span><span class="n">media_id</span><span class="p">)</span>
        <span class="n">import_molecules</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="n">exchange_data</span><span class="p">[</span><span class="s2">&quot;importUnconstrainedExchangeMolecules&quot;</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">exchange_data</span><span class="p">[</span><span class="s2">&quot;importConstrainedExchangeMolecules&quot;</span><span class="p">])</span>

        <span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># Construct bulk container</span>
        <span class="n">ids_molecules</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
        <span class="n">average_container</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">mol_data</span> <span class="k">for</span> <span class="n">mol_data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ids_molecules</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ids_molecules</span><span class="p">)))],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">ids_molecules</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)],</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_seeds</span><span class="p">):</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">average_container</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">initialize_bulk_counts</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="p">,</span>
                <span class="n">media_id</span><span class="p">,</span>
                <span class="n">import_molecules</span><span class="p">,</span>
                <span class="n">random_state</span><span class="p">,</span>
                <span class="n">mass_coeff</span><span class="p">,</span>
                <span class="n">ppgpp_regulation</span><span class="p">,</span>
                <span class="n">trna_attenuation</span><span class="p">,</span>
                <span class="n">form_complexes</span><span class="o">=</span><span class="n">form_complexes</span><span class="p">,</span>
            <span class="p">)[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;sim_data might not be fully initialized. &quot;</span>
            <span class="s2">&quot;Make sure all attributes have been set before &quot;</span>
            <span class="s2">&quot;using this function.&quot;</span>
        <span class="p">)</span>

    <span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">old_condition</span>
    <span class="n">average_container</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">average_container</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_seeds</span>
    <span class="k">return</span> <span class="n">average_container</span></div>



<div class="viewcode-block" id="initialize_bulk_counts">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_bulk_counts">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_bulk_counts</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">media_id</span><span class="p">,</span>
    <span class="n">import_molecules</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">,</span>
    <span class="n">mass_coeff</span><span class="p">,</span>
    <span class="n">ppgpp_regulation</span><span class="p">,</span>
    <span class="n">trna_attenuation</span><span class="p">,</span>
    <span class="n">form_complexes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># Allocate count array to populate</span>
    <span class="n">bulk_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
    <span class="p">)</span>

    <span class="c1"># Set protein counts from expression</span>
    <span class="n">initialize_protein_monomers</span><span class="p">(</span>
        <span class="n">bulk_counts</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">,</span>
        <span class="n">mass_coeff</span><span class="p">,</span>
        <span class="n">ppgpp_regulation</span><span class="p">,</span>
        <span class="n">trna_attenuation</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Set RNA counts from expression</span>
    <span class="n">initialize_rna</span><span class="p">(</span>
        <span class="n">bulk_counts</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">,</span>
        <span class="n">mass_coeff</span><span class="p">,</span>
        <span class="n">ppgpp_regulation</span><span class="p">,</span>
        <span class="n">trna_attenuation</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Set mature RNA counts</span>
    <span class="n">initialize_mature_RNA</span><span class="p">(</span><span class="n">bulk_counts</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">)</span>

    <span class="c1"># Set other biomass components</span>
    <span class="n">set_small_molecule_counts</span><span class="p">(</span>
        <span class="n">bulk_counts</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">media_id</span><span class="p">,</span> <span class="n">import_molecules</span><span class="p">,</span> <span class="n">mass_coeff</span>
    <span class="p">)</span>

    <span class="c1"># Form complexes</span>
    <span class="k">if</span> <span class="n">form_complexes</span><span class="p">:</span>
        <span class="n">initialize_complexation</span><span class="p">(</span><span class="n">bulk_counts</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

    <span class="n">bulk_masses</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span>
        <span class="n">units</span><span class="o">.</span><span class="n">fg</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">mol</span>
    <span class="p">)</span> <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
    <span class="n">bulk_submasses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bulk_submass_dtypes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">submass</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">submass_name_to_index</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">bulk_submasses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bulk_masses</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">])</span>
        <span class="n">bulk_submass_dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">submass</span><span class="si">}</span><span class="s2">_submass&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
    <span class="n">bulk_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="o">.</span><span class="n">struct_array</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">bulk_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">mol_data</span> <span class="k">for</span> <span class="n">mol_data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bulk_ids</span><span class="p">,</span> <span class="n">bulk_counts</span><span class="p">,</span> <span class="o">*</span><span class="n">bulk_submasses</span><span class="p">)],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span> <span class="o">+</span> <span class="n">bulk_submass_dtypes</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">bulk_array</span></div>



<div class="viewcode-block" id="initialize_unique_molecules">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_unique_molecules">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_unique_molecules</span><span class="p">(</span>
    <span class="n">bulk_state</span><span class="p">,</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">cell_mass</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">,</span>
    <span class="n">unique_id_rng</span><span class="p">,</span>
    <span class="n">superhelical_density</span><span class="p">,</span>
    <span class="n">ppgpp_regulation</span><span class="p">,</span>
    <span class="n">trna_attenuation</span><span class="p">,</span>
    <span class="n">mechanistic_replisome</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">unique_molecules</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Initialize counts of full chromosomes</span>
    <span class="n">initialize_full_chromosome</span><span class="p">(</span><span class="n">unique_molecules</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">unique_id_rng</span><span class="p">)</span>

    <span class="c1"># Initialize unique molecules relevant to replication</span>
    <span class="n">initialize_replication</span><span class="p">(</span>
        <span class="n">bulk_state</span><span class="p">,</span>
        <span class="n">unique_molecules</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">cell_mass</span><span class="p">,</span>
        <span class="n">mechanistic_replisome</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Initialize bound transcription factors</span>
    <span class="n">initialize_transcription_factors</span><span class="p">(</span>
        <span class="n">bulk_state</span><span class="p">,</span> <span class="n">unique_molecules</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">random_state</span>
    <span class="p">)</span>

    <span class="c1"># Initialize active RNAPs and unique molecule representations of RNAs</span>
    <span class="n">initialize_transcription</span><span class="p">(</span>
        <span class="n">bulk_state</span><span class="p">,</span>
        <span class="n">unique_molecules</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">random_state</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
        <span class="n">ppgpp_regulation</span><span class="p">,</span>
        <span class="n">trna_attenuation</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Initialize linking numbers of chromosomal segments</span>
    <span class="k">if</span> <span class="n">superhelical_density</span><span class="p">:</span>
        <span class="n">initialize_chromosomal_segments</span><span class="p">(</span><span class="n">unique_molecules</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">unique_id_rng</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;chromosomal_segment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
            <span class="s2">&quot;chromosomal_segment&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">unique_id_rng</span>
        <span class="p">)</span>

    <span class="c1"># Initialize active ribosomes</span>
    <span class="n">initialize_translation</span><span class="p">(</span>
        <span class="n">bulk_state</span><span class="p">,</span> <span class="n">unique_molecules</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">unique_id_rng</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">unique_molecules</span></div>



<div class="viewcode-block" id="create_new_unique_molecules">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.create_new_unique_molecules">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_new_unique_molecules</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n_mols</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to create a new Numpy structured array with n_mols</span>
<span class="sd">    instances of the unique molecule called name. Accepts keyword arguments</span>
<span class="sd">    that become initial values for specified attributes of the new molecules.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">unique_molecule</span><span class="o">.</span><span class="n">unique_molecule_definitions</span><span class="p">[</span>
            <span class="n">name</span>
        <span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">submasses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">submass_name_to_index</span><span class="p">)</span>
    <span class="n">dtypes</span> <span class="o">+=</span> <span class="p">[(</span><span class="sa">f</span><span class="s2">&quot;massDiff_</span><span class="si">{</span><span class="n">submass</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;f8&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">submass</span> <span class="ow">in</span> <span class="n">submasses</span><span class="p">]</span>
    <span class="n">dtypes</span> <span class="o">+=</span> <span class="p">[(</span><span class="s2">&quot;_entryState&quot;</span><span class="p">,</span> <span class="s2">&quot;i1&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;unique_index&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;i8&quot;</span><span class="p">)]</span>
    <span class="n">unique_mols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_mols</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">attr_value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">unique_mols</span><span class="p">[</span><span class="n">attr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">attr_value</span>
    <span class="c1"># Each unique molecule has unique prefix for indices to prevent conflicts</span>
    <span class="n">unique_mol_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">unique_molecule</span><span class="o">.</span><span class="n">unique_molecule_definitions</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">unique_prefix</span> <span class="o">=</span> <span class="n">unique_mol_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">59</span>
    <span class="n">unique_mols</span><span class="p">[</span><span class="s2">&quot;unique_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">unique_prefix</span><span class="p">,</span> <span class="n">unique_prefix</span> <span class="o">+</span> <span class="n">n_mols</span><span class="p">)</span>
    <span class="n">unique_mols</span><span class="p">[</span><span class="s2">&quot;_entryState&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">unique_mols</span> <span class="o">=</span> <span class="n">MetadataArray</span><span class="p">(</span><span class="n">unique_mols</span><span class="p">,</span> <span class="n">unique_prefix</span> <span class="o">+</span> <span class="n">n_mols</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unique_mols</span></div>



<div class="viewcode-block" id="initialize_protein_monomers">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_protein_monomers">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_protein_monomers</span><span class="p">(</span>
    <span class="n">bulk_counts</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">mass_coeff</span><span class="p">,</span> <span class="n">ppgpp_regulation</span><span class="p">,</span> <span class="n">trna_attenuation</span>
<span class="p">):</span>
    <span class="n">monomer_mass</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">mass_coeff</span>
        <span class="o">*</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">get_component_masses</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">]</span>
        <span class="p">)[</span><span class="s2">&quot;proteinMass&quot;</span><span class="p">]</span>
        <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_to_initial_cell_conversion_factor</span>
    <span class="p">)</span>
    <span class="c1"># TODO: unify this logic with the parca so it doesn]t fall out of step</span>
    <span class="c1"># again (look at teh calProteinCounts function)</span>

    <span class="n">transcription</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span>
    <span class="k">if</span> <span class="n">ppgpp_regulation</span><span class="p">:</span>
        <span class="n">rna_expression</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">calculate_ppgpp_expression</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rna_expression</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_expression</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">trna_attenuation</span><span class="p">:</span>
        <span class="c1"># Need to adjust expression (calculated without attenuation) by basal_adjustment</span>
        <span class="c1"># to get the expected expression without any attenuation and then multiply</span>
        <span class="c1"># by the condition readthrough probability to get the condition specific expression</span>
        <span class="n">readthrough</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">attenuation_readthrough</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">]</span>
        <span class="n">basal_adjustment</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">attenuation_readthrough</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span>
        <span class="n">rna_expression</span><span class="p">[</span><span class="n">transcription</span><span class="o">.</span><span class="n">attenuated_rna_indices</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
            <span class="n">readthrough</span> <span class="o">/</span> <span class="n">basal_adjustment</span>
        <span class="p">)</span>

    <span class="n">monomer_expression</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_tu_mapping_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rna_expression</span><span class="p">)[</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">relation</span><span class="o">.</span><span class="n">cistron_to_monomer_mapping</span>
        <span class="p">]</span>
        <span class="o">*</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">translation_efficiencies_by_monomer</span>
        <span class="o">/</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;deg_rate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span>
                <span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">n_monomers</span> <span class="o">=</span> <span class="n">countsFromMassAndExpression</span><span class="p">(</span>
        <span class="n">monomer_mass</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">g</span><span class="p">),</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;mw&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">g</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">mol</span><span class="p">),</span>
        <span class="n">monomer_expression</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">mol</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># Get indices for monomers in bulk counts array</span>
    <span class="n">monomer_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">bulk_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">monomer_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">monomer_ids</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>
    <span class="c1"># Calculate initial counts of each monomer from mutinomial distribution</span>
    <span class="n">bulk_counts</span><span class="p">[</span><span class="n">monomer_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">n_monomers</span><span class="p">,</span> <span class="n">monomer_expression</span><span class="p">)</span></div>



<div class="viewcode-block" id="initialize_rna">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_rna">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_rna</span><span class="p">(</span>
    <span class="n">bulk_counts</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">mass_coeff</span><span class="p">,</span> <span class="n">ppgpp_regulation</span><span class="p">,</span> <span class="n">trna_attenuation</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes counts of RNAs in the bulk molecule container using RNA</span>
<span class="sd">    expression data. mRNA counts are also initialized here, but is later reset</span>
<span class="sd">    to zero when the representations for mRNAs are moved to the unique molecule</span>
<span class="sd">    container.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">transcription</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span>

    <span class="n">rna_mass</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">mass_coeff</span>
        <span class="o">*</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">get_component_masses</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">]</span>
        <span class="p">)[</span><span class="s2">&quot;rnaMass&quot;</span><span class="p">]</span>
        <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_to_initial_cell_conversion_factor</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">ppgpp_regulation</span><span class="p">:</span>
        <span class="n">rna_expression</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">calculate_ppgpp_expression</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rna_expression</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_expression</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">trna_attenuation</span><span class="p">:</span>
        <span class="c1"># Need to adjust expression (calculated without attenuation) by basal_adjustment</span>
        <span class="c1"># to get the expected expression without any attenuation and then multiply</span>
        <span class="c1"># by the condition readthrough probability to get the condition specific expression</span>
        <span class="n">readthrough</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">attenuation_readthrough</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">]</span>
        <span class="n">basal_adjustment</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">attenuation_readthrough</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span>
        <span class="n">rna_expression</span><span class="p">[</span><span class="n">transcription</span><span class="o">.</span><span class="n">attenuated_rna_indices</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
            <span class="n">readthrough</span> <span class="o">/</span> <span class="n">basal_adjustment</span>
        <span class="p">)</span>
        <span class="n">rna_expression</span> <span class="o">/=</span> <span class="n">rna_expression</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">n_rnas</span> <span class="o">=</span> <span class="n">countsFromMassAndExpression</span><span class="p">(</span>
        <span class="n">rna_mass</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">g</span><span class="p">),</span>
        <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;mw&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">g</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">mol</span><span class="p">),</span>
        <span class="n">rna_expression</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">mol</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># Get indices for monomers in bulk counts array</span>
    <span class="n">rna_ids</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">bulk_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">rna_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">rna_ids</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>
    <span class="c1"># Calculate initial counts of each RNA from mutinomial distribution</span>
    <span class="n">bulk_counts</span><span class="p">[</span><span class="n">rna_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">n_rnas</span><span class="p">,</span> <span class="n">rna_expression</span><span class="p">)</span></div>



<div class="viewcode-block" id="initialize_mature_RNA">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_mature_RNA">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_mature_RNA</span><span class="p">(</span><span class="n">bulk_counts</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes counts of mature RNAs in the bulk molecule container using the</span>
<span class="sd">    counts of unprocessed RNAs. Also consolidates the different variants of each</span>
<span class="sd">    rRNA molecule into the main type.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">transcription</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span>
    <span class="n">rna_data</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span>
    <span class="n">unprocessed_rna_ids</span> <span class="o">=</span> <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">][</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_unprocessed&quot;</span><span class="p">]]</span>
    <span class="n">bulk_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">unprocessed_rna_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">unprocessed_rna_ids</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>

    <span class="c1"># Skip if there are no unprocessed RNAs represented</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unprocessed_rna_ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mature_rna_ids</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">mature_rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
        <span class="n">maturation_stoich_matrix</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_maturation_stoich_matrix</span>
        <span class="n">mature_rna_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">mature_rna_ids</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>

        <span class="c1"># Get counts of unprocessed RNAs</span>
        <span class="n">unprocessed_rna_counts</span> <span class="o">=</span> <span class="n">bulk_counts</span><span class="p">[</span><span class="n">unprocessed_rna_idx</span><span class="p">]</span>

        <span class="c1"># Assume all unprocessed RNAs are converted to mature RNAs</span>
        <span class="n">bulk_counts</span><span class="p">[</span><span class="n">unprocessed_rna_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bulk_counts</span><span class="p">[</span><span class="n">mature_rna_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">maturation_stoich_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="n">unprocessed_rna_counts</span>
        <span class="p">)</span>

    <span class="c1"># Get IDs of rRNAs</span>
    <span class="n">main_23s_rRNA_id</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">s50_23s_rRNA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">main_16s_rRNA_id</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">s30_16s_rRNA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">main_5s_rRNA_id</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">s50_5s_rRNA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">variant_23s_rRNA_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">s50_23s_rRNA</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">variant_16s_rRNA_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">s30_16s_rRNA</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">variant_5s_rRNA_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">s50_5s_rRNA</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Get indices of main and variant rRNAs</span>
    <span class="n">main_23s_rRNA_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">main_23s_rRNA_id</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>
    <span class="n">main_16s_rRNA_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">main_16s_rRNA_id</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>
    <span class="n">main_5s_rRNA_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">main_5s_rRNA_id</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>
    <span class="n">variant_23s_rRNA_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">variant_23s_rRNA_ids</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>
    <span class="n">variant_16s_rRNA_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">variant_16s_rRNA_ids</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>
    <span class="n">variant_5s_rRNA_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">variant_5s_rRNA_ids</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>

    <span class="c1"># Evolve states</span>
    <span class="n">bulk_counts</span><span class="p">[</span><span class="n">main_23s_rRNA_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bulk_counts</span><span class="p">[</span><span class="n">variant_23s_rRNA_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">bulk_counts</span><span class="p">[</span><span class="n">main_16s_rRNA_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bulk_counts</span><span class="p">[</span><span class="n">variant_16s_rRNA_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">bulk_counts</span><span class="p">[</span><span class="n">main_5s_rRNA_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">bulk_counts</span><span class="p">[</span><span class="n">variant_5s_rRNA_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">bulk_counts</span><span class="p">[</span><span class="n">variant_23s_rRNA_idx</span><span class="p">]</span> <span class="o">-=</span> <span class="n">bulk_counts</span><span class="p">[</span><span class="n">variant_23s_rRNA_idx</span><span class="p">]</span>
    <span class="n">bulk_counts</span><span class="p">[</span><span class="n">variant_16s_rRNA_idx</span><span class="p">]</span> <span class="o">-=</span> <span class="n">bulk_counts</span><span class="p">[</span><span class="n">variant_16s_rRNA_idx</span><span class="p">]</span>
    <span class="n">bulk_counts</span><span class="p">[</span><span class="n">variant_5s_rRNA_idx</span><span class="p">]</span> <span class="o">-=</span> <span class="n">bulk_counts</span><span class="p">[</span><span class="n">variant_5s_rRNA_idx</span><span class="p">]</span></div>



<span class="c1"># TODO: remove checks for zero concentrations (change to assertion)</span>
<span class="c1"># TODO: move any rescaling logic to KB/fitting</span>
<div class="viewcode-block" id="set_small_molecule_counts">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.set_small_molecule_counts">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_small_molecule_counts</span><span class="p">(</span>
    <span class="n">bulk_counts</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">media_id</span><span class="p">,</span> <span class="n">import_molecules</span><span class="p">,</span> <span class="n">mass_coeff</span><span class="p">,</span> <span class="n">cell_mass</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="n">doubling_time</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">]</span>

    <span class="n">conc_dict</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span><span class="o">.</span><span class="n">concentration_updates</span><span class="o">.</span><span class="n">concentrations_based_on_nutrients</span><span class="p">(</span>
        <span class="n">media_id</span><span class="o">=</span><span class="n">media_id</span><span class="p">,</span> <span class="n">imports</span><span class="o">=</span><span class="n">import_molecules</span>
    <span class="p">)</span>
    <span class="n">conc_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">getBiomassAsConcentrations</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">))</span>
    <span class="n">conc_dict</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_ids</span><span class="o">.</span><span class="n">ppGpp</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">growth_rate_parameters</span><span class="o">.</span><span class="n">get_ppGpp_conc</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">molecule_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">conc_dict</span><span class="p">)</span>
    <span class="n">bulk_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">molecule_concentrations</span> <span class="o">=</span> <span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">conc_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">molecule_ids</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">cell_mass</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">avg_cell_fraction_mass</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">get_component_masses</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">)</span>
        <span class="n">other_dry_mass</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">mass_coeff</span>
            <span class="o">*</span> <span class="p">(</span>
                <span class="n">avg_cell_fraction_mass</span><span class="p">[</span><span class="s2">&quot;proteinMass&quot;</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">avg_cell_fraction_mass</span><span class="p">[</span><span class="s2">&quot;rnaMass&quot;</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">avg_cell_fraction_mass</span><span class="p">[</span><span class="s2">&quot;dnaMass&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_to_initial_cell_conversion_factor</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">small_molecule_mass</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">fg</span>
        <span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">conc_dict</span><span class="p">:</span>
            <span class="n">mol_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>
            <span class="n">small_molecule_mass</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">bulk_counts</span><span class="p">[</span><span class="n">mol_idx</span><span class="p">]</span>
                <span class="o">*</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">getter</span><span class="o">.</span><span class="n">get_mass</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
                <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span>
            <span class="p">)</span>
        <span class="n">other_dry_mass</span> <span class="o">=</span> <span class="n">cell_mass</span> <span class="o">-</span> <span class="n">small_molecule_mass</span>

    <span class="n">masses_to_add</span><span class="p">,</span> <span class="n">counts_to_add</span> <span class="o">=</span> <span class="n">masses_and_counts_for_homeostatic_target</span><span class="p">(</span>
        <span class="n">other_dry_mass</span><span class="p">,</span>
        <span class="n">molecule_concentrations</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">getter</span><span class="o">.</span><span class="n">get_masses</span><span class="p">(</span><span class="n">molecule_ids</span><span class="p">),</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">cell_density</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">molecule_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">molecule_ids</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>
    <span class="n">bulk_counts</span><span class="p">[</span><span class="n">molecule_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts_to_add</span></div>



<div class="viewcode-block" id="initialize_complexation">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_complexation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_complexation</span><span class="p">(</span><span class="n">bulk_counts</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
    <span class="n">molecule_names</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">molecule_names</span>
    <span class="n">bulk_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">molecule_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">molecule_names</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="p">)</span>

    <span class="n">stoich_matrix</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">stoich_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span>
    <span class="p">)</span>

    <span class="n">molecule_counts</span> <span class="o">=</span> <span class="n">bulk_counts</span><span class="p">[</span><span class="n">molecule_idx</span><span class="p">]</span>
    <span class="n">updated_molecule_counts</span><span class="p">,</span> <span class="n">complexation_events</span> <span class="o">=</span> <span class="n">mccFormComplexesWithPrebuiltMatrices</span><span class="p">(</span>
        <span class="n">molecule_counts</span><span class="p">,</span>
        <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span>
        <span class="n">stoich_matrix</span><span class="p">,</span>
        <span class="o">*</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">prebuilt_matrices</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">bulk_counts</span><span class="p">[</span><span class="n">molecule_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_molecule_counts</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">updated_molecule_counts</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Negative counts after complexation&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="initialize_full_chromosome">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_full_chromosome">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_full_chromosome</span><span class="p">(</span><span class="n">unique_molecules</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">unique_id_rng</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes the counts of full chromosomes to one. The division_time of</span>
<span class="sd">    this initial chromosome is set to be zero for consistency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;full_chromosome&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
        <span class="s2">&quot;full_chromosome&quot;</span><span class="p">,</span>
        <span class="mi">1</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
        <span class="n">division_time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">has_triggered_division</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">domain_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="initialize_replication">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_replication">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_replication</span><span class="p">(</span>
    <span class="n">bulk_state</span><span class="p">,</span>
    <span class="n">unique_molecules</span><span class="p">,</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">cell_mass</span><span class="p">,</span>
    <span class="n">mechanistic_replisome</span><span class="p">,</span>
    <span class="n">unique_id_rng</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes replication by creating an appropriate number of replication</span>
<span class="sd">    forks given the cell growth rate. This also initializes the gene dosage</span>
<span class="sd">    bulk counts using the initial locations of the forks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine the number and location of replication forks at the start of</span>
    <span class="c1"># the cell cycle</span>
    <span class="c1"># Get growth rate constants</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">]</span><span class="o">.</span><span class="n">asUnit</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
    <span class="n">critical_mass</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">get_dna_critical_mass</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">replication_rate</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">basal_elongation_rate</span>

    <span class="c1"># Calculate length of replichore</span>
    <span class="n">genome_length</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">genome_length</span>
    <span class="n">replichore_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">genome_length</span><span class="p">)</span> <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">nt</span>

    <span class="c1"># Calculate the maximum number of replisomes that could be formed with</span>
    <span class="c1"># the existing counts of replisome subunits. If mechanistic_replisome option</span>
    <span class="c1"># is off, set to an arbitrary high number.</span>
    <span class="n">replisome_trimer_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">replisome_trimer_subunits</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">replisome_monomer_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">replisome_monomer_subunits</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">mechanistic_replisome</span><span class="p">:</span>
        <span class="n">n_max_replisomes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">replisome_trimer_idx</span><span class="p">]</span> <span class="o">//</span> <span class="mi">3</span><span class="p">,</span>
                    <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">replisome_monomer_idx</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_max_replisomes</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="c1"># Generate arrays specifying appropriate initial replication conditions</span>
    <span class="n">oric_state</span><span class="p">,</span> <span class="n">replisome_state</span><span class="p">,</span> <span class="n">domain_state</span> <span class="o">=</span> <span class="n">determine_chromosome_state</span><span class="p">(</span>
        <span class="n">tau</span><span class="p">,</span>
        <span class="n">replichore_length</span><span class="p">,</span>
        <span class="n">n_max_replisomes</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">no_child_place_holder</span><span class="p">,</span>
        <span class="n">cell_mass</span><span class="p">,</span>
        <span class="n">critical_mass</span><span class="p">,</span>
        <span class="n">replication_rate</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">n_oric</span> <span class="o">=</span> <span class="n">oric_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
    <span class="n">n_replisome</span> <span class="o">=</span> <span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
    <span class="n">n_domain</span> <span class="o">=</span> <span class="n">domain_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>

    <span class="c1"># Add OriC molecules with the proposed attributes</span>
    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;oriC&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
        <span class="s2">&quot;oriC&quot;</span><span class="p">,</span> <span class="n">n_oric</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">unique_id_rng</span><span class="p">,</span> <span class="n">domain_index</span><span class="o">=</span><span class="n">oric_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Add chromosome domain molecules with the proposed attributes</span>
    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;chromosome_domain&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
        <span class="s2">&quot;chromosome_domain&quot;</span><span class="p">,</span>
        <span class="n">n_domain</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
        <span class="n">domain_index</span><span class="o">=</span><span class="n">domain_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">],</span>
        <span class="n">child_domains</span><span class="o">=</span><span class="n">domain_state</span><span class="p">[</span><span class="s2">&quot;child_domains&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">n_replisome</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Update mass of replisomes if the mechanistic replisome option is set</span>
        <span class="k">if</span> <span class="n">mechanistic_replisome</span><span class="p">:</span>
            <span class="n">replisome_trimer_subunit_masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">sim_data</span><span class="o">.</span><span class="n">getter</span><span class="o">.</span><span class="n">get_submass_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span>
                        <span class="n">units</span><span class="o">.</span><span class="n">fg</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">count</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">replisome_trimer_subunits</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">replisome_monomer_subunit_masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">sim_data</span><span class="o">.</span><span class="n">getter</span><span class="o">.</span><span class="n">get_submass_array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span>
                        <span class="n">units</span><span class="o">.</span><span class="n">fg</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">count</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">replisome_monomer_subunits</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">replisome_mass_array</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">replisome_trimer_subunit_masses</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">replisome_monomer_subunit_masses</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">replisome_protein_mass</span> <span class="o">=</span> <span class="n">replisome_mass_array</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">replisome_protein_mass</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Update mass to account for DNA strands that have already been</span>
        <span class="c1"># elongated.</span>
        <span class="n">sequences</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">replication_sequences</span>
        <span class="n">fork_coordinates</span> <span class="o">=</span> <span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span>
        <span class="n">sequence_elongations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">fork_coordinates</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">mass_increase_dna</span> <span class="o">=</span> <span class="n">computeMassIncrease</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">sequences</span><span class="p">,</span> <span class="p">(</span><span class="n">n_replisome</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="n">sequence_elongations</span><span class="p">,</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">replication_monomer_weights</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">fg</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Add active replisomes as unique molecules and set attributes</span>
        <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;active_replisome&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
            <span class="s2">&quot;active_replisome&quot;</span><span class="p">,</span>
            <span class="n">n_replisome</span><span class="p">,</span>
            <span class="n">sim_data</span><span class="p">,</span>
            <span class="n">unique_id_rng</span><span class="p">,</span>
            <span class="n">domain_index</span><span class="o">=</span><span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">],</span>
            <span class="n">coordinates</span><span class="o">=</span><span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">],</span>
            <span class="n">right_replichore</span><span class="o">=</span><span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;right_replichore&quot;</span><span class="p">],</span>
            <span class="n">massDiff_DNA</span><span class="o">=</span><span class="n">mass_increase_dna</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">mass_increase_dna</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">massDiff_protein</span><span class="o">=</span><span class="n">replisome_protein_mass</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">mechanistic_replisome</span><span class="p">:</span>
            <span class="c1"># Remove replisome subunits from bulk molecules</span>
            <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">replisome_trimer_idx</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">n_replisome</span>
            <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">replisome_monomer_idx</span><span class="p">]</span> <span class="o">-=</span> <span class="n">n_replisome</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># For n_replisome = 0, still create an empty structured array with</span>
        <span class="c1"># the expected fields</span>
        <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;active_replisome&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
            <span class="s2">&quot;active_replisome&quot;</span><span class="p">,</span> <span class="n">n_replisome</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">unique_id_rng</span>
        <span class="p">)</span>

    <span class="c1"># Get coordinates of all genes, promoters and DnaA boxes</span>
    <span class="n">all_gene_coordinates</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span>
        <span class="s2">&quot;replication_coordinate&quot;</span>
    <span class="p">]</span>
    <span class="n">all_promoter_coordinates</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span>
        <span class="s2">&quot;replication_coordinate&quot;</span>
    <span class="p">]</span>
    <span class="n">all_DnaA_box_coordinates</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">motif_coordinates</span><span class="p">[</span>
        <span class="s2">&quot;DnaA_box&quot;</span>
    <span class="p">]</span>

    <span class="c1"># Define function that initializes attributes of sequence motifs given the</span>
    <span class="c1"># initial state of the chromosome</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_motif_attributes</span><span class="p">(</span><span class="n">all_motif_coordinates</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using the initial positions of replication forks, calculate attributes</span>
<span class="sd">        of unique molecules representing DNA motifs, given their positions on</span>
<span class="sd">        the genome.</span>

<span class="sd">        Args:</span>
<span class="sd">            all_motif_coordinates (ndarray): Genomic coordinates of DNA motifs,</span>
<span class="sd">            represented in a specific order</span>

<span class="sd">        Returns:</span>
<span class="sd">            motif_index: Indices of all motif copies, in the case where</span>
<span class="sd">            different indexes imply a different functional role</span>
<span class="sd">            motif_coordinates: Genomic coordinates of all motif copies</span>
<span class="sd">            motif_domain_index: Domain indexes of the chromosome domain that</span>
<span class="sd">            each motif copy belongs to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">motif_index</span><span class="p">,</span> <span class="n">motif_coordinates</span><span class="p">,</span> <span class="n">motif_domain_index</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">in_bounds</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">coordinates</span> <span class="o">&lt;</span> <span class="n">ub</span><span class="p">,</span> <span class="n">coordinates</span> <span class="o">&gt;</span> <span class="n">lb</span><span class="p">)</span>

        <span class="c1"># Loop through all chromosome domains</span>
        <span class="k">for</span> <span class="n">domain_idx</span> <span class="ow">in</span> <span class="n">domain_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">]:</span>
            <span class="c1"># If the domain is the mother domain of the initial chromosome,</span>
            <span class="k">if</span> <span class="n">domain_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n_replisome</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># No replisomes - all motifs should fall in this domain</span>
                    <span class="n">motif_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">all_motif_coordinates</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Get domain boundaries</span>
                    <span class="n">domain_boundaries</span> <span class="o">=</span> <span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">][</span>
                        <span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="p">]</span>

                    <span class="c1"># Add motifs outside of this boundary</span>
                    <span class="n">motif_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                        <span class="n">all_motif_coordinates</span> <span class="o">&gt;</span> <span class="n">domain_boundaries</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                        <span class="n">all_motif_coordinates</span> <span class="o">&lt;</span> <span class="n">domain_boundaries</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                    <span class="p">)</span>

            <span class="c1"># If the domain contains the origin,</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">domain_idx</span><span class="p">,</span> <span class="n">oric_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">]):</span>
                <span class="c1"># Get index of the parent domain</span>
                <span class="n">parent_domain_idx</span> <span class="o">=</span> <span class="n">domain_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">][</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">domain_state</span><span class="p">[</span><span class="s2">&quot;child_domains&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">domain_idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">]</span>

                <span class="c1"># Get domain boundaries of the parent domain</span>
                <span class="n">parent_domain_boundaries</span> <span class="o">=</span> <span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">][</span>
                    <span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">parent_domain_idx</span>
                <span class="p">]</span>

                <span class="c1"># Add motifs inside this boundary</span>
                <span class="n">motif_mask</span> <span class="o">=</span> <span class="n">in_bounds</span><span class="p">(</span>
                    <span class="n">all_motif_coordinates</span><span class="p">,</span>
                    <span class="n">parent_domain_boundaries</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                    <span class="n">parent_domain_boundaries</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                <span class="p">)</span>

            <span class="c1"># If the domain neither contains the origin nor the terminus,</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get index of the parent domain</span>
                <span class="n">parent_domain_idx</span> <span class="o">=</span> <span class="n">domain_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">][</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">domain_state</span><span class="p">[</span><span class="s2">&quot;child_domains&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">domain_idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">]</span>

                <span class="c1"># Get domain boundaries of the parent domain</span>
                <span class="n">parent_domain_boundaries</span> <span class="o">=</span> <span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">][</span>
                    <span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">parent_domain_idx</span>
                <span class="p">]</span>

                <span class="c1"># Get domain boundaries of this domain</span>
                <span class="n">domain_boundaries</span> <span class="o">=</span> <span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">][</span>
                    <span class="n">replisome_state</span><span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">domain_idx</span>
                <span class="p">]</span>

                <span class="c1"># Add motifs between the boundaries</span>
                <span class="n">motif_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                    <span class="n">in_bounds</span><span class="p">(</span>
                        <span class="n">all_motif_coordinates</span><span class="p">,</span>
                        <span class="n">domain_boundaries</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                        <span class="n">parent_domain_boundaries</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                    <span class="p">),</span>
                    <span class="n">in_bounds</span><span class="p">(</span>
                        <span class="n">all_motif_coordinates</span><span class="p">,</span>
                        <span class="n">parent_domain_boundaries</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                        <span class="n">domain_boundaries</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                    <span class="p">),</span>
                <span class="p">)</span>

            <span class="c1"># Append attributes to existing list</span>
            <span class="n">motif_index</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">motif_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">motif_coordinates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">all_motif_coordinates</span><span class="p">[</span><span class="n">motif_mask</span><span class="p">])</span>
            <span class="n">motif_domain_index</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">motif_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">domain_idx</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">motif_index</span><span class="p">,</span> <span class="n">motif_coordinates</span><span class="p">,</span> <span class="n">motif_domain_index</span>

    <span class="c1"># Use function to get attributes for promoters and DnaA boxes</span>
    <span class="n">TU_index</span><span class="p">,</span> <span class="n">promoter_coordinates</span><span class="p">,</span> <span class="n">promoter_domain_index</span> <span class="o">=</span> <span class="n">get_motif_attributes</span><span class="p">(</span>
        <span class="n">all_promoter_coordinates</span>
    <span class="p">)</span>
    <span class="n">cistron_index</span><span class="p">,</span> <span class="n">gene_coordinates</span><span class="p">,</span> <span class="n">gene_domain_index</span> <span class="o">=</span> <span class="n">get_motif_attributes</span><span class="p">(</span>
        <span class="n">all_gene_coordinates</span>
    <span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">DnaA_box_coordinates</span><span class="p">,</span> <span class="n">DnaA_box_domain_index</span> <span class="o">=</span> <span class="n">get_motif_attributes</span><span class="p">(</span>
        <span class="n">all_DnaA_box_coordinates</span>
    <span class="p">)</span>

    <span class="c1"># Add promoters as unique molecules and set attributes</span>
    <span class="c1"># Note: the bound_TF attribute is properly initialized in the function</span>
    <span class="c1"># initialize_transcription_factors</span>
    <span class="n">n_promoter</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">TU_index</span><span class="p">)</span>
    <span class="n">n_tf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">tf_ids</span><span class="p">)</span>

    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;promoter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
        <span class="s2">&quot;promoter&quot;</span><span class="p">,</span>
        <span class="n">n_promoter</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
        <span class="n">domain_index</span><span class="o">=</span><span class="n">promoter_domain_index</span><span class="p">,</span>
        <span class="n">coordinates</span><span class="o">=</span><span class="n">promoter_coordinates</span><span class="p">,</span>
        <span class="n">TU_index</span><span class="o">=</span><span class="n">TU_index</span><span class="p">,</span>
        <span class="n">bound_TF</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_promoter</span><span class="p">,</span> <span class="n">n_tf</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># Add genes as unique molecules and set attributes</span>
    <span class="n">n_gene</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cistron_index</span><span class="p">)</span>

    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;gene&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
        <span class="s2">&quot;gene&quot;</span><span class="p">,</span>
        <span class="n">n_gene</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
        <span class="n">cistron_index</span><span class="o">=</span><span class="n">cistron_index</span><span class="p">,</span>
        <span class="n">coordinates</span><span class="o">=</span><span class="n">gene_coordinates</span><span class="p">,</span>
        <span class="n">domain_index</span><span class="o">=</span><span class="n">gene_domain_index</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Add DnaA boxes as unique molecules and set attributes</span>
    <span class="n">n_DnaA_box</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DnaA_box_coordinates</span><span class="p">)</span>

    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;DnaA_box&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
        <span class="s2">&quot;DnaA_box&quot;</span><span class="p">,</span>
        <span class="n">n_DnaA_box</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
        <span class="n">domain_index</span><span class="o">=</span><span class="n">DnaA_box_domain_index</span><span class="p">,</span>
        <span class="n">coordinates</span><span class="o">=</span><span class="n">DnaA_box_coordinates</span><span class="p">,</span>
        <span class="n">DnaA_bound</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_DnaA_box</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="initialize_transcription_factors">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_transcription_factors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_transcription_factors</span><span class="p">(</span>
    <span class="n">bulk_state</span><span class="p">,</span> <span class="n">unique_molecules</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">random_state</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize transcription factors that are bound to the chromosome. For each</span>
<span class="sd">    type of transcription factor, this function calculates the total number of</span>
<span class="sd">    transcription factors that should be bound to the chromosome using the</span>
<span class="sd">    binding probabilities of each transcription factor and the number of</span>
<span class="sd">    available promoter sites. The calculated number of transcription factors</span>
<span class="sd">    are then distributed randomly to promoters, whose bound_TF attributes and</span>
<span class="sd">    submasses are updated correspondingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get transcription factor properties from sim_data</span>
    <span class="n">tf_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">tf_ids</span>
    <span class="n">tf_to_tf_type</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">tf_to_tf_type</span>
    <span class="n">p_promoter_bound_TF</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">p_promoter_bound_tf</span>

    <span class="c1"># Build dict that maps TFs to transcription units they regulate</span>
    <span class="n">delta_prob</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">delta_prob</span>
    <span class="n">TF_to_TU_idx</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tf_ids</span><span class="p">):</span>
        <span class="n">TF_to_TU_idx</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_prob</span><span class="p">[</span><span class="s2">&quot;deltaI&quot;</span><span class="p">][</span><span class="n">delta_prob</span><span class="p">[</span><span class="s2">&quot;deltaJ&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>

    <span class="c1"># Get views into bulk molecule representations of transcription factors</span>
    <span class="n">active_tf_view</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">inactive_tf_view</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">active_tf_view_idx</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">inactive_tf_view_idx</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">tf_ids</span><span class="p">:</span>
        <span class="n">tf_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
        <span class="n">active_tf_view</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">tf_idx</span><span class="p">]</span>
        <span class="n">active_tf_view_idx</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf_idx</span>

        <span class="k">if</span> <span class="n">tf_to_tf_type</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;1CS&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tf</span> <span class="o">==</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">active_to_bound</span><span class="p">[</span><span class="n">tf</span><span class="p">]:</span>
                <span class="n">inactive_tf_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
                    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">get_unbound</span><span class="p">(</span><span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">),</span>
                    <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">inactive_tf_view</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">inactive_tf_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inactive_tf_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
                    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">active_to_bound</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span>
                    <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">,</span>
                    <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">inactive_tf_view</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">inactive_tf_idx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">tf_to_tf_type</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;2CS&quot;</span><span class="p">:</span>
            <span class="n">inactive_tf_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">two_component_system</span><span class="o">.</span><span class="n">active_to_inactive_tf</span><span class="p">[</span><span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">],</span>
                <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">inactive_tf_view</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">inactive_tf_idx</span><span class="p">]</span>
        <span class="n">inactive_tf_view_idx</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="n">inactive_tf_idx</span>

    <span class="c1"># Get masses of active transcription factors</span>
    <span class="n">tf_indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">tf_id</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tf_id</span> <span class="ow">in</span> <span class="n">tf_ids</span><span class="p">]</span>
    <span class="n">active_tf_masses</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">][</span><span class="n">tf_indexes</span><span class="p">]</span>
        <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span>
    <span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">fg</span><span class="p">)</span>

    <span class="c1"># Get TU indices of promoters</span>
    <span class="n">TU_index</span> <span class="o">=</span> <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;promoter&quot;</span><span class="p">][</span><span class="s2">&quot;TU_index&quot;</span><span class="p">]</span>

    <span class="c1"># Initialize bound_TF array</span>
    <span class="n">bound_TF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">TU_index</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">tf_ids</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">tf_idx</span><span class="p">,</span> <span class="n">tf_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tf_ids</span><span class="p">):</span>
        <span class="c1"># Get counts of transcription factors</span>
        <span class="n">active_tf_counts</span> <span class="o">=</span> <span class="n">active_tf_view</span><span class="p">[</span><span class="n">tf_id</span><span class="p">]</span>

        <span class="c1"># If there are no active transcription factors at initialization,</span>
        <span class="c1"># continue to the next transcription factor</span>
        <span class="k">if</span> <span class="n">active_tf_counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Compute probability of binding the promoter</span>
        <span class="k">if</span> <span class="n">tf_to_tf_type</span><span class="p">[</span><span class="n">tf_id</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;0CS&quot;</span><span class="p">:</span>
            <span class="n">p_promoter_bound</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inactive_tf_counts</span> <span class="o">=</span> <span class="n">inactive_tf_view</span><span class="p">[</span><span class="n">tf_id</span><span class="p">]</span>
            <span class="n">p_promoter_bound</span> <span class="o">=</span> <span class="n">p_promoter_bound_TF</span><span class="p">(</span><span class="n">active_tf_counts</span><span class="p">,</span> <span class="n">inactive_tf_counts</span><span class="p">)</span>

        <span class="c1"># Determine the number of available promoter sites</span>
        <span class="n">available_promoters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">TU_index</span><span class="p">,</span> <span class="n">TF_to_TU_idx</span><span class="p">[</span><span class="n">tf_id</span><span class="p">])</span>
        <span class="n">n_available_promoters</span> <span class="o">=</span> <span class="n">available_promoters</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Calculate the number of promoters that should be bound</span>
        <span class="n">n_to_bind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
            <span class="n">stochasticRound</span><span class="p">(</span>
                <span class="n">random_state</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_available_promoters</span><span class="p">,</span> <span class="n">p_promoter_bound</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="n">bound_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_available_promoters</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_to_bind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Determine randomly which DNA targets to bind based on which of</span>
            <span class="c1"># the following is more limiting:</span>
            <span class="c1"># number of promoter sites to bind, or number of active</span>
            <span class="c1"># transcription factors</span>
            <span class="n">bound_locs</span><span class="p">[</span>
                <span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                    <span class="n">n_available_promoters</span><span class="p">,</span>
                    <span class="n">size</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">n_to_bind</span><span class="p">,</span> <span class="n">active_tf_view</span><span class="p">[</span><span class="n">tf_id</span><span class="p">]),</span>
                    <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Update count of free transcription factors</span>
            <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">active_tf_view_idx</span><span class="p">[</span><span class="n">tf_id</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">bound_locs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="c1"># Update bound_TF array</span>
            <span class="n">bound_TF</span><span class="p">[</span><span class="n">available_promoters</span><span class="p">,</span> <span class="n">tf_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_locs</span>

    <span class="c1"># Calculate masses of bound TFs</span>
    <span class="n">mass_diffs</span> <span class="o">=</span> <span class="n">bound_TF</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">active_tf_masses</span><span class="p">)</span>

    <span class="c1"># Reset bound_TF attribute of promoters</span>
    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;promoter&quot;</span><span class="p">][</span><span class="s2">&quot;bound_TF&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_TF</span>

    <span class="c1"># Add mass_diffs array to promoter submass</span>
    <span class="k">for</span> <span class="n">submass</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">submass_name_to_index</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;promoter&quot;</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;massDiff_</span><span class="si">{</span><span class="n">submass</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mass_diffs</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span></div>



<div class="viewcode-block" id="initialize_transcription">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_transcription">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_transcription</span><span class="p">(</span>
    <span class="n">bulk_state</span><span class="p">,</span>
    <span class="n">unique_molecules</span><span class="p">,</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">random_state</span><span class="p">,</span>
    <span class="n">unique_id_rng</span><span class="p">,</span>
    <span class="n">ppgpp_regulation</span><span class="p">,</span>
    <span class="n">trna_attenuation</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Activate RNA polymerases as unique molecules, and distribute them along</span>
<span class="sd">    lengths of trancription units, while decreasing counts of unactivated RNA</span>
<span class="sd">    polymerases (APORNAP-CPLX[c]). Also initialize unique molecule</span>
<span class="sd">    representations of fully transcribed mRNAs and partially transcribed RNAs,</span>
<span class="sd">    using counts of mRNAs initialized as bulk molecules, and the attributes of</span>
<span class="sd">    initialized RNA polymerases. The counts of full mRNAs represented as bulk</span>
<span class="sd">    molecules are reset to zero.</span>

<span class="sd">    RNA polymerases are placed randomly across the length of each transcription</span>
<span class="sd">    unit, with the synthesis probabilities for each TU determining the number of</span>
<span class="sd">    RNA polymerases placed at each gene.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load parameters</span>
    <span class="n">rna_lengths</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span>
    <span class="n">rna_masses</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;mw&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span>
    <span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">fg</span><span class="p">)</span>
    <span class="n">current_media_id</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">conditions</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">][</span><span class="s2">&quot;nutrients&quot;</span><span class="p">]</span>
    <span class="n">frac_active_rnap</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnapFractionActiveDict</span><span class="p">[</span>
        <span class="n">current_media_id</span>
    <span class="p">]</span>
    <span class="n">inactive_rnap_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_ids</span><span class="o">.</span><span class="n">full_RNAP</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">inactive_RNAP_counts</span> <span class="o">=</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">inactive_rnap_idx</span><span class="p">]</span>
    <span class="n">rna_sequences</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">transcription_sequences</span>
    <span class="n">nt_weights</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">transcription_monomer_weights</span>
    <span class="n">end_weight</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">transcription_end_weight</span>
    <span class="n">replichore_lengths</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">replichore_lengths</span>
    <span class="n">chromosome_length</span> <span class="o">=</span> <span class="n">replichore_lengths</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Number of rnaPoly to activate</span>
    <span class="n">n_RNAPs_to_activate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">frac_active_rnap</span> <span class="o">*</span> <span class="n">inactive_RNAP_counts</span><span class="p">)</span>

    <span class="c1"># Get attributes of promoters</span>
    <span class="n">TU_index</span><span class="p">,</span> <span class="n">bound_TF</span><span class="p">,</span> <span class="n">domain_index_promoters</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">(</span>
        <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;promoter&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;TU_index&quot;</span><span class="p">,</span> <span class="s2">&quot;bound_TF&quot;</span><span class="p">,</span> <span class="s2">&quot;domain_index&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Parameters for rnaSynthProb</span>
    <span class="k">if</span> <span class="n">ppgpp_regulation</span><span class="p">:</span>
        <span class="n">doubling_time</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">]</span>
        <span class="n">ppgpp_conc</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">growth_rate_parameters</span><span class="o">.</span><span class="n">get_ppGpp_conc</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">)</span>
        <span class="n">basal_prob</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">synth_prob_from_ppgpp</span><span class="p">(</span>
            <span class="n">ppgpp_conc</span><span class="p">,</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">get_average_copy_number</span>
        <span class="p">)</span>
        <span class="n">ppgpp_scale</span> <span class="o">=</span> <span class="n">basal_prob</span><span class="p">[</span><span class="n">TU_index</span><span class="p">]</span>
        <span class="c1"># Use original delta prob if no ppGpp basal prob</span>
        <span class="n">ppgpp_scale</span><span class="p">[</span><span class="n">ppgpp_scale</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">basal_prob</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">basal_prob</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ppgpp_scale</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">trna_attenuation</span><span class="p">:</span>
        <span class="n">basal_prob</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">attenuated_rna_indices</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">attenuation_basal_prob_adjustments</span>
        <span class="p">)</span>
    <span class="n">n_TUs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basal_prob</span><span class="p">)</span>
    <span class="n">delta_prob_matrix</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">get_delta_prob_matrix</span><span class="p">(</span>
        <span class="n">dense</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ppgpp</span><span class="o">=</span><span class="n">ppgpp_regulation</span>
    <span class="p">)</span>

    <span class="c1"># Synthesis probabilities for different categories of genes</span>
    <span class="n">rna_synth_prob_fractions</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbFraction</span>
    <span class="n">rna_synth_prob_R_protein</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbRProtein</span>
    <span class="n">rna_synth_prob_rna_polymerase</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbRnaPolymerase</span>
    <span class="p">)</span>

    <span class="c1"># Get coordinates and transcription directions of transcription units</span>
    <span class="n">replication_coordinate</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span>
        <span class="s2">&quot;replication_coordinate&quot;</span>
    <span class="p">]</span>
    <span class="n">transcription_direction</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_forward&quot;</span><span class="p">]</span>

    <span class="c1"># Determine changes from genetic perturbations</span>
    <span class="n">genetic_perturbations</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">perturbations</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="s2">&quot;genetic_perturbations&quot;</span><span class="p">,</span> <span class="p">{})</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">perturbations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">probability_indexes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">genetic_perturbations</span><span class="p">[</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">rna_data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">genetic_perturbations</span>
        <span class="p">]</span>

        <span class="n">genetic_perturbations</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;fixedRnaIdxs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">probability_indexes</span><span class="p">],</span>
            <span class="s2">&quot;fixedSynthProbs&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">probability_indexes</span><span class="p">],</span>
        <span class="p">}</span>

    <span class="c1"># ID Groups</span>
    <span class="n">idx_rRNA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_rRNA&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">idx_mRNA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_mRNA&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">idx_tRNA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_tRNA&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">idx_rprotein</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;includes_ribosomal_protein&quot;</span><span class="p">]</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">idx_rnap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;includes_RNAP&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Calculate probabilities of the RNAP binding to the promoters</span>
    <span class="n">promoter_init_probs</span> <span class="o">=</span> <span class="n">basal_prob</span><span class="p">[</span><span class="n">TU_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">ppgpp_scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
        <span class="n">delta_prob_matrix</span><span class="p">[</span><span class="n">TU_index</span><span class="p">,</span> <span class="p">:],</span> <span class="n">bound_TF</span>
    <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">genetic_perturbations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">rescale_initiation_probs</span><span class="p">(</span>
            <span class="n">promoter_init_probs</span><span class="p">,</span>
            <span class="n">TU_index</span><span class="p">,</span>
            <span class="n">genetic_perturbations</span><span class="p">[</span><span class="s2">&quot;fixedSynthProbs&quot;</span><span class="p">],</span>
            <span class="n">genetic_perturbations</span><span class="p">[</span><span class="s2">&quot;fixedRnaIdxs&quot;</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="c1"># Adjust probabilities to not be negative</span>
    <span class="n">promoter_init_probs</span><span class="p">[</span><span class="n">promoter_init_probs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">promoter_init_probs</span> <span class="o">/=</span> <span class="n">promoter_init_probs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">promoter_init_probs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Have negative RNA synthesis probabilities&quot;</span><span class="p">)</span>

    <span class="c1"># Adjust synthesis probabilities depending on environment</span>
    <span class="n">synth_prob_fractions</span> <span class="o">=</span> <span class="n">rna_synth_prob_fractions</span><span class="p">[</span><span class="n">current_media_id</span><span class="p">]</span>

    <span class="c1"># Create masks for different types of RNAs</span>
    <span class="n">is_mRNA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">TU_index</span><span class="p">,</span> <span class="n">idx_mRNA</span><span class="p">)</span>
    <span class="n">is_tRNA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">TU_index</span><span class="p">,</span> <span class="n">idx_tRNA</span><span class="p">)</span>
    <span class="n">is_rRNA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">TU_index</span><span class="p">,</span> <span class="n">idx_rRNA</span><span class="p">)</span>
    <span class="n">is_rprotein</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">TU_index</span><span class="p">,</span> <span class="n">idx_rprotein</span><span class="p">)</span>
    <span class="n">is_rnap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">TU_index</span><span class="p">,</span> <span class="n">idx_rnap</span><span class="p">)</span>
    <span class="n">is_fixed</span> <span class="o">=</span> <span class="n">is_tRNA</span> <span class="o">|</span> <span class="n">is_rRNA</span> <span class="o">|</span> <span class="n">is_rprotein</span> <span class="o">|</span> <span class="n">is_rnap</span>

    <span class="c1"># Rescale initiation probabilities based on type of RNA</span>
    <span class="n">promoter_init_probs</span><span class="p">[</span><span class="n">is_mRNA</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
        <span class="n">synth_prob_fractions</span><span class="p">[</span><span class="s2">&quot;mRna&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">promoter_init_probs</span><span class="p">[</span><span class="n">is_mRNA</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">promoter_init_probs</span><span class="p">[</span><span class="n">is_tRNA</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
        <span class="n">synth_prob_fractions</span><span class="p">[</span><span class="s2">&quot;tRna&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">promoter_init_probs</span><span class="p">[</span><span class="n">is_tRNA</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="n">promoter_init_probs</span><span class="p">[</span><span class="n">is_rRNA</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
        <span class="n">synth_prob_fractions</span><span class="p">[</span><span class="s2">&quot;rRna&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">promoter_init_probs</span><span class="p">[</span><span class="n">is_rRNA</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># Set fixed synthesis probabilities for RProteins and RNAPs</span>
    <span class="n">rescale_initiation_probs</span><span class="p">(</span>
        <span class="n">promoter_init_probs</span><span class="p">,</span>
        <span class="n">TU_index</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">rna_synth_prob_R_protein</span><span class="p">[</span><span class="n">current_media_id</span><span class="p">],</span>
                <span class="n">rna_synth_prob_rna_polymerase</span><span class="p">[</span><span class="n">current_media_id</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">idx_rprotein</span><span class="p">,</span> <span class="n">idx_rnap</span><span class="p">)),</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="n">promoter_init_probs</span><span class="p">[</span><span class="n">is_fixed</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1.0</span>

    <span class="c1"># Adjust for attenuation that will stop transcription after initiation</span>
    <span class="k">if</span> <span class="n">trna_attenuation</span><span class="p">:</span>
        <span class="n">attenuation_readthrough</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">idx</span><span class="p">:</span> <span class="n">prob</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">attenuated_rna_indices</span><span class="p">,</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">attenuation_readthrough</span><span class="p">[</span>
                    <span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span>
                <span class="p">],</span>
            <span class="p">)</span>
        <span class="p">}</span>
        <span class="n">readthrough_adjustment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">attenuation_readthrough</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">TU_index</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">promoter_init_probs</span> <span class="o">*=</span> <span class="n">readthrough_adjustment</span>

    <span class="n">scale_the_rest_by</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mf">1.0</span> <span class="o">-</span> <span class="n">promoter_init_probs</span><span class="p">[</span><span class="n">is_fixed</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">)</span> <span class="o">/</span> <span class="n">promoter_init_probs</span><span class="p">[</span><span class="o">~</span><span class="n">is_fixed</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">promoter_init_probs</span><span class="p">[</span><span class="o">~</span><span class="n">is_fixed</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scale_the_rest_by</span>

    <span class="c1"># normalize to length of rna</span>
    <span class="n">init_prob_length_adjusted</span> <span class="o">=</span> <span class="n">promoter_init_probs</span> <span class="o">*</span> <span class="n">rna_lengths</span><span class="p">[</span><span class="n">TU_index</span><span class="p">]</span>
    <span class="n">init_prob_normalized</span> <span class="o">=</span> <span class="n">init_prob_length_adjusted</span> <span class="o">/</span> <span class="n">init_prob_length_adjusted</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Sample a multinomial distribution of synthesis probabilities to determine</span>
    <span class="c1"># what RNA are initialized</span>
    <span class="n">n_initiations</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span><span class="n">n_RNAPs_to_activate</span><span class="p">,</span> <span class="n">init_prob_normalized</span><span class="p">)</span>

    <span class="c1"># Build array of transcription unit indexes for partially transcribed mRNAs</span>
    <span class="c1"># and domain indexes for RNAPs</span>
    <span class="n">TU_index_partial_RNAs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">TU_index</span><span class="p">,</span> <span class="n">n_initiations</span><span class="p">)</span>
    <span class="n">domain_index_rnap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">domain_index_promoters</span><span class="p">,</span> <span class="n">n_initiations</span><span class="p">)</span>

    <span class="c1"># Build arrays of starting coordinates and transcription directions</span>
    <span class="n">starting_coordinates</span> <span class="o">=</span> <span class="n">replication_coordinate</span><span class="p">[</span><span class="n">TU_index_partial_RNAs</span><span class="p">]</span>
    <span class="n">is_forward</span> <span class="o">=</span> <span class="n">transcription_direction</span><span class="p">[</span><span class="n">TU_index_partial_RNAs</span><span class="p">]</span>

    <span class="c1"># Randomly advance RNAPs along the transcription units</span>
    <span class="c1"># TODO (Eran): make sure there aren&#39;t any RNAPs at same location on same TU</span>
    <span class="n">updated_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_RNAPs_to_activate</span><span class="p">)</span> <span class="o">*</span> <span class="n">rna_lengths</span><span class="p">[</span><span class="n">TU_index_partial_RNAs</span><span class="p">],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Rescale boolean array of directions to an array of 1&#39;s and -1&#39;s.</span>
    <span class="n">direction_rescaled</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">is_forward</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="c1"># Compute the updated coordinates of RNAPs. Coordinates of RNAPs moving in</span>
    <span class="c1"># the positive direction are increased, whereas coordinates of RNAPs moving</span>
    <span class="c1"># in the negative direction are decreased.</span>
    <span class="n">updated_coordinates</span> <span class="o">=</span> <span class="n">starting_coordinates</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
        <span class="n">direction_rescaled</span><span class="p">,</span> <span class="n">updated_lengths</span>
    <span class="p">)</span>

    <span class="c1"># Reset coordinates of RNAPs that cross the boundaries between right and</span>
    <span class="c1"># left replichores</span>
    <span class="n">updated_coordinates</span><span class="p">[</span><span class="n">updated_coordinates</span> <span class="o">&gt;</span> <span class="n">replichore_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-=</span> <span class="p">(</span>
        <span class="n">chromosome_length</span>
    <span class="p">)</span>
    <span class="n">updated_coordinates</span><span class="p">[</span><span class="n">updated_coordinates</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">replichore_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+=</span> <span class="p">(</span>
        <span class="n">chromosome_length</span>
    <span class="p">)</span>

    <span class="c1"># Update mass</span>
    <span class="n">sequences</span> <span class="o">=</span> <span class="n">rna_sequences</span><span class="p">[</span><span class="n">TU_index_partial_RNAs</span><span class="p">]</span>
    <span class="n">added_mass</span> <span class="o">=</span> <span class="n">computeMassIncrease</span><span class="p">(</span><span class="n">sequences</span><span class="p">,</span> <span class="n">updated_lengths</span><span class="p">,</span> <span class="n">nt_weights</span><span class="p">)</span>
    <span class="n">added_mass</span><span class="p">[</span><span class="n">updated_lengths</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">end_weight</span>  <span class="c1"># add endWeight to all new Rna</span>

    <span class="c1"># Masses of partial mRNAs are counted as mRNA mass as they are already</span>
    <span class="c1"># functional, but the masses of other types of partial RNAs are counted as</span>
    <span class="c1"># generic RNA mass.</span>
    <span class="n">added_RNA_mass</span> <span class="o">=</span> <span class="n">added_mass</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">added_mRNA_mass</span> <span class="o">=</span> <span class="n">added_mass</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">is_mRNA_partial_RNAs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">TU_index_partial_RNAs</span><span class="p">,</span> <span class="n">idx_mRNA</span><span class="p">)</span>
    <span class="n">added_RNA_mass</span><span class="p">[</span><span class="n">is_mRNA_partial_RNAs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">added_mRNA_mass</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">is_mRNA_partial_RNAs</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Add active RNAPs and get their unique indexes</span>
    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;active_RNAP&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
        <span class="s2">&quot;active_RNAP&quot;</span><span class="p">,</span>
        <span class="n">n_RNAPs_to_activate</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
        <span class="n">domain_index</span><span class="o">=</span><span class="n">domain_index_rnap</span><span class="p">,</span>
        <span class="n">coordinates</span><span class="o">=</span><span class="n">updated_coordinates</span><span class="p">,</span>
        <span class="n">is_forward</span><span class="o">=</span><span class="n">is_forward</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Decrement counts of bulk inactive RNAPs</span>
    <span class="n">rnap_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_ids</span><span class="o">.</span><span class="n">full_RNAP</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">rnap_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inactive_RNAP_counts</span> <span class="o">-</span> <span class="n">n_RNAPs_to_activate</span>

    <span class="c1"># Add partially transcribed RNAs</span>
    <span class="n">partial_rnas</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
        <span class="s2">&quot;RNA&quot;</span><span class="p">,</span>
        <span class="n">n_RNAPs_to_activate</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
        <span class="n">TU_index</span><span class="o">=</span><span class="n">TU_index_partial_RNAs</span><span class="p">,</span>
        <span class="n">transcript_length</span><span class="o">=</span><span class="n">updated_lengths</span><span class="p">,</span>
        <span class="n">is_mRNA</span><span class="o">=</span><span class="n">is_mRNA_partial_RNAs</span><span class="p">,</span>
        <span class="n">is_full_transcript</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_RNAPs_to_activate</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
        <span class="n">can_translate</span><span class="o">=</span><span class="n">is_mRNA_partial_RNAs</span><span class="p">,</span>
        <span class="n">RNAP_index</span><span class="o">=</span><span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;active_RNAP&quot;</span><span class="p">][</span><span class="s2">&quot;unique_index&quot;</span><span class="p">],</span>
        <span class="n">massDiff_nonspecific_RNA</span><span class="o">=</span><span class="n">added_RNA_mass</span><span class="p">,</span>
        <span class="n">massDiff_mRNA</span><span class="o">=</span><span class="n">added_mRNA_mass</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Get counts of mRNAs initialized as bulk molecules</span>
    <span class="n">mRNA_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">][</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_mRNA&quot;</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">mRNA_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">mRNA_ids</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">mRNA_counts</span> <span class="o">=</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">mRNA_idx</span><span class="p">]</span>

    <span class="c1"># Subtract number of partially transcribed mRNAs that were initialized.</span>
    <span class="c1"># Note: some mRNAs with high degradation rates have more partial mRNAs than</span>
    <span class="c1"># the expected total number of mRNAs - for these mRNAs we simply set the</span>
    <span class="c1"># initial full mRNA counts to be zero.</span>
    <span class="n">partial_mRNA_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
        <span class="n">TU_index_partial_RNAs</span><span class="p">[</span><span class="n">is_mRNA_partial_RNAs</span><span class="p">],</span> <span class="n">minlength</span><span class="o">=</span><span class="n">n_TUs</span>
    <span class="p">)[</span><span class="n">idx_mRNA</span><span class="p">]</span>
    <span class="n">full_mRNA_counts</span> <span class="o">=</span> <span class="p">(</span><span class="n">mRNA_counts</span> <span class="o">-</span> <span class="n">partial_mRNA_counts</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Get array of TU indexes for each full mRNA</span>
    <span class="n">TU_index_full_mRNAs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">idx_mRNA</span><span class="p">,</span> <span class="n">full_mRNA_counts</span><span class="p">)</span>

    <span class="c1"># Add fully transcribed mRNAs. The RNAP_index attribute of these molecules</span>
    <span class="c1"># are set to -1.</span>
    <span class="n">full_rnas</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
        <span class="s2">&quot;RNA&quot;</span><span class="p">,</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">TU_index_full_mRNAs</span><span class="p">),</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
        <span class="n">TU_index</span><span class="o">=</span><span class="n">TU_index_full_mRNAs</span><span class="p">,</span>
        <span class="n">transcript_length</span><span class="o">=</span><span class="n">rna_lengths</span><span class="p">[</span><span class="n">TU_index_full_mRNAs</span><span class="p">],</span>
        <span class="n">is_mRNA</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">TU_index_full_mRNAs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
        <span class="n">is_full_transcript</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">TU_index_full_mRNAs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
        <span class="n">can_translate</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">TU_index_full_mRNAs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
        <span class="n">RNAP_index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">TU_index_full_mRNAs</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
        <span class="n">massDiff_mRNA</span><span class="o">=</span><span class="n">rna_masses</span><span class="p">[</span><span class="n">TU_index_full_mRNAs</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;RNA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">partial_rnas</span><span class="p">,</span> <span class="n">full_rnas</span><span class="p">))</span>
    <span class="c1"># Have to recreate unique indices or else there will be conflicts between</span>
    <span class="c1"># full and partial RNAs</span>
    <span class="n">unique_prefix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;RNA&quot;</span><span class="p">][</span><span class="s2">&quot;unique_index&quot;</span><span class="p">])</span>
    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;RNA&quot;</span><span class="p">][</span><span class="s2">&quot;unique_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
        <span class="n">unique_prefix</span><span class="p">,</span> <span class="n">unique_prefix</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;RNA&quot;</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;RNA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MetadataArray</span><span class="p">(</span>
        <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;RNA&quot;</span><span class="p">],</span>
        <span class="n">unique_prefix</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;RNA&quot;</span><span class="p">]),</span>
    <span class="p">)</span>

    <span class="c1"># Reset counts of bulk mRNAs to zero</span>
    <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">mRNA_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span></div>



<div class="viewcode-block" id="initialize_chromosomal_segments">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_chromosomal_segments">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_chromosomal_segments</span><span class="p">(</span><span class="n">unique_molecules</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">unique_id_rng</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize unique molecule representations of chromosomal segments. All</span>
<span class="sd">    chromosomal segments are assumed to be at their relaxed states upon</span>
<span class="sd">    initialization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load parameters</span>
    <span class="n">relaxed_DNA_base_pairs_per_turn</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">chromosome_structure</span><span class="o">.</span><span class="n">relaxed_DNA_base_pairs_per_turn</span>
    <span class="p">)</span>
    <span class="n">terC_index</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">chromosome_structure</span><span class="o">.</span><span class="n">terC_dummy_molecule_index</span>
    <span class="n">replichore_lengths</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">replichore_lengths</span>
    <span class="n">min_coordinates</span> <span class="o">=</span> <span class="o">-</span><span class="n">replichore_lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">max_coordinates</span> <span class="o">=</span> <span class="n">replichore_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Get attributes of replisomes, active RNAPs, chromosome domains, full</span>
    <span class="c1"># chromosomes, and oriCs</span>
    <span class="p">(</span><span class="n">replisome_coordinates</span><span class="p">,</span> <span class="n">replisome_domain_indexes</span><span class="p">,</span> <span class="n">replisome_unique_indexes</span><span class="p">)</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">(</span>
        <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;active_replisome&quot;</span><span class="p">],</span>
        <span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">,</span> <span class="s2">&quot;domain_index&quot;</span><span class="p">,</span> <span class="s2">&quot;unique_index&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="p">(</span>
        <span class="n">active_RNAP_coordinates</span><span class="p">,</span>
        <span class="n">active_RNAP_domain_indexes</span><span class="p">,</span>
        <span class="n">active_RNAP_unique_indexes</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">(</span>
        <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;active_RNAP&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">,</span> <span class="s2">&quot;domain_index&quot;</span><span class="p">,</span> <span class="s2">&quot;unique_index&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">chromosome_domain_domain_indexes</span><span class="p">,</span> <span class="n">child_domains</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">(</span>
        <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;chromosome_domain&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">,</span> <span class="s2">&quot;child_domains&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="p">(</span><span class="n">full_chromosome_domain_indexes</span><span class="p">,)</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">(</span>
        <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;full_chromosome&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="p">(</span><span class="n">origin_domain_indexes</span><span class="p">,)</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">(</span><span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;oriC&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;domain_index&quot;</span><span class="p">])</span>

    <span class="c1"># Initialize chromosomal segment attributes</span>
    <span class="n">all_boundary_molecule_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">all_boundary_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">all_segment_domain_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">all_linking_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_chromosomal_segment_attributes</span><span class="p">(</span>
        <span class="n">coordinates</span><span class="p">,</span> <span class="n">unique_indexes</span><span class="p">,</span> <span class="n">spans_oriC</span><span class="p">,</span> <span class="n">spans_terC</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the attributes of all chromosomal segments from a continuous</span>
<span class="sd">        stretch of DNA, given the coordinates and unique indexes of all</span>
<span class="sd">        boundary molecules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coordinates_argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="n">coordinates_sorted</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="n">coordinates_argsort</span><span class="p">]</span>
        <span class="n">unique_indexes_sorted</span> <span class="o">=</span> <span class="n">unique_indexes</span><span class="p">[</span><span class="n">coordinates_argsort</span><span class="p">]</span>

        <span class="c1"># Add dummy molecule at terC if domain spans terC</span>
        <span class="k">if</span> <span class="n">spans_terC</span><span class="p">:</span>
            <span class="n">coordinates_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="n">coordinates_sorted</span><span class="p">,</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinates_sorted</span><span class="p">)],</span>
                <span class="p">[</span><span class="n">min_coordinates</span><span class="p">,</span> <span class="n">max_coordinates</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">unique_indexes_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="n">unique_indexes_sorted</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_indexes_sorted</span><span class="p">)],</span> <span class="n">terC_index</span>
            <span class="p">)</span>

        <span class="n">boundary_molecule_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">unique_indexes_sorted</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                <span class="n">unique_indexes_sorted</span><span class="p">[</span><span class="mi">1</span><span class="p">:][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">boundary_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">coordinates_sorted</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                <span class="n">coordinates_sorted</span><span class="p">[</span><span class="mi">1</span><span class="p">:][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Remove segment that spans oriC if the domain does not span oriC</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">spans_oriC</span><span class="p">:</span>
            <span class="n">oriC_segment_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">boundary_coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">oriC_segment_index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="n">boundary_molecule_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                <span class="n">boundary_molecule_indexes</span><span class="p">,</span> <span class="n">oriC_segment_index</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>
            <span class="n">boundary_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                <span class="n">boundary_coordinates</span><span class="p">,</span> <span class="n">oriC_segment_index</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>

        <span class="c1"># Assumes all segments are at their relaxed state at initialization</span>
        <span class="n">linking_numbers</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">boundary_coordinates</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundary_coordinates</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">relaxed_DNA_base_pairs_per_turn</span>

        <span class="k">return</span> <span class="n">boundary_molecule_indexes</span><span class="p">,</span> <span class="n">boundary_coordinates</span><span class="p">,</span> <span class="n">linking_numbers</span>

    <span class="c1"># Loop through each domain index</span>
    <span class="k">for</span> <span class="n">domain_index</span> <span class="ow">in</span> <span class="n">chromosome_domain_domain_indexes</span><span class="p">:</span>
        <span class="n">domain_spans_oriC</span> <span class="o">=</span> <span class="n">domain_index</span> <span class="ow">in</span> <span class="n">origin_domain_indexes</span>
        <span class="n">domain_spans_terC</span> <span class="o">=</span> <span class="n">domain_index</span> <span class="ow">in</span> <span class="n">full_chromosome_domain_indexes</span>

        <span class="c1"># Get coordinates and indexes of all RNAPs on this domain</span>
        <span class="n">RNAP_domain_mask</span> <span class="o">=</span> <span class="n">active_RNAP_domain_indexes</span> <span class="o">==</span> <span class="n">domain_index</span>
        <span class="n">molecule_coordinates_this_domain</span> <span class="o">=</span> <span class="n">active_RNAP_coordinates</span><span class="p">[</span><span class="n">RNAP_domain_mask</span><span class="p">]</span>
        <span class="n">molecule_indexes_this_domain</span> <span class="o">=</span> <span class="n">active_RNAP_unique_indexes</span><span class="p">[</span><span class="n">RNAP_domain_mask</span><span class="p">]</span>

        <span class="c1"># Append coordinates and indexes of replisomes on this domain, if any</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">domain_spans_oriC</span><span class="p">:</span>
            <span class="n">replisome_domain_mask</span> <span class="o">=</span> <span class="n">replisome_domain_indexes</span> <span class="o">==</span> <span class="n">domain_index</span>
            <span class="n">molecule_coordinates_this_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">molecule_coordinates_this_domain</span><span class="p">,</span>
                    <span class="n">replisome_coordinates</span><span class="p">[</span><span class="n">replisome_domain_mask</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">molecule_indexes_this_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">molecule_indexes_this_domain</span><span class="p">,</span>
                    <span class="n">replisome_unique_indexes</span><span class="p">[</span><span class="n">replisome_domain_mask</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Append coordinates and indexes of parent domain replisomes, if any</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">domain_spans_terC</span><span class="p">:</span>
            <span class="n">parent_domain_index</span> <span class="o">=</span> <span class="n">chromosome_domain_domain_indexes</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">child_domains</span> <span class="o">==</span> <span class="n">domain_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">replisome_parent_domain_mask</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">replisome_domain_indexes</span> <span class="o">==</span> <span class="n">parent_domain_index</span>
            <span class="p">)</span>
            <span class="n">molecule_coordinates_this_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">molecule_coordinates_this_domain</span><span class="p">,</span>
                    <span class="n">replisome_coordinates</span><span class="p">[</span><span class="n">replisome_parent_domain_mask</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">molecule_indexes_this_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">molecule_indexes_this_domain</span><span class="p">,</span>
                    <span class="n">replisome_unique_indexes</span><span class="p">[</span><span class="n">replisome_parent_domain_mask</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Get attributes of chromosomal segments on this domain</span>
        <span class="p">(</span>
            <span class="n">boundary_molecule_indexes_this_domain</span><span class="p">,</span>
            <span class="n">boundary_coordinates_this_domain</span><span class="p">,</span>
            <span class="n">linking_numbers_this_domain</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">get_chromosomal_segment_attributes</span><span class="p">(</span>
            <span class="n">molecule_coordinates_this_domain</span><span class="p">,</span>
            <span class="n">molecule_indexes_this_domain</span><span class="p">,</span>
            <span class="n">domain_spans_oriC</span><span class="p">,</span>
            <span class="n">domain_spans_terC</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Append to existing array of attributes</span>
        <span class="n">all_boundary_molecule_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">all_boundary_molecule_indexes</span><span class="p">,</span> <span class="n">boundary_molecule_indexes_this_domain</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">all_boundary_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">all_boundary_coordinates</span><span class="p">,</span> <span class="n">boundary_coordinates_this_domain</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">all_segment_domain_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">all_segment_domain_indexes</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">linking_numbers_this_domain</span><span class="p">),</span> <span class="n">domain_index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">all_linking_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">all_linking_numbers</span><span class="p">,</span> <span class="n">linking_numbers_this_domain</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Confirm total counts of all segments</span>
    <span class="n">n_segments</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_linking_numbers</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">n_segments</span>
        <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_RNAP_unique_indexes</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">replisome_unique_indexes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">)</span>

    <span class="c1"># Add chromosomal segments</span>
    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;chromosomal_segment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
        <span class="s2">&quot;chromosomal_segment&quot;</span><span class="p">,</span>
        <span class="n">n_segments</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
        <span class="n">boundary_molecule_indexes</span><span class="o">=</span><span class="n">all_boundary_molecule_indexes</span><span class="p">,</span>
        <span class="n">boundary_coordinates</span><span class="o">=</span><span class="n">all_boundary_coordinates</span><span class="p">,</span>
        <span class="n">domain_index</span><span class="o">=</span><span class="n">all_segment_domain_indexes</span><span class="p">,</span>
        <span class="n">linking_number</span><span class="o">=</span><span class="n">all_linking_numbers</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="initialize_translation">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_translation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_translation</span><span class="p">(</span>
    <span class="n">bulk_state</span><span class="p">,</span> <span class="n">unique_molecules</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">unique_id_rng</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Activate ribosomes as unique molecules, and distribute them along lengths</span>
<span class="sd">    of mRNAs, while decreasing counts of unactivated ribosomal subunits (30S</span>
<span class="sd">    and 50S).</span>

<span class="sd">    Ribosomes are placed randomly across the lengths of each mRNA.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load translation parameters</span>
    <span class="n">current_nutrients</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">conditions</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">condition</span><span class="p">][</span><span class="s2">&quot;nutrients&quot;</span><span class="p">]</span>
    <span class="n">frac_active_ribosome</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">ribosomeFractionActiveDict</span><span class="p">[</span>
        <span class="n">current_nutrients</span>
    <span class="p">]</span>
    <span class="n">protein_sequences</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">translation_sequences</span>
    <span class="n">protein_lengths</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span>
    <span class="n">translation_efficiencies</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">translation_efficiencies_by_monomer</span>
    <span class="p">)</span>
    <span class="n">aa_weights_incorporated</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">translation_monomer_weights</span>
    <span class="n">end_weight</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">translation_end_weight</span>
    <span class="n">cistron_lengths</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span>
        <span class="n">units</span><span class="o">.</span><span class="n">nt</span>
    <span class="p">)</span>
    <span class="n">TU_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">monomer_index_to_tu_indexes</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">relation</span><span class="o">.</span><span class="n">monomer_index_to_tu_indexes</span>
    <span class="n">monomer_index_to_cistron_index</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">i</span><span class="p">:</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">_cistron_id_to_index</span><span class="p">[</span><span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;cistron_id&quot;</span><span class="p">]]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">monomer</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1"># Get attributes of RNAs</span>
    <span class="p">(</span>
        <span class="n">TU_index_all_RNAs</span><span class="p">,</span>
        <span class="n">length_all_RNAs</span><span class="p">,</span>
        <span class="n">is_mRNA</span><span class="p">,</span>
        <span class="n">is_full_transcript_all_RNAs</span><span class="p">,</span>
        <span class="n">unique_index_all_RNAs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">(</span>
        <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;RNA&quot;</span><span class="p">],</span>
        <span class="p">[</span>
            <span class="s2">&quot;TU_index&quot;</span><span class="p">,</span>
            <span class="s2">&quot;transcript_length&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_mRNA&quot;</span><span class="p">,</span>
            <span class="s2">&quot;is_full_transcript&quot;</span><span class="p">,</span>
            <span class="s2">&quot;unique_index&quot;</span><span class="p">,</span>
        <span class="p">],</span>
    <span class="p">)</span>
    <span class="n">TU_index_mRNAs</span> <span class="o">=</span> <span class="n">TU_index_all_RNAs</span><span class="p">[</span><span class="n">is_mRNA</span><span class="p">]</span>
    <span class="n">length_mRNAs</span> <span class="o">=</span> <span class="n">length_all_RNAs</span><span class="p">[</span><span class="n">is_mRNA</span><span class="p">]</span>
    <span class="n">is_full_transcript_mRNAs</span> <span class="o">=</span> <span class="n">is_full_transcript_all_RNAs</span><span class="p">[</span><span class="n">is_mRNA</span><span class="p">]</span>
    <span class="n">unique_index_mRNAs</span> <span class="o">=</span> <span class="n">unique_index_all_RNAs</span><span class="p">[</span><span class="n">is_mRNA</span><span class="p">]</span>

    <span class="c1"># Calculate available template lengths of each mRNA cistron from fully</span>
    <span class="c1"># transcribed mRNA transcription units</span>
    <span class="n">TU_index_full_mRNAs</span> <span class="o">=</span> <span class="n">TU_index_mRNAs</span><span class="p">[</span><span class="n">is_full_transcript_mRNAs</span><span class="p">]</span>
    <span class="n">TU_counts_full_mRNAs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">TU_index_full_mRNAs</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">TU_ids</span><span class="p">))</span>
    <span class="n">cistron_counts_full_mRNAs</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_tu_mapping_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="n">TU_counts_full_mRNAs</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">available_cistron_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">cistron_counts_full_mRNAs</span><span class="p">,</span> <span class="n">cistron_lengths</span><span class="p">)</span>

    <span class="c1"># Add available template lengths from each partially transcribed mRNAs</span>
    <span class="n">TU_index_incomplete_mRNAs</span> <span class="o">=</span> <span class="n">TU_index_mRNAs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">is_full_transcript_mRNAs</span><span class="p">)]</span>
    <span class="n">length_incomplete_mRNAs</span> <span class="o">=</span> <span class="n">length_mRNAs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">is_full_transcript_mRNAs</span><span class="p">)]</span>

    <span class="n">TU_index_to_mRNA_lengths</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">TU_index</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">TU_index_incomplete_mRNAs</span><span class="p">,</span> <span class="n">length_incomplete_mRNAs</span><span class="p">):</span>
        <span class="n">TU_index_to_mRNA_lengths</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">TU_index</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">TU_index</span><span class="p">,</span> <span class="n">available_lengths</span> <span class="ow">in</span> <span class="n">TU_index_to_mRNA_lengths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">cistron_indexes</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_id_to_cistron_indexes</span><span class="p">(</span>
            <span class="n">TU_ids</span><span class="p">[</span><span class="n">TU_index</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">cistron_start_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_start_end_pos_in_tu</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">cistron_index</span><span class="p">,</span> <span class="n">TU_index</span><span class="p">)</span>
                <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">cistron_index</span> <span class="ow">in</span> <span class="n">cistron_indexes</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="n">available_lengths</span><span class="p">:</span>
            <span class="n">available_cistron_lengths</span><span class="p">[</span><span class="n">cistron_indexes</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
                <span class="n">length</span> <span class="o">-</span> <span class="n">cistron_start_positions</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cistron_lengths</span><span class="p">[</span><span class="n">cistron_indexes</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="c1"># Find number of ribosomes to activate</span>
    <span class="n">ribosome30S_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_ids</span><span class="o">.</span><span class="n">s30_full_complex</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">ribosome30S</span> <span class="o">=</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">ribosome30S_idx</span><span class="p">]</span>
    <span class="n">ribosome50S_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_ids</span><span class="o">.</span><span class="n">s50_full_complex</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">ribosome50S</span> <span class="o">=</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">ribosome50S_idx</span><span class="p">]</span>
    <span class="n">inactive_ribosome_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">ribosome30S</span><span class="p">,</span> <span class="n">ribosome50S</span><span class="p">)</span>
    <span class="n">n_ribosomes_to_activate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">frac_active_ribosome</span> <span class="o">*</span> <span class="n">inactive_ribosome_count</span><span class="p">)</span>

    <span class="c1"># Add total available template lengths as weights and normalize</span>
    <span class="n">protein_init_probs</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span>
        <span class="n">available_cistron_lengths</span><span class="p">[</span><span class="n">sim_data</span><span class="o">.</span><span class="n">relation</span><span class="o">.</span><span class="n">cistron_to_monomer_mapping</span><span class="p">]</span>
        <span class="o">*</span> <span class="n">translation_efficiencies</span>
    <span class="p">)</span>

    <span class="c1"># Sample a multinomial distribution of synthesis probabilities to determine</span>
    <span class="c1"># which types of mRNAs are initialized</span>
    <span class="n">n_new_proteins</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span>
        <span class="n">n_ribosomes_to_activate</span><span class="p">,</span> <span class="n">protein_init_probs</span>
    <span class="p">)</span>

    <span class="c1"># Build attributes for active ribosomes</span>
    <span class="n">protein_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_ribosomes_to_activate</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">cistron_start_positions_on_mRNA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_ribosomes_to_activate</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">positions_on_mRNA_from_cistron_start_site</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
        <span class="n">n_ribosomes_to_activate</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
    <span class="p">)</span>
    <span class="n">mRNA_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_ribosomes_to_activate</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nonzero_count</span> <span class="o">=</span> <span class="n">n_new_proteins</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">protein_index</span><span class="p">,</span> <span class="n">protein_counts</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_new_proteins</span><span class="o">.</span><span class="n">size</span><span class="p">)[</span><span class="n">nonzero_count</span><span class="p">],</span> <span class="n">n_new_proteins</span><span class="p">[</span><span class="n">nonzero_count</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="c1"># Set protein index</span>
        <span class="n">protein_indexes</span><span class="p">[</span><span class="n">start_index</span> <span class="p">:</span> <span class="n">start_index</span> <span class="o">+</span> <span class="n">protein_counts</span><span class="p">]</span> <span class="o">=</span> <span class="n">protein_index</span>

        <span class="c1"># Get index of cistron corresponding to this protein</span>
        <span class="n">cistron_index</span> <span class="o">=</span> <span class="n">monomer_index_to_cistron_index</span><span class="p">[</span><span class="n">protein_index</span><span class="p">]</span>

        <span class="c1"># Initialize list of available lengths for each transcript and the</span>
        <span class="c1"># indexes of each transcript in the list of mRNA attributes</span>
        <span class="n">available_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">attribute_indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cistron_start_positions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Distribute ribosomes among mRNAs that produce this protein, weighted</span>
        <span class="c1"># by their lengths</span>
        <span class="k">for</span> <span class="n">TU_index</span> <span class="ow">in</span> <span class="n">monomer_index_to_tu_indexes</span><span class="p">[</span><span class="n">protein_index</span><span class="p">]:</span>
            <span class="n">attribute_indexes_this_TU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">TU_index_mRNAs</span> <span class="o">==</span> <span class="n">TU_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cistron_start_position</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_start_end_pos_in_tu</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">cistron_index</span><span class="p">,</span> <span class="n">TU_index</span><span class="p">)</span>
                <span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">available_lengths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
                    <span class="n">length_mRNAs</span><span class="p">[</span><span class="n">attribute_indexes_this_TU</span><span class="p">]</span> <span class="o">-</span> <span class="n">cistron_start_position</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">cistron_lengths</span><span class="p">[</span><span class="n">cistron_index</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">attribute_indexes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">attribute_indexes_this_TU</span><span class="p">)</span>
            <span class="n">cistron_start_positions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span><span class="n">cistron_start_position</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribute_indexes_this_TU</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">available_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">available_lengths</span><span class="p">)</span>
        <span class="n">attribute_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">attribute_indexes</span><span class="p">)</span>
        <span class="n">cistron_start_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cistron_start_positions</span><span class="p">)</span>

        <span class="n">n_ribosomes_per_RNA</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span>
            <span class="n">protein_counts</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="n">available_lengths</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Get unique indexes of each mRNA</span>
        <span class="n">mRNA_indexes</span><span class="p">[</span><span class="n">start_index</span> <span class="p">:</span> <span class="n">start_index</span> <span class="o">+</span> <span class="n">protein_counts</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="n">unique_index_mRNAs</span><span class="p">[</span><span class="n">attribute_indexes</span><span class="p">],</span> <span class="n">n_ribosomes_per_RNA</span>
        <span class="p">)</span>

        <span class="c1"># Get full length of this polypeptide</span>
        <span class="n">peptide_full_length</span> <span class="o">=</span> <span class="n">protein_lengths</span><span class="p">[</span><span class="n">protein_index</span><span class="p">]</span>

        <span class="c1"># Randomly place ribosomes along the length of each mRNA, capped by the</span>
        <span class="c1"># mRNA length expected from the full polypeptide length to prevent</span>
        <span class="c1"># ribosomes from overshooting full peptide lengths</span>
        <span class="n">cistron_start_positions_on_mRNA</span><span class="p">[</span><span class="n">start_index</span> <span class="p">:</span> <span class="n">start_index</span> <span class="o">+</span> <span class="n">protein_counts</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">cistron_start_positions</span><span class="p">,</span> <span class="n">n_ribosomes_per_RNA</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">positions_on_mRNA_from_cistron_start_site</span><span class="p">[</span>
            <span class="n">start_index</span> <span class="p">:</span> <span class="n">start_index</span> <span class="o">+</span> <span class="n">protein_counts</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
            <span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">protein_counts</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">available_lengths</span><span class="p">,</span> <span class="n">peptide_full_length</span> <span class="o">*</span> <span class="mi">3</span><span class="p">),</span>
                <span class="n">n_ribosomes_per_RNA</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">start_index</span> <span class="o">+=</span> <span class="n">protein_counts</span>

    <span class="c1"># Calculate the lengths of the partial polypeptide, and rescale position on</span>
    <span class="c1"># mRNA to be a multiple of three using this peptide length</span>
    <span class="n">peptide_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="n">positions_on_mRNA_from_cistron_start_site</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">positions_on_mRNA</span> <span class="o">=</span> <span class="n">cistron_start_positions_on_mRNA</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">peptide_lengths</span>

    <span class="c1"># Update masses of partially translated proteins</span>
    <span class="n">sequences</span> <span class="o">=</span> <span class="n">protein_sequences</span><span class="p">[</span><span class="n">protein_indexes</span><span class="p">]</span>
    <span class="n">mass_increase_protein</span> <span class="o">=</span> <span class="n">computeMassIncrease</span><span class="p">(</span>
        <span class="n">sequences</span><span class="p">,</span> <span class="n">peptide_lengths</span><span class="p">,</span> <span class="n">aa_weights_incorporated</span>
    <span class="p">)</span>

    <span class="c1"># Add end weight</span>
    <span class="n">mass_increase_protein</span><span class="p">[</span><span class="n">peptide_lengths</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">end_weight</span>

    <span class="c1"># Add active ribosomes</span>
    <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;active_ribosome&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_unique_molecules</span><span class="p">(</span>
        <span class="s2">&quot;active_ribosome&quot;</span><span class="p">,</span>
        <span class="n">n_ribosomes_to_activate</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">unique_id_rng</span><span class="p">,</span>
        <span class="n">protein_index</span><span class="o">=</span><span class="n">protein_indexes</span><span class="p">,</span>
        <span class="n">peptide_length</span><span class="o">=</span><span class="n">peptide_lengths</span><span class="p">,</span>
        <span class="n">mRNA_index</span><span class="o">=</span><span class="n">mRNA_indexes</span><span class="p">,</span>
        <span class="n">pos_on_mRNA</span><span class="o">=</span><span class="n">positions_on_mRNA</span><span class="p">,</span>
        <span class="n">massDiff_protein</span><span class="o">=</span><span class="n">mass_increase_protein</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Decrease counts of free 30S and 50S ribosomal subunits</span>
    <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">ribosome30S_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ribosome30S</span> <span class="o">-</span> <span class="n">n_ribosomes_to_activate</span>
    <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">ribosome50S_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ribosome50S</span> <span class="o">-</span> <span class="n">n_ribosomes_to_activate</span></div>



<div class="viewcode-block" id="determine_chromosome_state">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.determine_chromosome_state">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">determine_chromosome_state</span><span class="p">(</span>
    <span class="n">tau</span><span class="p">:</span> <span class="n">Unum</span><span class="p">,</span>
    <span class="n">replichore_length</span><span class="p">:</span> <span class="n">Unum</span><span class="p">,</span>
    <span class="n">n_max_replisomes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">place_holder</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">cell_mass</span><span class="p">:</span> <span class="n">Unum</span><span class="p">,</span>
    <span class="n">critical_mass</span><span class="p">:</span> <span class="n">Unum</span><span class="p">,</span>
    <span class="n">replication_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
    <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]],</span>
    <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span>
    <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]],</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the attributes of oriC&#39;s, replisomes, and chromosome domains on</span>
<span class="sd">    the chromosomes at the beginning of the cell cycle.</span>

<span class="sd">    Args:</span>
<span class="sd">        tau: the doubling time of the cell (with Unum time unit)</span>
<span class="sd">        replichore_length: the amount of DNA to be replicated per fork, usually</span>
<span class="sd">            half of the genome, in base-pairs (with Unum nucleotide unit)</span>
<span class="sd">        n_max_replisomes: the maximum number of replisomes that can be formed</span>
<span class="sd">            given the initial counts of replisome subunits</span>
<span class="sd">        place_holder: placeholder value for chromosome domains without child</span>
<span class="sd">            domains</span>
<span class="sd">        cell_mass: total mass of the cell with mass units (with Unum mass unit)</span>
<span class="sd">        critical_mass: mass per oriC before replication is initiated</span>
<span class="sd">            (with Unum mass unit)</span>
<span class="sd">        replication_rate: rate of nucleotide elongation</span>
<span class="sd">            (with Unum nucleotides per time unit)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Three dictionaries, each containing updates to attributes of a unique molecule type.</span>

<span class="sd">        - ``oric_state``: dictionary of the following format::</span>

<span class="sd">            {&#39;domain_index&#39;: a vector of integers indicating which chromosome domain the</span>
<span class="sd">                oriC sequence belongs to.}</span>

<span class="sd">        - ``replisome_state``: dictionary of the following format::</span>

<span class="sd">            {&#39;coordinates&#39;: a vector of integers that indicates where the replisomes</span>
<span class="sd">                are located on the chromosome relative to the origin in base pairs,</span>
<span class="sd">            &#39;right_replichore&#39;: a vector of boolean values that indicates whether the</span>
<span class="sd">                replisome is on the right replichore (True) or the left replichore (False),</span>
<span class="sd">            &#39;domain_index&#39;: a vector of integers indicating which chromosome domain the</span>
<span class="sd">                replisomes belong to. The index of the &quot;mother&quot; domain of the replication</span>
<span class="sd">                fork is assigned to the replisome}</span>

<span class="sd">        - ``domain_state``: dictionary of the following format::</span>

<span class="sd">            {&#39;domain_index&#39;: the indexes of the domains,</span>
<span class="sd">            &#39;child_domains&#39;: the (n_domain X 2) array of the domain indexes of the two</span>
<span class="sd">                children domains that are connected on the oriC side with the given domain.}</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># All inputs must be positive numbers</span>
    <span class="n">unitless_tau</span> <span class="o">=</span> <span class="n">tau</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>
    <span class="n">unitless_replichore_length</span> <span class="o">=</span> <span class="n">replichore_length</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">nt</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">unitless_tau</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;tau value can&#39;t be negative.&quot;</span>
    <span class="k">assert</span> <span class="n">unitless_replichore_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;replichore_length must be positive.&quot;</span>

    <span class="c1"># Convert to unitless</span>
    <span class="n">unitless_cell_mass</span> <span class="o">=</span> <span class="n">cell_mass</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">fg</span><span class="p">)</span>
    <span class="n">unitless_critical_mass</span> <span class="o">=</span> <span class="n">critical_mass</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">fg</span><span class="p">)</span>

    <span class="c1"># Calculate the maximum number of replication rounds given the maximum</span>
    <span class="c1"># count of replisomes</span>
    <span class="n">n_max_rounds</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">n_max_replisomes</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Calculate the number of active replication rounds</span>
    <span class="n">n_rounds</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
        <span class="n">n_max_rounds</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">unitless_cell_mass</span> <span class="o">/</span> <span class="n">unitless_critical_mass</span><span class="p">)))),</span>
    <span class="p">)</span>

    <span class="c1"># Initialize arrays for replisomes</span>
    <span class="n">n_replisomes</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n_rounds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_replisomes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">right_replichore_replisome</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_replisomes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">domain_index_replisome</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_replisomes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Initialize child domain array for chromosome domains</span>
    <span class="n">n_domains</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n_rounds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">child_domains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_domains</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">place_holder</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Set domain_index attribute of oriC&#39;s and chromosome domains</span>
    <span class="n">domain_index_oric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
        <span class="mi">2</span><span class="o">**</span><span class="n">n_rounds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n_rounds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span>
    <span class="p">)</span>
    <span class="n">domain_index_domains</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_domains</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the number of replication events that happen before the</span>
<span class="sd">        replication round index given as an argument. Since 2**i events happen</span>
<span class="sd">        at each round i = 0, 1, ..., the sum of the number of events before</span>
<span class="sd">        round j is 2**j - 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">**</span><span class="n">round_idx</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Loop through active replication rounds, starting from the oldest round.</span>
    <span class="c1"># If n_round = 0 skip loop entirely - no active replication round.</span>
    <span class="k">for</span> <span class="n">round_idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_rounds</span><span class="p">):</span>
        <span class="c1"># Determine at which location (base) of the chromosome the replication</span>
        <span class="c1"># forks should be initialized to</span>
        <span class="n">round_critical_mass</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">round_idx</span> <span class="o">*</span> <span class="n">unitless_critical_mass</span>
        <span class="n">growth_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">unitless_tau</span>
        <span class="n">replication_time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">unitless_cell_mass</span> <span class="o">/</span> <span class="n">round_critical_mass</span><span class="p">)</span> <span class="o">/</span> <span class="n">growth_rate</span>
        <span class="p">)</span>
        <span class="c1"># TODO: this should handle completed replication (instead of taking min)</span>
        <span class="c1"># for accuracy but will likely never start with multiple chromosomes</span>
        <span class="n">fork_location</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">replication_time</span> <span class="o">*</span> <span class="n">replication_rate</span><span class="p">),</span>
            <span class="n">unitless_replichore_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add 2^n initiation events per round. A single initiation event</span>
        <span class="c1"># generates two replication forks.</span>
        <span class="n">n_events_this_round</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">round_idx</span><span class="p">)</span>

        <span class="c1"># Set attributes of replisomes for this replication round</span>
        <span class="n">coordinates</span><span class="p">[</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span><span class="p">)</span> <span class="p">:</span> <span class="mi">2</span>
            <span class="o">*</span> <span class="n">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fork_location</span><span class="p">,</span> <span class="o">-</span><span class="n">fork_location</span><span class="p">]),</span> <span class="n">n_events_this_round</span><span class="p">)</span>

        <span class="n">right_replichore_replisome</span><span class="p">[</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span><span class="p">)</span> <span class="p">:</span> <span class="mi">2</span>
            <span class="o">*</span> <span class="n">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]),</span> <span class="n">n_events_this_round</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">domain_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span><span class="p">),</span>
                <span class="n">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="n">domain_index_replisome</span><span class="p">[</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="n">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="p">:</span> <span class="mi">2</span>
                <span class="o">*</span> <span class="n">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span><span class="p">)</span>
                <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">domain_index</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Set attributes of chromosome domains for this replication round</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">domain_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span>
                <span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="n">child_domains</span><span class="p">[</span><span class="n">n_events_before_this_round</span><span class="p">(</span><span class="n">round_idx</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">domain_index</span><span class="p">,</span> <span class="n">domain_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="c1"># Convert to numpy arrays and wrap into dictionaries</span>
    <span class="n">oric_state</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;domain_index&quot;</span><span class="p">:</span> <span class="n">domain_index_oric</span><span class="p">}</span>

    <span class="n">replisome_state</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="n">coordinates</span><span class="p">,</span>
        <span class="s2">&quot;right_replichore&quot;</span><span class="p">:</span> <span class="n">right_replichore_replisome</span><span class="p">,</span>
        <span class="s2">&quot;domain_index&quot;</span><span class="p">:</span> <span class="n">domain_index_replisome</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">domain_state</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;child_domains&quot;</span><span class="p">:</span> <span class="n">child_domains</span><span class="p">,</span>
        <span class="s2">&quot;domain_index&quot;</span><span class="p">:</span> <span class="n">domain_index_domains</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">oric_state</span><span class="p">,</span> <span class="n">replisome_state</span><span class="p">,</span> <span class="n">domain_state</span></div>



<div class="viewcode-block" id="rescale_initiation_probs">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.rescale_initiation_probs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rescale_initiation_probs</span><span class="p">(</span><span class="n">init_probs</span><span class="p">,</span> <span class="n">TU_index</span><span class="p">,</span> <span class="n">fixed_synth_probs</span><span class="p">,</span> <span class="n">fixed_TU_indexes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rescales the initiation probabilities of each promoter such that the total</span>
<span class="sd">    synthesis probabilities of certain types of RNAs are fixed to a</span>
<span class="sd">    predetermined value. For instance, if there are two copies of promoters for</span>
<span class="sd">    RNA A, whose synthesis probability should be fixed to 0.1, each promoter is</span>
<span class="sd">    given an initiation probability of 0.05.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">rna_idx</span><span class="p">,</span> <span class="n">synth_prob</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fixed_TU_indexes</span><span class="p">,</span> <span class="n">fixed_synth_probs</span><span class="p">):</span>
        <span class="n">fixed_rna_mask</span> <span class="o">=</span> <span class="n">TU_index</span> <span class="o">==</span> <span class="n">rna_idx</span>
        <span class="n">init_probs</span><span class="p">[</span><span class="n">fixed_rna_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">synth_prob</span> <span class="o">/</span> <span class="n">fixed_rna_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>



<div class="viewcode-block" id="calculate_cell_mass">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.calculate_cell_mass">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_cell_mass</span><span class="p">(</span><span class="n">bulk_state</span><span class="p">,</span> <span class="n">unique_molecules</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates cell mass in femtograms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bulk_submass_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">submass</span><span class="si">}</span><span class="s2">_submass&quot;</span> <span class="k">for</span> <span class="n">submass</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">submass_name_to_index</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="p">]</span>
    <span class="n">cell_mass</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span>
        <span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rfn</span><span class="o">.</span><span class="n">structured_to_unstructured</span><span class="p">(</span><span class="n">bulk_state</span><span class="p">[</span><span class="n">bulk_submass_names</span><span class="p">]))</span>
        <span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_molecules</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">unique_masses</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">unique_molecule</span><span class="o">.</span><span class="n">unique_molecule_masses</span><span class="p">[</span>
            <span class="s2">&quot;mass&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">fg</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span> <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">mol</span>
        <span class="p">)</span>
        <span class="n">unique_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">unique_molecule</span><span class="o">.</span><span class="n">unique_molecule_masses</span><span class="p">[</span>
            <span class="s2">&quot;id&quot;</span>
        <span class="p">]</span>
        <span class="n">unique_submass_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;massDiff_</span><span class="si">{</span><span class="n">submass</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">submass</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">submass_name_to_index</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">unique_id</span><span class="p">,</span> <span class="n">unique_submasses</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unique_ids</span><span class="p">,</span> <span class="n">unique_masses</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">unique_id</span> <span class="ow">in</span> <span class="n">unique_molecules</span><span class="p">:</span>
                <span class="n">cell_mass</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">unique_molecules</span><span class="p">[</span><span class="n">unique_id</span><span class="p">][</span><span class="s2">&quot;_entryState&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">unique_submasses</span>
                <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">cell_mass</span> <span class="o">+=</span> <span class="n">rfn</span><span class="o">.</span><span class="n">structured_to_unstructured</span><span class="p">(</span>
                    <span class="n">unique_molecules</span><span class="p">[</span><span class="n">unique_id</span><span class="p">][</span><span class="n">unique_submass_names</span><span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">units</span><span class="o">.</span><span class="n">fg</span> <span class="o">*</span> <span class="n">cell_mass</span></div>



<div class="viewcode-block" id="initialize_trna_charging">
<a class="viewcode-back" href="../../../reference/api/ecoli/ecoli.library.initial_conditions.html#ecoli.library.initial_conditions.initialize_trna_charging">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize_trna_charging</span><span class="p">(</span>
    <span class="n">bulk_state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">unique_molecules</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">sim_data</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">variable_elongation</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes charged tRNA from uncharged tRNA and amino acids</span>

<span class="sd">    Args:</span>
<span class="sd">        bulk_state: Structured array with IDs and counts of all bulk molecules</span>
<span class="sd">        unique_molecules: Mapping of unique molecule names to structured</span>
<span class="sd">            arrays of their current simulation states</span>
<span class="sd">        sim_data: Simulation data loaded from pickle generated by ParCa</span>
<span class="sd">        variable_elongation: Sets max elongation higher if True</span>

<span class="sd">    .. note::</span>
<span class="sd">        Does not adjust for mass of amino acids on charged tRNA (~0.01% of cell mass)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate cell volume for concentrations</span>
    <span class="n">cell_volume</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">calculate_cell_mass</span><span class="p">(</span><span class="n">bulk_state</span><span class="p">,</span> <span class="n">unique_molecules</span><span class="p">,</span> <span class="n">sim_data</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">cell_density</span>
    <span class="p">)</span>
    <span class="n">counts_to_molar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span> <span class="o">*</span> <span class="n">cell_volume</span><span class="p">)</span>

    <span class="c1"># Get molecule views and concentrations</span>
    <span class="n">transcription</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span>
    <span class="n">aa_from_synthetase</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">aa_from_synthetase</span>
    <span class="n">aa_from_trna</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">aa_from_trna</span>
    <span class="n">synthetases</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span>
        <span class="n">bulk_state</span><span class="p">,</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">transcription</span><span class="o">.</span><span class="n">synthetase_names</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">uncharged_trna_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">transcription</span><span class="o">.</span><span class="n">uncharged_trna_names</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">uncharged_trna</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulk_state</span><span class="p">,</span> <span class="n">uncharged_trna_idx</span><span class="p">)</span>
    <span class="n">charged_trna_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">transcription</span><span class="o">.</span><span class="n">charged_trna_names</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">charged_trna</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulk_state</span><span class="p">,</span> <span class="n">charged_trna_idx</span><span class="p">)</span>
    <span class="n">aas</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span>
        <span class="n">bulk_state</span><span class="p">,</span>
        <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">amino_acids</span><span class="p">,</span> <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]),</span>
    <span class="p">)</span>

    <span class="n">ribosome_counts</span> <span class="o">=</span> <span class="n">unique_molecules</span><span class="p">[</span><span class="s2">&quot;active_ribosome&quot;</span><span class="p">][</span><span class="s2">&quot;_entryState&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">synthetase_conc</span> <span class="o">=</span> <span class="n">counts_to_molar</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aa_from_synthetase</span><span class="p">,</span> <span class="n">synthetases</span><span class="p">)</span>
    <span class="n">uncharged_trna_conc</span> <span class="o">=</span> <span class="n">counts_to_molar</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aa_from_trna</span><span class="p">,</span> <span class="n">uncharged_trna</span><span class="p">)</span>
    <span class="n">charged_trna_conc</span> <span class="o">=</span> <span class="n">counts_to_molar</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aa_from_trna</span><span class="p">,</span> <span class="n">charged_trna</span><span class="p">)</span>
    <span class="n">aa_conc</span> <span class="o">=</span> <span class="n">counts_to_molar</span> <span class="o">*</span> <span class="n">aas</span>
    <span class="n">ribosome_conc</span> <span class="o">=</span> <span class="n">counts_to_molar</span> <span class="o">*</span> <span class="n">ribosome_counts</span>

    <span class="c1"># Estimate fraction of amino acids from sequences, excluding first index for padding of -1</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">aas_in_sequences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">translation_sequences</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">aas_in_sequences</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">aas_in_sequences</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="c1"># Estimate initial charging state</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span>
    <span class="n">transcription</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span>
    <span class="n">metabolism</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span>
    <span class="n">elongation_max</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">constants</span><span class="o">.</span><span class="n">ribosome_elongation_rate_max</span>
        <span class="k">if</span> <span class="n">variable_elongation</span>
        <span class="k">else</span> <span class="n">constants</span><span class="o">.</span><span class="n">ribosome_elongation_rate_basal</span>
    <span class="p">)</span>
    <span class="n">charging_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;kS&quot;</span><span class="p">:</span> <span class="n">constants</span><span class="o">.</span><span class="n">synthetase_charging_rate</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span><span class="p">),</span>
        <span class="s2">&quot;KMaa&quot;</span><span class="p">:</span> <span class="n">transcription</span><span class="o">.</span><span class="n">aa_kms</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">MICROMOLAR_UNITS</span><span class="p">),</span>
        <span class="s2">&quot;KMtf&quot;</span><span class="p">:</span> <span class="n">transcription</span><span class="o">.</span><span class="n">trna_kms</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">MICROMOLAR_UNITS</span><span class="p">),</span>
        <span class="s2">&quot;krta&quot;</span><span class="p">:</span> <span class="n">constants</span><span class="o">.</span><span class="n">Kdissociation_charged_trna_ribosome</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span>
            <span class="n">MICROMOLAR_UNITS</span>
        <span class="p">),</span>
        <span class="s2">&quot;krtf&quot;</span><span class="p">:</span> <span class="n">constants</span><span class="o">.</span><span class="n">Kdissociation_uncharged_trna_ribosome</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span>
            <span class="n">MICROMOLAR_UNITS</span>
        <span class="p">),</span>
        <span class="s2">&quot;max_elong_rate&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">elongation_max</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">aa</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span><span class="p">)),</span>
        <span class="s2">&quot;charging_mask&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">aa</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">REMOVED_FROM_CHARGING</span>
                <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">amino_acids</span>
            <span class="p">]</span>
        <span class="p">),</span>
        <span class="s2">&quot;unit_conversion&quot;</span><span class="p">:</span> <span class="n">metabolism</span><span class="o">.</span><span class="n">get_amino_acid_conc_conversion</span><span class="p">(</span><span class="n">MICROMOLAR_UNITS</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="n">fraction_charged</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">calculate_trna_charging</span><span class="p">(</span>
        <span class="n">synthetase_conc</span><span class="p">,</span>
        <span class="n">uncharged_trna_conc</span><span class="p">,</span>
        <span class="n">charged_trna_conc</span><span class="p">,</span>
        <span class="n">aa_conc</span><span class="p">,</span>
        <span class="n">ribosome_conc</span><span class="p">,</span>
        <span class="n">f</span><span class="p">,</span>
        <span class="n">charging_params</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Update counts of tRNA to match charging</span>
    <span class="n">total_trna_counts</span> <span class="o">=</span> <span class="n">uncharged_trna</span> <span class="o">+</span> <span class="n">charged_trna</span>
    <span class="n">charged_trna_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
        <span class="n">total_trna_counts</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fraction_charged</span><span class="p">,</span> <span class="n">aa_from_trna</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">uncharged_trna_counts</span> <span class="o">=</span> <span class="n">total_trna_counts</span> <span class="o">-</span> <span class="n">charged_trna_counts</span>
    <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">charged_trna_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">charged_trna_counts</span>
    <span class="n">bulk_state</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">uncharged_trna_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">uncharged_trna_counts</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2025, The Vivarium E. coli Authors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>