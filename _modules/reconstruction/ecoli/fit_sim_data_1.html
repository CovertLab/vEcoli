

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>reconstruction.ecoli.fit_sim_data_1 &mdash; Vivarium E. coli 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Vivarium E. coli
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../stores.html">Stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../composites.html">Composites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../experiments.html">Experiments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflows.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../docs.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hpc.html">HPC Clusters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gcloud.html">Google Cloud</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ci.html">Continuous Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pycharm.html">PyCharm Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../diffs.html">Model Differences From wcEcoli</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/api_ref.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Vivarium E. coli</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">reconstruction.ecoli.fit_sim_data_1</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for reconstruction.ecoli.fit_sim_data_1</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The parca, aka parameter calculator.</span>

<span class="sd">TODO: establish a controlled language for function behaviors (i.e. create* set* fit*)</span>
<span class="sd">TODO: functionalize so that values are not both set and returned from some methods</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">binascii</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">traceback</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">stochastic_arrow</span><span class="w"> </span><span class="kn">import</span> <span class="n">StochasticSystem</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cvxpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">Variable</span><span class="p">,</span> <span class="n">Problem</span><span class="p">,</span> <span class="n">Minimize</span><span class="p">,</span> <span class="n">norm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.optimize</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.sparse</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">ecoli.library.initial_conditions</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_bulk_container</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ecoli.library.schema</span><span class="w"> </span><span class="kn">import</span> <span class="n">bulk_name_to_idx</span><span class="p">,</span> <span class="n">counts</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">reconstruction.ecoli.simulation_data</span><span class="w"> </span><span class="kn">import</span> <span class="n">SimulationDataEcoli</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wholecell.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">parallelization</span><span class="p">,</span> <span class="n">units</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">wholecell.utils.fitting</span><span class="w"> </span><span class="kn">import</span> <span class="n">normalize</span><span class="p">,</span> <span class="n">masses_and_counts_for_homeostatic_target</span>


<span class="c1"># Fitting parameters</span>
<span class="c1"># NOTE: This threshold is arbitrary but relaxing it too much can slow doubling time.</span>
<span class="n">FITNESS_THRESHOLD</span> <span class="o">=</span> <span class="mf">1e-9</span>
<span class="n">MAX_FITTING_ITERATIONS</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">N_SEEDS</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># Parameters used in fitPromoterBoundProbability()</span>
<span class="n">PROMOTER_PDIFF_THRESHOLD</span> <span class="o">=</span> <span class="mf">0.06</span>  <span class="c1"># Minimum difference between binding probabilities of a TF in conditions where TF is active and inactive</span>
<span class="n">PROMOTER_REG_COEFF</span> <span class="o">=</span> <span class="mf">1e-3</span>  <span class="c1"># Optimization weight on how much probability should stay close to original values</span>
<span class="n">PROMOTER_SCALING</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Multiplied to all matrices for numerical stability</span>
<span class="n">PROMOTER_NORM_TYPE</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Matrix 1-norm</span>
<span class="n">PROMOTER_MAX_ITERATIONS</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">PROMOTER_CONVERGENCE_THRESHOLD</span> <span class="o">=</span> <span class="mf">1e-9</span>
<span class="n">ECOS_0_TOLERANCE</span> <span class="o">=</span> <span class="mf">1e-10</span>  <span class="c1"># Tolerance to adjust solver output to 0</span>

<span class="n">BASAL_EXPRESSION_CONDITION</span> <span class="o">=</span> <span class="s2">&quot;M9 Glucose minus AAs&quot;</span>

<span class="n">VERBOSE</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">COUNTS_UNITS</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">dmol</span>
<span class="n">VOLUME_UNITS</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span>
<span class="n">MASS_UNITS</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">g</span>
<span class="n">TIME_UNITS</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span>

<span class="n">functions_run</span> <span class="o">=</span> <span class="p">[]</span>


<div class="viewcode-block" id="fitSimData_1">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.fitSimData_1">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fitSimData_1</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits parameters necessary for the simulation based on the knowledge base</span>

<span class="sd">    Inputs:</span>
<span class="sd">            raw_data (KnowledgeBaseEcoli) - knowledge base consisting of the</span>
<span class="sd">                    necessary raw data</span>
<span class="sd">            cpus (int) - number of processes to use (if &gt; 1, use multiprocessing)</span>
<span class="sd">            debug (bool) - if True, fit only one arbitrarily-chosen transcription</span>
<span class="sd">                    factor in order to speed up a debug cycle (should not be used for</span>
<span class="sd">                    an actual simulation)</span>
<span class="sd">            save_intermediates (bool) - if True, save the state (sim_data and cell_specs)</span>
<span class="sd">                    to disk in intermediates_directory after each Parca step</span>
<span class="sd">            intermediates_directory (str) - path to the directory to save intermediate</span>
<span class="sd">                    sim_data and cell_specs files to</span>
<span class="sd">            load_intermediate (str) - the function name of the Parca step to load</span>
<span class="sd">                    sim_data and cell_specs from; functions prior to and including this</span>
<span class="sd">                    will be skipped but all following functions will run</span>
<span class="sd">            variable_elongation_transcription (bool) - enable variable elongation</span>
<span class="sd">                    for transcription</span>
<span class="sd">            variable_elongation_translation (bool) - enable variable elongation for</span>
<span class="sd">                    translation</span>
<span class="sd">            disable_ribosome_capacity_fitting (bool) - if True, ribosome expression</span>
<span class="sd">                    is not fit to protein synthesis demands</span>
<span class="sd">            disable_rnapoly_capacity_fitting (bool) - if True, RNA polymerase</span>
<span class="sd">                    expression is not fit to protein synthesis demands</span>
<span class="sd">            cache_dir (str) - path to the directory to save cached data for</span>
<span class="sd">                    affinities of RNAs binding to endoRNases</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sim_data</span> <span class="o">=</span> <span class="n">SimulationDataEcoli</span><span class="p">()</span>
    <span class="n">cell_specs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Functions to modify sim_data and/or cell_specs</span>
    <span class="c1"># Functions defined below should be wrapped by @save_state to allow saving</span>
    <span class="c1"># and loading sim_data and cell_specs to skip certain functions while doing</span>
    <span class="c1"># development for faster testing and iteration of later functions that</span>
    <span class="c1"># might not need earlier functions to be rerun each time.</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">initialize</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="n">raw_data</span><span class="o">=</span><span class="n">raw_data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">input_adjustments</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">basal_specs</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">tf_condition_specs</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">fit_condition</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">promoter_binding</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">adjust_promoters</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">set_conditions</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">final_adjustments</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sim_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;sim_data is not specified.  Check that the&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; load_intermediate function (</span><span class="si">{</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;load_intermediate&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="s2">&quot; is correct and matches a function to be run.&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">sim_data</span></div>



<div class="viewcode-block" id="save_state">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.save_state">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">save_state</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for functions called in fitSimData_1() to allow saving and loading</span>
<span class="sd">    of sim_data and cell_specs at different points in the parameter calculation</span>
<span class="sd">    pipeline.  This is useful for development in order to skip time intensive</span>
<span class="sd">    steps that are not required to recalculate in order to work with the desired</span>
<span class="sd">    stage of parameter calculation.</span>

<span class="sd">    This wrapper expects arguments in the kwargs passed into a wrapped function:</span>
<span class="sd">            save_intermediates (bool): if True, the state (sim_data and cell_specs)</span>
<span class="sd">                    will be saved to disk in intermediates_directory</span>
<span class="sd">            intermediates_directory (str): path to the directory to save intermediate</span>
<span class="sd">                    sim_data and cell_specs files to</span>
<span class="sd">            load_intermediate (str): the name of the function to load sim_data and</span>
<span class="sd">                    cell_specs from, functions prior to and including this will be</span>
<span class="sd">                    skipped but all following functions will run</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">load_intermediate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;load_intermediate&quot;</span><span class="p">)</span>
        <span class="n">intermediates_dir</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;intermediates_directory&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Files to save to or load from</span>
        <span class="n">sim_data_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">intermediates_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;sim_data_</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">.cPickle&quot;</span><span class="p">)</span>
        <span class="n">cell_specs_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">intermediates_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;cell_specs_</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">.cPickle&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Run the wrapped function if the function to load is not specified or was already loaded</span>
        <span class="k">if</span> <span class="n">load_intermediate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">load_intermediate</span> <span class="ow">in</span> <span class="n">functions_run</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ran </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2"> s&quot;</span><span class="p">)</span>
        <span class="c1"># Load the saved results from the wrapped function if it is set to be loaded</span>
        <span class="k">elif</span> <span class="n">load_intermediate</span> <span class="o">==</span> <span class="n">func_name</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">sim_data_file</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cell_specs_file</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Could not find intermediate files (</span><span class="si">{</span><span class="n">sim_data_file</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; or </span><span class="si">{</span><span class="n">cell_specs_file</span><span class="si">}</span><span class="s2">) to load. Make sure to save intermediates&quot;</span>
                    <span class="s2">&quot; before trying to load them.&quot;</span>
                <span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sim_data_file</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">sim_data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cell_specs_file</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded sim_data and cell_specs for </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Skip running or loading if a later function will be loaded</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipped </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sim_data</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">cell_specs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Save the current state of the parameter calculator after the function to disk</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;save_intermediates&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">intermediates_dir</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span>
            <span class="ow">and</span> <span class="n">sim_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">intermediates_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sim_data_file</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cell_specs_file</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">cell_specs</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saved data for </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Record which functions have been run to know if the loaded function has run</span>
        <span class="n">functions_run</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>



<div class="viewcode-block" id="initialize">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.initialize">[docs]</a>
<span class="nd">@save_state</span>
<span class="k">def</span><span class="w"> </span><span class="nf">initialize</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="n">raw_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span>
        <span class="n">raw_data</span><span class="o">=</span><span class="n">raw_data</span><span class="p">,</span>
        <span class="n">basal_expression_condition</span><span class="o">=</span><span class="n">BASAL_EXPRESSION_CONDITION</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span></div>



<div class="viewcode-block" id="input_adjustments">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.input_adjustments">[docs]</a>
<span class="nd">@save_state</span>
<span class="k">def</span><span class="w"> </span><span class="nf">input_adjustments</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Limit the number of conditions that are being fit so that execution time decreases</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Warning: Running the Parca in debug mode - not all conditions will be fit&quot;</span>
        <span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="p">}</span>

    <span class="c1"># Make adjustments for metabolic enzymes</span>
    <span class="n">setTranslationEfficiencies</span><span class="p">(</span><span class="n">sim_data</span><span class="p">)</span>
    <span class="n">set_balanced_translation_efficiencies</span><span class="p">(</span><span class="n">sim_data</span><span class="p">)</span>
    <span class="n">setRNAExpression</span><span class="p">(</span><span class="n">sim_data</span><span class="p">)</span>
    <span class="n">setRNADegRates</span><span class="p">(</span><span class="n">sim_data</span><span class="p">)</span>
    <span class="n">setProteinDegRates</span><span class="p">(</span><span class="n">sim_data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span></div>



<div class="viewcode-block" id="basal_specs">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.basal_specs">[docs]</a>
<span class="nd">@save_state</span>
<span class="k">def</span><span class="w"> </span><span class="nf">basal_specs</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">cell_specs</span><span class="p">,</span>
    <span class="n">disable_ribosome_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">disable_rnapoly_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">variable_elongation_transcription</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">variable_elongation_translation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">cell_specs</span> <span class="o">=</span> <span class="n">buildBasalCellSpecifications</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">variable_elongation_transcription</span><span class="p">,</span>
        <span class="n">variable_elongation_translation</span><span class="p">,</span>
        <span class="n">disable_ribosome_capacity_fitting</span><span class="p">,</span>
        <span class="n">disable_rnapoly_capacity_fitting</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Set expression based on ppGpp regulation from basal expression</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">set_ppgpp_expression</span><span class="p">(</span><span class="n">sim_data</span><span class="p">)</span>
    <span class="c1"># TODO (Travis): use ppGpp expression in condition fitting</span>

    <span class="c1"># Modify other properties</span>
    <span class="c1"># Compute Km&#39;s</span>
    <span class="n">Km</span> <span class="o">=</span> <span class="n">setKmCooperativeEndoRNonLinearRNAdecay</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;bulkContainer&quot;</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cache_dir&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">n_transcribed_rnas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;Km_endoRNase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Km</span><span class="p">[:</span><span class="n">n_transcribed_rnas</span><span class="p">]</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">mature_rna_data</span><span class="p">[</span><span class="s2">&quot;Km_endoRNase&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Km</span><span class="p">[</span>
        <span class="n">n_transcribed_rnas</span><span class="p">:</span>
    <span class="p">]</span>

    <span class="c1">## Calculate and set maintenance values</span>
    <span class="c1"># ----- Growth associated maintenance -----</span>
    <span class="n">fitMaintenanceCosts</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;bulkContainer&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span></div>



<div class="viewcode-block" id="tf_condition_specs">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.tf_condition_specs">[docs]</a>
<span class="nd">@save_state</span>
<span class="k">def</span><span class="w"> </span><span class="nf">tf_condition_specs</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">cell_specs</span><span class="p">,</span>
    <span class="n">cpus</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">disable_ribosome_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">disable_rnapoly_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">variable_elongation_transcription</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">variable_elongation_translation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># Limit the number of CPUs before printing it to stdout.</span>
    <span class="n">cpus</span> <span class="o">=</span> <span class="n">parallelization</span><span class="o">.</span><span class="n">cpus</span><span class="p">(</span><span class="n">cpus</span><span class="p">)</span>

    <span class="c1"># Apply updates to cell_specs from buildTfConditionCellSpecifications for each TF condition</span>
    <span class="n">conditions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">))</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span>
            <span class="n">sim_data</span><span class="p">,</span>
            <span class="n">tf</span><span class="p">,</span>
            <span class="n">variable_elongation_transcription</span><span class="p">,</span>
            <span class="n">variable_elongation_translation</span><span class="p">,</span>
            <span class="n">disable_ribosome_capacity_fitting</span><span class="p">,</span>
            <span class="n">disable_rnapoly_capacity_fitting</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">conditions</span>
    <span class="p">]</span>
    <span class="n">apply_updates</span><span class="p">(</span>
        <span class="n">buildTfConditionCellSpecifications</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">conditions</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="n">cpus</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">conditionKey</span> <span class="ow">in</span> <span class="n">cell_specs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">conditionKey</span> <span class="o">==</span> <span class="s2">&quot;basal&quot;</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_expression</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span>
            <span class="n">conditionKey</span>
        <span class="p">][</span><span class="s2">&quot;expression&quot;</span><span class="p">]</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span>
            <span class="n">conditionKey</span>
        <span class="p">][</span><span class="s2">&quot;synthProb&quot;</span><span class="p">]</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_expression</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span>
            <span class="n">conditionKey</span>
        <span class="p">][</span><span class="s2">&quot;cistron_expression&quot;</span><span class="p">]</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">fit_cistron_expression</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;fit_cistron_expression&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="n">buildCombinedConditionCellSpecifications</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">cell_specs</span><span class="p">,</span>
        <span class="n">variable_elongation_transcription</span><span class="p">,</span>
        <span class="n">variable_elongation_translation</span><span class="p">,</span>
        <span class="n">disable_ribosome_capacity_fitting</span><span class="p">,</span>
        <span class="n">disable_rnapoly_capacity_fitting</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span></div>



<div class="viewcode-block" id="fit_condition">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.fit_condition">[docs]</a>
<span class="nd">@save_state</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fit_condition</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="n">cpus</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Apply updates from fitCondition to cell_specs for each fit condition</span>
    <span class="n">conditions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">cell_specs</span><span class="p">))</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">[</span><span class="n">condition</span><span class="p">],</span> <span class="n">condition</span><span class="p">)</span> <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">conditions</span><span class="p">]</span>
    <span class="n">apply_updates</span><span class="p">(</span><span class="n">fitCondition</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">conditions</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="n">cpus</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">condition_label</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cell_specs</span><span class="p">):</span>
        <span class="n">nutrients</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">conditions</span><span class="p">[</span><span class="n">condition_label</span><span class="p">][</span><span class="s2">&quot;nutrients&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nutrients</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">translation_supply_rate</span><span class="p">:</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">translation_supply_rate</span><span class="p">[</span><span class="n">nutrients</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span><span class="n">condition_label</span><span class="p">][</span>
                <span class="s2">&quot;translation_aa_supply&quot;</span>
            <span class="p">]</span>

    <span class="k">return</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span></div>



<div class="viewcode-block" id="promoter_binding">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.promoter_binding">[docs]</a>
<span class="nd">@save_state</span>
<span class="k">def</span><span class="w"> </span><span class="nf">promoter_binding</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fitting promoter binding&quot;</span><span class="p">)</span>
    <span class="c1"># noinspection PyTypeChecker</span>
    <span class="n">fitPromoterBoundProbability</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span></div>



<div class="viewcode-block" id="adjust_promoters">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.adjust_promoters">[docs]</a>
<span class="nd">@save_state</span>
<span class="k">def</span><span class="w"> </span><span class="nf">adjust_promoters</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># noinspection PyTypeChecker</span>
    <span class="n">fitLigandConcentrations</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">)</span>
    <span class="n">calculateRnapRecruitment</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span></div>



<div class="viewcode-block" id="set_conditions">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.set_conditions">[docs]</a>
<span class="nd">@save_state</span>
<span class="k">def</span><span class="w"> </span><span class="nf">set_conditions</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbFraction</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnapFractionActiveDict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbRProtein</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbRnaPolymerase</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaPolymeraseElongationRateDict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">expectedDryMassIncreaseDict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">ribosomeElongationRateDict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">ribosomeFractionActiveDict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">condition_label</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cell_specs</span><span class="p">):</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">conditions</span><span class="p">[</span><span class="n">condition_label</span><span class="p">]</span>
        <span class="n">nutrients</span> <span class="o">=</span> <span class="n">condition</span><span class="p">[</span><span class="s2">&quot;nutrients&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updating mass in condition </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">condition_label</span><span class="p">))</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span><span class="n">condition_label</span><span class="p">]</span>

        <span class="n">concDict</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span><span class="o">.</span><span class="n">concentration_updates</span><span class="o">.</span><span class="n">concentrations_based_on_nutrients</span><span class="p">(</span>
            <span class="n">media_id</span><span class="o">=</span><span class="n">nutrients</span>
        <span class="p">)</span>
        <span class="n">concDict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">getBiomassAsConcentrations</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="n">condition_label</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">avgCellDryMassInit</span><span class="p">,</span> <span class="n">fitAvgSolublePoolMass</span> <span class="o">=</span> <span class="n">rescaleMassForSolubleMetabolites</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="p">,</span>
            <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;bulkContainer&quot;</span><span class="p">],</span>
            <span class="n">concDict</span><span class="p">,</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="n">condition_label</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec</span><span class="p">[</span><span class="s2">&quot;avgCellDryMassInit&quot;</span><span class="p">],</span> <span class="n">avgCellDryMassInit</span><span class="p">))</span>

        <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;avgCellDryMassInit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">avgCellDryMassInit</span>
        <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;fitAvgSolublePoolMass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fitAvgSolublePoolMass</span>

        <span class="n">mRnaSynthProb</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">condition_label</span><span class="p">][</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_mRNA&quot;</span><span class="p">]</span>
        <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">tRnaSynthProb</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">condition_label</span><span class="p">][</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_tRNA&quot;</span><span class="p">]</span>
        <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">rRnaSynthProb</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">condition_label</span><span class="p">][</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_rRNA&quot;</span><span class="p">]</span>
        <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condition</span><span class="p">[</span><span class="s2">&quot;perturbations&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nutrients</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbFraction</span><span class="p">:</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbFraction</span><span class="p">[</span><span class="n">nutrients</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;mRna&quot;</span><span class="p">:</span> <span class="n">mRnaSynthProb</span><span class="p">,</span>
                    <span class="s2">&quot;tRna&quot;</span><span class="p">:</span> <span class="n">tRnaSynthProb</span><span class="p">,</span>
                    <span class="s2">&quot;rRna&quot;</span><span class="p">:</span> <span class="n">rRnaSynthProb</span><span class="p">,</span>
                <span class="p">}</span>

            <span class="k">if</span> <span class="n">nutrients</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbRProtein</span><span class="p">:</span>
                <span class="n">prob</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">condition_label</span><span class="p">][</span>
                    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span>
                        <span class="s2">&quot;includes_ribosomal_protein&quot;</span>
                    <span class="p">]</span>
                <span class="p">]</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbRProtein</span><span class="p">[</span><span class="n">nutrients</span><span class="p">]</span> <span class="o">=</span> <span class="n">prob</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="n">nutrients</span>
                <span class="ow">not</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbRnaPolymerase</span>
            <span class="p">):</span>
                <span class="n">prob</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">condition_label</span><span class="p">][</span>
                    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;includes_RNAP&quot;</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaSynthProbRnaPolymerase</span><span class="p">[</span><span class="n">nutrients</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">prob</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">nutrients</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnapFractionActiveDict</span><span class="p">:</span>
                <span class="n">frac</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">growth_rate_parameters</span><span class="o">.</span><span class="n">get_fraction_active_rnap</span><span class="p">(</span>
                    <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;doubling_time&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnapFractionActiveDict</span><span class="p">[</span><span class="n">nutrients</span><span class="p">]</span> <span class="o">=</span> <span class="n">frac</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="n">nutrients</span>
                <span class="ow">not</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaPolymeraseElongationRateDict</span>
            <span class="p">):</span>
                <span class="n">rate</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">growth_rate_parameters</span><span class="o">.</span><span class="n">get_rnap_elongation_rate</span><span class="p">(</span>
                    <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;doubling_time&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rnaPolymeraseElongationRateDict</span><span class="p">[</span>
                    <span class="n">nutrients</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">rate</span>

            <span class="k">if</span> <span class="n">nutrients</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">expectedDryMassIncreaseDict</span><span class="p">:</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">expectedDryMassIncreaseDict</span><span class="p">[</span><span class="n">nutrients</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[</span>
                    <span class="s2">&quot;avgCellDryMassInit&quot;</span>
                <span class="p">]</span>

            <span class="k">if</span> <span class="n">nutrients</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">ribosomeElongationRateDict</span><span class="p">:</span>
                <span class="n">rate</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">growth_rate_parameters</span><span class="o">.</span><span class="n">get_ribosome_elongation_rate</span><span class="p">(</span>
                    <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;doubling_time&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">ribosomeElongationRateDict</span><span class="p">[</span><span class="n">nutrients</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">rate</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">nutrients</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">ribosomeFractionActiveDict</span><span class="p">:</span>
                <span class="n">frac</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">growth_rate_parameters</span><span class="o">.</span><span class="n">get_fraction_active_ribosome</span><span class="p">(</span>
                    <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;doubling_time&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">ribosomeFractionActiveDict</span><span class="p">[</span><span class="n">nutrients</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">frac</span>
                <span class="p">)</span>

    <span class="k">return</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span></div>



<div class="viewcode-block" id="final_adjustments">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.final_adjustments">[docs]</a>
<span class="nd">@save_state</span>
<span class="k">def</span><span class="w"> </span><span class="nf">final_adjustments</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Adjust expression for RNA attenuation</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">calculate_attenuation</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">)</span>

    <span class="c1"># Adjust ppGpp regulated expression after conditions have been fit for physiological constraints</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">adjust_polymerizing_ppgpp_expression</span><span class="p">(</span><span class="n">sim_data</span><span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">adjust_ppgpp_expression_for_tfs</span><span class="p">(</span><span class="n">sim_data</span><span class="p">)</span>

    <span class="c1"># Set supply constants for amino acids based on condition supply requirements</span>
    <span class="n">average_basal_container</span> <span class="o">=</span> <span class="n">create_bulk_container</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">n_seeds</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">average_with_aa_container</span> <span class="o">=</span> <span class="n">create_bulk_container</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="s2">&quot;with_aa&quot;</span><span class="p">,</span> <span class="n">n_seeds</span><span class="o">=</span><span class="mi">5</span>
    <span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span><span class="o">.</span><span class="n">set_phenomological_supply_constants</span><span class="p">(</span><span class="n">sim_data</span><span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span><span class="o">.</span><span class="n">set_mechanistic_supply_constants</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="n">average_basal_container</span><span class="p">,</span> <span class="n">average_with_aa_container</span>
    <span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span><span class="o">.</span><span class="n">set_mechanistic_export_constants</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="n">average_basal_container</span>
    <span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span><span class="o">.</span><span class="n">set_mechanistic_uptake_constants</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="n">average_with_aa_container</span>
    <span class="p">)</span>

    <span class="c1"># Set ppGpp reaction parameters</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">set_ppgpp_kinetics_parameters</span><span class="p">(</span>
        <span class="n">average_basal_container</span><span class="p">,</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span></div>



<div class="viewcode-block" id="apply_updates">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.apply_updates">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_updates</span><span class="p">(</span>
    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span>
    <span class="n">args</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span>
    <span class="n">labels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">dest</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">cpus</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use multiprocessing (if cpus &gt; 1) to apply args to a function to get</span>
<span class="sd">    dictionary updates for a destination dictionary.</span>

<span class="sd">    Args:</span>
<span class="sd">            func: function to call with args</span>
<span class="sd">            args: list of args to apply to func</span>
<span class="sd">            labels: label for each set of args for exception information</span>
<span class="sd">            dest: destination dictionary that will be updated with results</span>
<span class="sd">                    from each function call</span>
<span class="sd">            cpus: number of cpus to use</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">cpus</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting </span><span class="si">{}</span><span class="s2"> Parca processes&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cpus</span><span class="p">))</span>

        <span class="c1"># Apply args to func</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">parallelization</span><span class="o">.</span><span class="n">pool</span><span class="p">(</span><span class="n">cpus</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="n">label</span><span class="p">:</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">args</span><span class="p">)}</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

        <span class="c1"># Check results from function calls and update dest</span>
        <span class="n">failed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">successful</span><span class="p">():</span>
                <span class="n">dest</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># noinspection PyBroadException</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
                    <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="c1"># Cleanup</span>
        <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Error(s) raised for </span><span class="si">{}</span><span class="s2"> while using multiple processes&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;End parallel processing&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">dest</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">))</span></div>



<div class="viewcode-block" id="buildBasalCellSpecifications">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.buildBasalCellSpecifications">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">buildBasalCellSpecifications</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">variable_elongation_transcription</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">variable_elongation_translation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">disable_ribosome_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">disable_rnapoly_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates cell specifications for the basal condition by fitting expression.</span>
<span class="sd">    Relies on expressionConverge() to set the expression and update masses.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - disable_ribosome_capacity_fitting (bool) - if True, ribosome expression</span>
<span class="sd">    is not fit</span>
<span class="sd">    - disable_rnapoly_capacity_fitting (bool) - if True, RNA polymerase</span>
<span class="sd">    expression is not fit</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - Metabolite concentrations based on &#39;minimal&#39; nutrients</span>
<span class="sd">    - &#39;basal&#39; RNA expression</span>
<span class="sd">    - &#39;basal&#39; doubling time</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - Average mass values of the cell</span>
<span class="sd">    - cistron expression</span>
<span class="sd">    - RNA expression and synthesis probabilities</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - dict {&#39;basal&#39;: dict} with the following keys in the dict from key &#39;basal&#39;:</span>
<span class="sd">            &#39;concDict&#39; {metabolite_name (str): concentration (float with units)} -</span>
<span class="sd">                    dictionary of concentrations for each metabolite with a concentration</span>
<span class="sd">            &#39;fit_cistron_expression&#39; (array of floats) - hypothetical expression for</span>
<span class="sd">                    each RNA cistron post-fit, total normalized to 1, if all</span>
<span class="sd">                    transcription units were monocistronic</span>
<span class="sd">            &#39;expression&#39; (array of floats) - expression for each RNA, total normalized to 1</span>
<span class="sd">            &#39;doubling_time&#39; (float with units) - cell doubling time</span>
<span class="sd">            &#39;synthProb&#39; (array of floats) - synthesis probability for each RNA,</span>
<span class="sd">                    total normalized to 1</span>
<span class="sd">            &#39;avgCellDryMassInit&#39; (float with units) - average initial cell dry mass</span>
<span class="sd">            &#39;fitAvgSolubleTargetMolMass&#39; (float with units) - the adjusted dry mass</span>
<span class="sd">                    of the soluble fraction of a cell</span>
<span class="sd">            - bulkContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">                    for expected counts based on expression of all bulk molecules</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - TODO - sets sim_data attributes and returns values - change to only return values</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create dictionary for basal condition</span>
    <span class="n">cell_specs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;concDict&quot;</span><span class="p">:</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span><span class="o">.</span><span class="n">concentration_updates</span><span class="o">.</span><span class="n">concentrations_based_on_nutrients</span><span class="p">(</span>
            <span class="n">media_id</span><span class="o">=</span><span class="s2">&quot;minimal&quot;</span>
        <span class="p">),</span>
        <span class="s2">&quot;expression&quot;</span><span class="p">:</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_expression</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="s2">&quot;doubling_time&quot;</span><span class="p">:</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="c1"># Determine expression and synthesis probabilities</span>
    <span class="p">(</span>
        <span class="n">expression</span><span class="p">,</span>
        <span class="n">synthProb</span><span class="p">,</span>
        <span class="n">fit_cistron_expression</span><span class="p">,</span>
        <span class="n">avgCellDryMassInit</span><span class="p">,</span>
        <span class="n">fitAvgSolubleTargetMolMass</span><span class="p">,</span>
        <span class="n">bulkContainer</span><span class="p">,</span>
        <span class="n">_</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">expressionConverge</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;expression&quot;</span><span class="p">],</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;concDict&quot;</span><span class="p">],</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;doubling_time&quot;</span><span class="p">],</span>
        <span class="n">conditionKey</span><span class="o">=</span><span class="s2">&quot;basal&quot;</span><span class="p">,</span>
        <span class="n">variable_elongation_transcription</span><span class="o">=</span><span class="n">variable_elongation_transcription</span><span class="p">,</span>
        <span class="n">variable_elongation_translation</span><span class="o">=</span><span class="n">variable_elongation_translation</span><span class="p">,</span>
        <span class="n">disable_ribosome_capacity_fitting</span><span class="o">=</span><span class="n">disable_ribosome_capacity_fitting</span><span class="p">,</span>
        <span class="n">disable_rnapoly_capacity_fitting</span><span class="o">=</span><span class="n">disable_rnapoly_capacity_fitting</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Store calculated values</span>
    <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;expression&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expression</span>
    <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;synthProb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">synthProb</span>
    <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;fit_cistron_expression&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_cistron_expression</span>
    <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;avgCellDryMassInit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">avgCellDryMassInit</span>
    <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;fitAvgSolubleTargetMolMass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fitAvgSolubleTargetMolMass</span>
    <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;bulkContainer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulkContainer</span>

    <span class="c1"># Modify sim_data mass</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_dry_mass_init</span> <span class="o">=</span> <span class="n">avgCellDryMassInit</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_dry_mass</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_dry_mass_init</span>
        <span class="o">*</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_to_initial_cell_conversion_factor</span>
    <span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_water_mass_init</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_dry_mass_init</span>
        <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">cell_dry_mass_fraction</span>
        <span class="o">*</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">cell_water_mass_fraction</span>
    <span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">fitAvgSolubleTargetMolMass</span> <span class="o">=</span> <span class="n">fitAvgSolubleTargetMolMass</span>

    <span class="c1"># Modify sim_data expression</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_expression</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span>
        <span class="s2">&quot;expression&quot;</span>
    <span class="p">]</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span>
        <span class="s2">&quot;synthProb&quot;</span>
    <span class="p">]</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">fit_cistron_expression</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span>
        <span class="s2">&quot;basal&quot;</span>
    <span class="p">][</span><span class="s2">&quot;fit_cistron_expression&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">cell_specs</span></div>



<div class="viewcode-block" id="buildTfConditionCellSpecifications">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.buildTfConditionCellSpecifications">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">buildTfConditionCellSpecifications</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">tf</span><span class="p">,</span>
    <span class="n">variable_elongation_transcription</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">variable_elongation_translation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">disable_ribosome_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">disable_rnapoly_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates cell specifications for a given transcription factor by</span>
<span class="sd">    fitting expression. Will set for the active and inactive TF condition.</span>
<span class="sd">    Relies on expressionConverge() to set the expression and masses.</span>
<span class="sd">    Uses fold change data relative to the &#39;basal&#39; condition to determine</span>
<span class="sd">    expression for a given TF.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - tf (str) - label for the transcription factor to fit (eg. &#39;CPLX-125&#39;)</span>
<span class="sd">    - disable_ribosome_capacity_fitting (bool) - if True, ribosome expression</span>
<span class="sd">    is not fit</span>
<span class="sd">    - disable_rnapoly_capacity_fitting (bool) - if True, RNA polymerase</span>
<span class="sd">    expression is not fit</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - Metabolite concentrations based on nutrients for the TF</span>
<span class="sd">    - Adjusted &#39;basal&#39; cistron expression</span>
<span class="sd">    - Doubling time for the TF</span>
<span class="sd">    - Fold changes in expression for each gene given the TF</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - dict {tf + &#39;__active&#39;/&#39;__inactive&#39;: dict} with the following keys in each dict:</span>
<span class="sd">            &#39;concDict&#39; {metabolite_name (str): concentration (float with units)} -</span>
<span class="sd">                    dictionary of concentrations for each metabolite with a concentration</span>
<span class="sd">            &#39;expression&#39; (array of floats) - expression for each RNA, total normalized to 1</span>
<span class="sd">            &#39;doubling_time&#39; (float with units) - cell doubling time</span>
<span class="sd">            &#39;synthProb&#39; (array of floats) - synthesis probability for each RNA,</span>
<span class="sd">                    total normalized to 1</span>
<span class="sd">            &#39;cistron_expression&#39; (array of floats) - hypothetical expression for</span>
<span class="sd">                    each RNA cistron, calculated from basal cistron expression levels</span>
<span class="sd">                    and fold change data</span>
<span class="sd">            &#39;fit_cistron_expression&#39; (array of floats) - hypothetical expression for</span>
<span class="sd">                    each RNA cistron post-fit, total normalized to 1, if all</span>
<span class="sd">                    transcription units were monocistronic</span>
<span class="sd">            &#39;avgCellDryMassInit&#39; (float with units) - average initial cell dry mass</span>
<span class="sd">            &#39;fitAvgSolubleTargetMolMass&#39; (float with units) - the adjusted dry mass</span>
<span class="sd">                    of the soluble fraction of a cell</span>
<span class="sd">            - bulkContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">                    for expected counts based on expression of all bulk molecules</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cell_specs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;__active&quot;</span><span class="p">,</span> <span class="s2">&quot;__inactive&quot;</span><span class="p">]:</span>
        <span class="n">conditionKey</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">+</span> <span class="n">choice</span>
        <span class="n">conditionValue</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">conditions</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span>

        <span class="c1"># Get expression for the condition based on fold changes over &#39;basal&#39;</span>
        <span class="c1"># condition if the condition is not the same as &#39;basal&#39;</span>
        <span class="n">fcData</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="s2">&quot;__active&quot;</span> <span class="ow">and</span> <span class="n">conditionValue</span> <span class="o">!=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">conditions</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]:</span>
            <span class="n">fcData</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_fold_change</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="s2">&quot;__inactive&quot;</span> <span class="ow">and</span> <span class="n">conditionValue</span> <span class="o">!=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">conditions</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]:</span>
            <span class="n">fcDataTmp</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_fold_change</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">fcDataTmp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">fcData</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">value</span>
        <span class="n">expression</span><span class="p">,</span> <span class="n">cistron_expression</span> <span class="o">=</span> <span class="n">expressionFromConditionAndFoldChange</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="p">,</span>
            <span class="n">conditionValue</span><span class="p">[</span><span class="s2">&quot;perturbations&quot;</span><span class="p">],</span>
            <span class="n">fcData</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Get metabolite concentrations for the condition</span>
        <span class="n">concDict</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span><span class="o">.</span><span class="n">concentration_updates</span><span class="o">.</span><span class="n">concentrations_based_on_nutrients</span><span class="p">(</span>
            <span class="n">media_id</span><span class="o">=</span><span class="n">conditionValue</span><span class="p">[</span><span class="s2">&quot;nutrients&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">concDict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">getBiomassAsConcentrations</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Create dictionary for the condition</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;concDict&quot;</span><span class="p">:</span> <span class="n">concDict</span><span class="p">,</span>
            <span class="s2">&quot;expression&quot;</span><span class="p">:</span> <span class="n">expression</span><span class="p">,</span>
            <span class="s2">&quot;doubling_time&quot;</span><span class="p">:</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">conditionKey</span><span class="p">,</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span>
            <span class="p">),</span>
        <span class="p">}</span>

        <span class="c1"># Determine expression and synthesis probabilities</span>
        <span class="p">(</span>
            <span class="n">expression</span><span class="p">,</span>
            <span class="n">synthProb</span><span class="p">,</span>
            <span class="n">fit_cistron_expression</span><span class="p">,</span>
            <span class="n">avgCellDryMassInit</span><span class="p">,</span>
            <span class="n">fitAvgSolubleTargetMolMass</span><span class="p">,</span>
            <span class="n">bulkContainer</span><span class="p">,</span>
            <span class="n">concDict</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">expressionConverge</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="p">,</span>
            <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;expression&quot;</span><span class="p">],</span>
            <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;concDict&quot;</span><span class="p">],</span>
            <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;doubling_time&quot;</span><span class="p">],</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;Km_endoRNase&quot;</span><span class="p">],</span>
            <span class="n">conditionKey</span><span class="o">=</span><span class="n">conditionKey</span><span class="p">,</span>
            <span class="n">variable_elongation_transcription</span><span class="o">=</span><span class="n">variable_elongation_transcription</span><span class="p">,</span>
            <span class="n">variable_elongation_translation</span><span class="o">=</span><span class="n">variable_elongation_translation</span><span class="p">,</span>
            <span class="n">disable_ribosome_capacity_fitting</span><span class="o">=</span><span class="n">disable_ribosome_capacity_fitting</span><span class="p">,</span>
            <span class="n">disable_rnapoly_capacity_fitting</span><span class="o">=</span><span class="n">disable_rnapoly_capacity_fitting</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Store calculated values</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;expression&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expression</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;synthProb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">synthProb</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;cistron_expression&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cistron_expression</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;fit_cistron_expression&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_cistron_expression</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;avgCellDryMassInit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">avgCellDryMassInit</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;fitAvgSolubleTargetMolMass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">fitAvgSolubleTargetMolMass</span>
        <span class="p">)</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;bulkContainer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulkContainer</span>

    <span class="k">return</span> <span class="n">cell_specs</span></div>



<div class="viewcode-block" id="buildCombinedConditionCellSpecifications">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.buildCombinedConditionCellSpecifications">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">buildCombinedConditionCellSpecifications</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">cell_specs</span><span class="p">,</span>
    <span class="n">variable_elongation_transcription</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">variable_elongation_translation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">disable_ribosome_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">disable_rnapoly_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates cell specifications for sets of transcription factors being active.</span>
<span class="sd">    These sets include conditions like &#39;with_aa&#39; or &#39;no_oxygen&#39; where multiple</span>
<span class="sd">    transcription factors will be active at the same time.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - cell_specs {condition (str): dict} - information about each individual</span>
<span class="sd">    transcription factor condition</span>
<span class="sd">    - disable_ribosome_capacity_fitting (bool) - if True, ribosome expression</span>
<span class="sd">    is not fit</span>
<span class="sd">    - disable_rnapoly_capacity_fitting (bool) - if True, RNA polymerase</span>
<span class="sd">    expression is not fit</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - Metabolite concentrations based on nutrients for the condition</span>
<span class="sd">    - Adjusted &#39;basal&#39; RNA expression</span>
<span class="sd">    - Doubling time for the combined condition</span>
<span class="sd">    - Fold changes in expression for each gene given the TF</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - cell_specs dictionary for each combined condition</span>
<span class="sd">    - RNA expression and synthesis probabilities for each combined condition</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - TODO - determine how to handle fold changes when multiple TFs change the</span>
<span class="sd">    same gene because multiplying both fold changes together might not be</span>
<span class="sd">    appropriate</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">conditionKey</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_active_tfs</span><span class="p">:</span>
        <span class="c1"># Skip adjustments if &#39;basal&#39; condition</span>
        <span class="k">if</span> <span class="n">conditionKey</span> <span class="o">==</span> <span class="s2">&quot;basal&quot;</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Get expression from fold changes for each TF in the given condition</span>
        <span class="n">fcData</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">conditionValue</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">conditions</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_active_tfs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">gene</span><span class="p">,</span> <span class="n">fc</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_fold_change</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">fcData</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcData</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fc</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_inactive_tfs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">gene</span><span class="p">,</span> <span class="n">fc</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_fold_change</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">fcData</span><span class="p">[</span><span class="n">gene</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcData</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">gene</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">fc</span>

        <span class="n">expression</span><span class="p">,</span> <span class="n">cistron_expression</span> <span class="o">=</span> <span class="n">expressionFromConditionAndFoldChange</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="p">,</span>
            <span class="n">conditionValue</span><span class="p">[</span><span class="s2">&quot;perturbations&quot;</span><span class="p">],</span>
            <span class="n">fcData</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Get metabolite concentrations for the condition</span>
        <span class="n">concDict</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span><span class="o">.</span><span class="n">concentration_updates</span><span class="o">.</span><span class="n">concentrations_based_on_nutrients</span><span class="p">(</span>
            <span class="n">media_id</span><span class="o">=</span><span class="n">conditionValue</span><span class="p">[</span><span class="s2">&quot;nutrients&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">concDict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">getBiomassAsConcentrations</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Create dictionary for the condition</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;concDict&quot;</span><span class="p">:</span> <span class="n">concDict</span><span class="p">,</span>
            <span class="s2">&quot;expression&quot;</span><span class="p">:</span> <span class="n">expression</span><span class="p">,</span>
            <span class="s2">&quot;doubling_time&quot;</span><span class="p">:</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">conditionKey</span><span class="p">,</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span>
            <span class="p">),</span>
        <span class="p">}</span>

        <span class="c1"># Determine expression and synthesis probabilities</span>
        <span class="p">(</span>
            <span class="n">expression</span><span class="p">,</span>
            <span class="n">synthProb</span><span class="p">,</span>
            <span class="n">fit_cistron_expression</span><span class="p">,</span>
            <span class="n">avgCellDryMassInit</span><span class="p">,</span>
            <span class="n">fitAvgSolubleTargetMolMass</span><span class="p">,</span>
            <span class="n">bulkContainer</span><span class="p">,</span>
            <span class="n">concDict</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">expressionConverge</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="p">,</span>
            <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;expression&quot;</span><span class="p">],</span>
            <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;concDict&quot;</span><span class="p">],</span>
            <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;doubling_time&quot;</span><span class="p">],</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;Km_endoRNase&quot;</span><span class="p">],</span>
            <span class="n">conditionKey</span><span class="o">=</span><span class="n">conditionKey</span><span class="p">,</span>
            <span class="n">variable_elongation_transcription</span><span class="o">=</span><span class="n">variable_elongation_transcription</span><span class="p">,</span>
            <span class="n">variable_elongation_translation</span><span class="o">=</span><span class="n">variable_elongation_translation</span><span class="p">,</span>
            <span class="n">disable_ribosome_capacity_fitting</span><span class="o">=</span><span class="n">disable_ribosome_capacity_fitting</span><span class="p">,</span>
            <span class="n">disable_rnapoly_capacity_fitting</span><span class="o">=</span><span class="n">disable_rnapoly_capacity_fitting</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Modify cell_specs for calculated values</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;expression&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expression</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;synthProb&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">synthProb</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;cistron_expression&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cistron_expression</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;fit_cistron_expression&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_cistron_expression</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;avgCellDryMassInit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">avgCellDryMassInit</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;fitAvgSolubleTargetMolMass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">fitAvgSolubleTargetMolMass</span>
        <span class="p">)</span>
        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;bulkContainer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulkContainer</span>

        <span class="c1"># Modify sim_data expression</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_expression</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span>
            <span class="n">conditionKey</span>
        <span class="p">][</span><span class="s2">&quot;expression&quot;</span><span class="p">]</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span>
            <span class="n">conditionKey</span>
        <span class="p">][</span><span class="s2">&quot;synthProb&quot;</span><span class="p">]</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_expression</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span>
            <span class="n">conditionKey</span>
        <span class="p">][</span><span class="s2">&quot;cistron_expression&quot;</span><span class="p">]</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">fit_cistron_expression</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;fit_cistron_expression&quot;</span><span class="p">]</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="expressionConverge">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.expressionConverge">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">expressionConverge</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">expression</span><span class="p">,</span>
    <span class="n">concDict</span><span class="p">,</span>
    <span class="n">doubling_time</span><span class="p">,</span>
    <span class="n">Km</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">conditionKey</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">variable_elongation_transcription</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">variable_elongation_translation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">disable_ribosome_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">disable_rnapoly_capacity_fitting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iteratively fits synthesis probabilities for RNA. Calculates initial</span>
<span class="sd">    expression based on gene expression data and makes adjustments to match</span>
<span class="sd">    physiological constraints for ribosome and RNAP counts. Relies on</span>
<span class="sd">    fitExpression() to converge</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - expression (array of floats) - expression for each RNA, normalized to 1</span>
<span class="sd">    - concDict {metabolite (str): concentration (float with units of mol/volume)} -</span>
<span class="sd">    dictionary for concentrations of each metabolite with location tag</span>
<span class="sd">    - doubling_time (float with units of time) - doubling time</span>
<span class="sd">    - Km (array of floats with units of mol/volume) - Km for each RNA associated</span>
<span class="sd">    with RNases</span>
<span class="sd">    - disable_ribosome_capacity_fitting (bool) - if True, ribosome expression</span>
<span class="sd">    is not fit</span>
<span class="sd">    - disable_rnapoly_capacity_fitting (bool) - if True, RNA polymerase</span>
<span class="sd">    expression is not fit</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - MAX_FITTING_ITERATIONS (int) - number of iterations to adjust expression</span>
<span class="sd">    before an exception is raised</span>
<span class="sd">    - FITNESS_THRESHOLD (float) - acceptable change from one iteration to break</span>
<span class="sd">    the fitting loop</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - expression (array of floats) - adjusted expression for each RNA,</span>
<span class="sd">    normalized to 1</span>
<span class="sd">    - synthProb (array of floats) - synthesis probability for each RNA which</span>
<span class="sd">    accounts for expression and degradation rate, normalized to 1</span>
<span class="sd">    - avgCellDryMassInit (float with units of mass) - expected initial dry cell mass</span>
<span class="sd">    - fitAvgSolubleTargetMolMass (float with units of mass) - the adjusted dry mass</span>
<span class="sd">    of the soluble fraction of a cell</span>
<span class="sd">    - bulkContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">            for expected counts based on expression of all bulk molecules</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Fitting RNA synthesis probabilities for condition </span><span class="si">{</span><span class="n">conditionKey</span><span class="si">}</span><span class="s2"> ...&quot;</span><span class="p">,</span>
            <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MAX_FITTING_ITERATIONS</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iteration</span><span class="p">))</span>

        <span class="n">initialExpression</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">expression</span> <span class="o">=</span> <span class="n">setInitialRnaExpression</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">)</span>
        <span class="n">bulkContainer</span> <span class="o">=</span> <span class="n">createBulkContainer</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">)</span>
        <span class="n">avgCellDryMassInit</span><span class="p">,</span> <span class="n">fitAvgSolubleTargetMolMass</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">rescaleMassForSolubleMetabolites</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">,</span> <span class="n">concDict</span><span class="p">,</span> <span class="n">doubling_time</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">disable_rnapoly_capacity_fitting</span><span class="p">:</span>
            <span class="n">setRNAPCountsConstrainedByPhysiology</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="p">,</span>
                <span class="n">bulkContainer</span><span class="p">,</span>
                <span class="n">doubling_time</span><span class="p">,</span>
                <span class="n">avgCellDryMassInit</span><span class="p">,</span>
                <span class="n">variable_elongation_transcription</span><span class="p">,</span>
                <span class="n">Km</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">disable_ribosome_capacity_fitting</span><span class="p">:</span>
            <span class="n">setRibosomeCountsConstrainedByPhysiology</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">,</span> <span class="n">variable_elongation_translation</span>
            <span class="p">)</span>

        <span class="c1"># Normalize expression and write out changes</span>
        <span class="n">expression</span><span class="p">,</span> <span class="n">synthProb</span><span class="p">,</span> <span class="n">fit_cistron_expression</span><span class="p">,</span> <span class="n">cistron_expression_res</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">fitExpression</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">,</span> <span class="n">avgCellDryMassInit</span><span class="p">,</span> <span class="n">Km</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">degreeOfFit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">initialExpression</span> <span class="o">-</span> <span class="n">expression</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;degree of fit: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">degreeOfFit</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Average cistron expression residuals: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cistron_expression_res</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">degreeOfFit</span> <span class="o">&lt;</span> <span class="n">FITNESS_THRESHOLD</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;! Fitting converged after </span><span class="si">{}</span><span class="s2"> iterations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">break</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Fitting did not converge&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">expression</span><span class="p">,</span>
        <span class="n">synthProb</span><span class="p">,</span>
        <span class="n">fit_cistron_expression</span><span class="p">,</span>
        <span class="n">avgCellDryMassInit</span><span class="p">,</span>
        <span class="n">fitAvgSolubleTargetMolMass</span><span class="p">,</span>
        <span class="n">bulkContainer</span><span class="p">,</span>
        <span class="n">concDict</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="fitCondition">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.fitCondition">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fitCondition</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">condition</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a given condition and returns the predicted bulk average, bulk deviation,</span>
<span class="sd">    protein monomer average, protein monomer deviation, and amino acid supply to</span>
<span class="sd">    translation. This relies on calculateBulkDistributions and calculateTranslationSupply.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - condition (str) - condition to fit (eg &#39;CPLX0-7705__active&#39;)</span>
<span class="sd">    - spec {property (str): property values} - cell specifications for the given condition.</span>
<span class="sd">    This function uses the specs &quot;expression&quot;, &quot;concDict&quot;, &quot;avgCellDryMassInit&quot;,</span>
<span class="sd">    and &quot;doubling_time&quot;</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - A dictionary {condition (str): spec (dict)} with the updated spec dictionary</span>
<span class="sd">    with the following values updated:</span>
<span class="sd">            - bulkAverageContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">                    for the mean of the counts of all bulk molecules</span>
<span class="sd">            - bulkDeviationContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">                    for the standard deviation of the counts of all bulk molecules</span>
<span class="sd">            - proteinMonomerAverageContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">                    for the mean of the counts of all protein monomers</span>
<span class="sd">            - proteinMonomerDeviationContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">                    for the standard deviation of the counts of all protein monomers</span>
<span class="sd">            - translation_aa_supply (array with units of mol/(mass.time)) - the supply rates</span>
<span class="sd">            for each amino acid to translation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fitting condition </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">condition</span><span class="p">))</span>

    <span class="c1"># Find bulk and protein distributions</span>
    <span class="p">(</span>
        <span class="n">bulkAverageContainer</span><span class="p">,</span>
        <span class="n">bulkDeviationContainer</span><span class="p">,</span>
        <span class="n">proteinMonomerAverageContainer</span><span class="p">,</span>
        <span class="n">proteinMonomerDeviationContainer</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">calculateBulkDistributions</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;expression&quot;</span><span class="p">],</span>
        <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;concDict&quot;</span><span class="p">],</span>
        <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;avgCellDryMassInit&quot;</span><span class="p">],</span>
        <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;doubling_time&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulkAverageContainer</span>
    <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;bulkDeviationContainer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulkDeviationContainer</span>
    <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;proteinMonomerAverageContainer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proteinMonomerAverageContainer</span>
    <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;proteinMonomerDeviationContainer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proteinMonomerDeviationContainer</span>

    <span class="c1"># Find the supply rates of amino acids to translation given doubling time</span>
    <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;translation_aa_supply&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">calculateTranslationSupply</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span>
        <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;doubling_time&quot;</span><span class="p">],</span>
        <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;proteinMonomerAverageContainer&quot;</span><span class="p">],</span>
        <span class="n">spec</span><span class="p">[</span><span class="s2">&quot;avgCellDryMassInit&quot;</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span><span class="n">condition</span><span class="p">:</span> <span class="n">spec</span><span class="p">}</span></div>



<div class="viewcode-block" id="calculateTranslationSupply">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.calculateTranslationSupply">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculateTranslationSupply</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">,</span> <span class="n">avgCellDryMassInit</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the supply rates of all amino acids to translation given the desired</span>
<span class="sd">    doubling time. This creates a limit on the polypeptide elongation process,</span>
<span class="sd">    and thus on growth. The amino acid supply rate is found by calculating the</span>
<span class="sd">    concentration of amino acids per gram dry cell weight and multiplying by the</span>
<span class="sd">    loss to dilution given doubling time.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - doubling_time (float with units of time) - measured doubling times given the condition</span>
<span class="sd">    - bulkContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">            for count of all bulk molecules</span>
<span class="sd">    - avgCellDryMassInit (float with units of mass) - the average initial cell dry mass</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The supply of amino acids should not be based on a desired doubling time,</span>
<span class="sd">    but should come from a more mechanistic basis. This would allow simulations</span>
<span class="sd">    of environmental shifts in which the doubling time is unknown.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">aaCounts</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span>
        <span class="s2">&quot;aa_counts&quot;</span>
    <span class="p">]</span>  <span class="c1"># the counts of each amino acid required for each protein</span>
    <span class="n">protein_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">proteinCounts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">protein_idx</span><span class="p">)</span>  <span class="c1"># the counts of all proteins</span>
    <span class="n">nAvogadro</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span>

    <span class="n">molAAPerGDCW</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">aaCounts</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">proteinCounts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">aa</span> <span class="o">*</span> <span class="n">nAvogadro</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">avgCellDryMassInit</span><span class="p">))</span>

    <span class="c1"># Calculate required amino acid supply to translation to counter dilution</span>
    <span class="n">translation_aa_supply</span> <span class="o">=</span> <span class="n">molAAPerGDCW</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">doubling_time</span>

    <span class="k">return</span> <span class="n">translation_aa_supply</span></div>



<span class="c1"># Sub-fitting functions</span>


<div class="viewcode-block" id="setTranslationEfficiencies">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.setTranslationEfficiencies">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">setTranslationEfficiencies</span><span class="p">(</span><span class="n">sim_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function&#39;s goal is to set translation efficiencies for a subset of metabolic proteins.</span>
<span class="sd">    It first gathers the index of the proteins it wants to modify, then changes the monomer</span>
<span class="sd">    translation efficiencies based on the adjustment that is specified.</span>
<span class="sd">    These adjustments were made so that the simulation could run.</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - For each protein that needs to be modified, it takes in an adjustment factor.</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - This function modifies, for a subset of proteins, their translational efficiencies in sim_data.</span>
<span class="sd">    It takes their current efficiency and multiplies them by the factor specified in adjustments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">protein</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">adjustments</span><span class="o">.</span><span class="n">translation_efficiencies_adjustments</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">protein</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">translation_efficiencies_by_monomer</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">adjustments</span><span class="o">.</span><span class="n">translation_efficiencies_adjustments</span><span class="p">[</span><span class="n">protein</span><span class="p">]</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="set_balanced_translation_efficiencies">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.set_balanced_translation_efficiencies">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_balanced_translation_efficiencies</span><span class="p">(</span><span class="n">sim_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets the translation efficiencies of a group of proteins to be equal to the</span>
<span class="sd">    mean value of all proteins within the group.</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - List of proteins that should have balanced translation efficiencies.</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - Translation efficiencies of proteins within each specified group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">monomer_id_to_index</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">][:</span><span class="o">-</span><span class="mi">3</span><span class="p">]:</span> <span class="n">i</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">monomer</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">proteins</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">adjustments</span><span class="o">.</span><span class="n">balanced_translation_efficiencies</span><span class="p">:</span>
        <span class="n">protein_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">monomer_id_to_index</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">proteins</span><span class="p">])</span>
        <span class="n">mean_trl_eff</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">translation_efficiencies_by_monomer</span><span class="p">[</span>
            <span class="n">protein_indexes</span>
        <span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">translation_efficiencies_by_monomer</span><span class="p">[</span>
            <span class="n">protein_indexes</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">mean_trl_eff</span></div>



<div class="viewcode-block" id="setRNAExpression">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.setRNAExpression">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">setRNAExpression</span><span class="p">(</span><span class="n">sim_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function&#39;s goal is to set expression levels for a subset of RNAs.</span>
<span class="sd">    It first gathers the index of the RNA&#39;s it wants to modify, then changes</span>
<span class="sd">    the expression levels of those RNAs, within sim_data, based on the</span>
<span class="sd">    specified adjustment factor. If the specified ID is an RNA cistron, the</span>
<span class="sd">    expression levels of all RNA molecules containing the cistron are adjusted.</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - For each RNA that needs to be modified, it takes in an adjustment factor.</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - This function modifies the basal RNA expression levels set in sim_data,</span>
<span class="sd">    for the chosen RNAs. It takes their current basal expression and multiplies</span>
<span class="sd">    them by the factor specified in adjustments.</span>
<span class="sd">    - After updating the basal expression levels for the given RNAs, the</span>
<span class="sd">    function normalizes all the basal expression levels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cistron_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">rna_id_to_index</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">rna_id</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]:</span> <span class="n">i</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rna_id</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="p">}</span>

    <span class="n">rna_index_to_adjustment</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">mol_id</span><span class="p">,</span> <span class="n">adj_factor</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">adjustments</span><span class="o">.</span><span class="n">rna_expression_adjustments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">mol_id</span> <span class="ow">in</span> <span class="n">cistron_ids</span><span class="p">:</span>
            <span class="c1"># Find indexes of all RNAs containing the cistron</span>
            <span class="n">rna_indexes</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_id_to_rna_indexes</span><span class="p">(</span>
                <span class="n">mol_id</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">mol_id</span> <span class="ow">in</span> <span class="n">rna_id_to_index</span><span class="p">:</span>
            <span class="n">rna_indexes</span> <span class="o">=</span> <span class="n">rna_id_to_index</span><span class="p">[</span><span class="n">mol_id</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Molecule ID </span><span class="si">{</span><span class="n">mol_id</span><span class="si">}</span><span class="s2"> not found in list of cistrons or transcription units.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If multiple adjustments are made for the same RNA, take the maximum</span>
        <span class="c1"># adjustment factor</span>
        <span class="k">for</span> <span class="n">rna_index</span> <span class="ow">in</span> <span class="n">rna_indexes</span><span class="p">:</span>
            <span class="n">rna_index_to_adjustment</span><span class="p">[</span><span class="n">rna_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">rna_index_to_adjustment</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rna_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">adj_factor</span>
            <span class="p">)</span>

    <span class="c1"># Multiply all degradation rates with the specified adjustment factor</span>
    <span class="k">for</span> <span class="n">rna_index</span><span class="p">,</span> <span class="n">adj_factor</span> <span class="ow">in</span> <span class="n">rna_index_to_adjustment</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_expression</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="n">rna_index</span><span class="p">]</span> <span class="o">*=</span> <span class="n">adj_factor</span>

    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_expression</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span> <span class="o">/=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_expression</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="setRNADegRates">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.setRNADegRates">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">setRNADegRates</span><span class="p">(</span><span class="n">sim_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function&#39;s goal is to adjust the degradation rates for a subset of</span>
<span class="sd">    metabolic RNA&#39;s. It first gathers the index of the RNA&#39;s it wants to modify,</span>
<span class="sd">    then changes the degradation rates of those RNAs. If the specified ID is</span>
<span class="sd">    that of an RNA cistron, the degradation rates of all RNA molecules</span>
<span class="sd">    containing the cistron are adjusted. (Note: since RNA concentrations are</span>
<span class="sd">    assumed to be in equilibrium, increasing the degradation rate increases the</span>
<span class="sd">    synthesis rates of these RNAs)</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - For each RNA that needs to be modified, it takes in an adjustment factor</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - This function modifies the RNA degradation rates for the chosen RNAs in</span>
<span class="sd">    sim_data. It takes their current degradation rate and multiplies them by the</span>
<span class="sd">    factor specified in adjustments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cistron_id_to_index</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">cistron_id</span><span class="p">:</span> <span class="n">i</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cistron_id</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">}</span>
    <span class="n">rna_id_to_index</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">rna_id</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]:</span> <span class="n">i</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">rna_id</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="p">}</span>

    <span class="n">rna_index_to_adjustment</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">mol_id</span><span class="p">,</span> <span class="n">adj_factor</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">adjustments</span><span class="o">.</span><span class="n">rna_deg_rates_adjustments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">mol_id</span> <span class="ow">in</span> <span class="n">cistron_id_to_index</span><span class="p">:</span>
            <span class="c1"># Multiply the cistron degradation rate with the specified</span>
            <span class="c1"># adjustment factor (Note: these rates are not actually used by the</span>
            <span class="c1"># simulation but are still adjusted for bookkeeping purposes)</span>
            <span class="n">cistron_index</span> <span class="o">=</span> <span class="n">cistron_id_to_index</span><span class="p">[</span><span class="n">mol_id</span><span class="p">]</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="o">.</span><span class="n">struct_array</span><span class="p">[</span><span class="s2">&quot;deg_rate&quot;</span><span class="p">][</span>
                <span class="n">cistron_index</span>
            <span class="p">]</span> <span class="o">*=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">adjustments</span><span class="o">.</span><span class="n">rna_deg_rates_adjustments</span><span class="p">[</span><span class="n">mol_id</span><span class="p">]</span>

            <span class="c1"># Find indexes of all RNAs containing the cistron</span>
            <span class="n">rna_indexes</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_id_to_rna_indexes</span><span class="p">(</span>
                <span class="n">mol_id</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">mol_id</span> <span class="ow">in</span> <span class="n">rna_id_to_index</span><span class="p">:</span>
            <span class="n">rna_indexes</span> <span class="o">=</span> <span class="n">rna_id_to_index</span><span class="p">[</span><span class="n">mol_id</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Molecule ID </span><span class="si">{</span><span class="n">mol_id</span><span class="si">}</span><span class="s2"> not found in list of cistrons or transcription units.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If multiple adjustments are made for the same RNA, take the maximum</span>
        <span class="c1"># adjustment factor</span>
        <span class="k">for</span> <span class="n">rna_index</span> <span class="ow">in</span> <span class="n">rna_indexes</span><span class="p">:</span>
            <span class="n">rna_index_to_adjustment</span><span class="p">[</span><span class="n">rna_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="n">rna_index_to_adjustment</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rna_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">adj_factor</span>
            <span class="p">)</span>

    <span class="c1"># Multiply all degradation rates with the specified adjustment factor</span>
    <span class="k">for</span> <span class="n">rna_index</span><span class="p">,</span> <span class="n">adj_factor</span> <span class="ow">in</span> <span class="n">rna_index_to_adjustment</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="o">.</span><span class="n">struct_array</span><span class="p">[</span><span class="s2">&quot;deg_rate&quot;</span><span class="p">][</span><span class="n">rna_index</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
            <span class="n">adj_factor</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="setProteinDegRates">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.setProteinDegRates">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">setProteinDegRates</span><span class="p">(</span><span class="n">sim_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function&#39;s goal is to set the degradation rates for a subset of proteins.</span>
<span class="sd">    It first gathers the index of the proteins it wants to modify, then changes the degradation</span>
<span class="sd">    rates of those proteins. These adjustments were made so that the simulation could run.</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - For each protein that needs to be modified it take in an adjustment factor.</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - This function modifies the protein degradation rates for the chosen proteins in sim_data.</span>
<span class="sd">    It takes their current degradation rate and multiplies them by the factor specified in adjustments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">protein</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">adjustments</span><span class="o">.</span><span class="n">protein_deg_rates_adjustments</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">protein</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="o">.</span><span class="n">struct_array</span><span class="p">[</span><span class="s2">&quot;deg_rate&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">adjustments</span><span class="o">.</span><span class="n">protein_deg_rates_adjustments</span><span class="p">[</span><span class="n">protein</span><span class="p">]</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="rescaleMassForSolubleMetabolites">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.rescaleMassForSolubleMetabolites">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rescaleMassForSolubleMetabolites</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">bulkMolCntr</span><span class="p">,</span> <span class="n">concDict</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust the cell&#39;s mass to accomodate target small molecule concentrations.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - bulkMolCntr (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">            for count of all bulk molecules</span>
<span class="sd">    - concDict (dict) - a dictionary of metabolite ID (string) : concentration (unit&#39;d number, dimensions of concentration) pairs</span>
<span class="sd">    - doubling_time (float with units of time) - measured doubling times given the condition</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - Cell mass fraction data at a given doubling time.</span>
<span class="sd">    - Average cell density.</span>
<span class="sd">    - The conversion factor for transforming from the size of an average cell to the size of a cell</span>
<span class="sd">      immediately following division.</span>
<span class="sd">    - Avogadro&#39;s number.</span>
<span class="sd">    - Concentrations of small molecules (including both dry mass components and water).</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - Adds small molecule counts to bulkMolCntr.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    - newAvgCellDryMassInit, the adjusted dry mass of a cell immediately following division.</span>
<span class="sd">    - fitAvgSolubleTargetMolMass, the adjusted dry mass of the soluble fraction of a cell</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">avgCellFractionMass</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">get_component_masses</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">)</span>

    <span class="n">non_small_molecule_initial_cell_mass</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">avgCellFractionMass</span><span class="p">[</span><span class="s2">&quot;proteinMass&quot;</span><span class="p">]</span>
        <span class="o">+</span> <span class="n">avgCellFractionMass</span><span class="p">[</span><span class="s2">&quot;rnaMass&quot;</span><span class="p">]</span>
        <span class="o">+</span> <span class="n">avgCellFractionMass</span><span class="p">[</span><span class="s2">&quot;dnaMass&quot;</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_to_initial_cell_conversion_factor</span>

    <span class="n">molar_units</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span>

    <span class="n">targetMoleculeIds</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">concDict</span><span class="p">)</span>
    <span class="n">targetMoleculeConcentrations</span> <span class="o">=</span> <span class="n">molar_units</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">concDict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">molar_units</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">targetMoleculeIds</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># Have to strip and replace units to obtain the proper array data type</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">targetMoleculeConcentrations</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">molar_units</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span>
        <span class="s2">&quot;Homeostatic dFBA objective requires non-zero (positive) concentrations&quot;</span>
    <span class="p">)</span>

    <span class="n">molecular_weights</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">getter</span><span class="o">.</span><span class="n">get_masses</span><span class="p">(</span><span class="n">targetMoleculeIds</span><span class="p">)</span>

    <span class="n">massesToAdd</span><span class="p">,</span> <span class="n">countsToAdd</span> <span class="o">=</span> <span class="n">masses_and_counts_for_homeostatic_target</span><span class="p">(</span>
        <span class="n">non_small_molecule_initial_cell_mass</span><span class="p">,</span>
        <span class="n">targetMoleculeConcentrations</span><span class="p">,</span>
        <span class="n">molecular_weights</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">cell_density</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">target_molecule_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">targetMoleculeIds</span><span class="p">,</span> <span class="n">bulkMolCntr</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">bulkMolCntr</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">target_molecule_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">countsToAdd</span>

    <span class="c1"># Increase avgCellDryMassInit to match these numbers &amp; rescale mass fractions</span>
    <span class="n">smallMoleculetargetMoleculesDryMass</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">massesToAdd</span><span class="p">[:</span> <span class="n">targetMoleculeIds</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;WATER[c]&quot;</span><span class="p">)],</span>
            <span class="n">massesToAdd</span><span class="p">[</span><span class="n">targetMoleculeIds</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;WATER[c]&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:],</span>
        <span class="p">)</span>
    <span class="p">)</span>  <span class="c1"># remove water since it&#39;s not part of the dry mass</span>

    <span class="n">newAvgCellDryMassInit</span> <span class="o">=</span> <span class="n">non_small_molecule_initial_cell_mass</span> <span class="o">+</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">smallMoleculetargetMoleculesDryMass</span>
    <span class="p">)</span>
    <span class="n">fitAvgSolubleTargetMolMass</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">smallMoleculetargetMoleculesDryMass</span><span class="p">)</span>
        <span class="o">*</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_to_initial_cell_conversion_factor</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">newAvgCellDryMassInit</span><span class="p">,</span> <span class="n">fitAvgSolubleTargetMolMass</span></div>



<div class="viewcode-block" id="setInitialRnaExpression">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.setInitialRnaExpression">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">setInitialRnaExpression</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a container that with the initial count and ID of each RNA,</span>
<span class="sd">    calculated based on the mass fraction, molecular weight, and expression</span>
<span class="sd">    distribution of each RNA. For rRNA the counts are set based on mass, while</span>
<span class="sd">    for tRNA and mRNA the counts are set based on mass and relative abundance.</span>
<span class="sd">    Relies on the math function totalCountFromMassesAndRatios.</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - Needs information from the knowledge base about the mass fraction,</span>
<span class="sd">    molecular weight, and distribution of each RNA species.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - expression (array of floats) - expression for each RNA, normalized to 1</span>
<span class="sd">    - doubling_time (float with units of time) - doubling time for condition</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - expression (array of floats) - contains the adjusted RNA expression,</span>
<span class="sd">    normalized to 1</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Now rnaData[&quot;synthProb&quot;] does not match &quot;expression&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load from sim_data</span>
    <span class="n">n_avogadro</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span>
    <span class="n">transcription</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span>
    <span class="n">cistron_data</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span>
    <span class="n">rna_data</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span>
    <span class="n">get_average_copy_number</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">get_average_copy_number</span>
    <span class="n">rna_mw</span> <span class="o">=</span> <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;mw&quot;</span><span class="p">]</span>
    <span class="n">rna_rRNA_mw</span> <span class="o">=</span> <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;rRNA_mw&quot;</span><span class="p">]</span>
    <span class="n">rna_tRNA_mw</span> <span class="o">=</span> <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;tRNA_mw&quot;</span><span class="p">]</span>
    <span class="n">rna_coord</span> <span class="o">=</span> <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;replication_coordinate&quot;</span><span class="p">]</span>

    <span class="c1"># Mask arrays for each RNA type</span>
    <span class="n">is_rRNA</span> <span class="o">=</span> <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_rRNA&quot;</span><span class="p">]</span>
    <span class="n">is_tRNA</span> <span class="o">=</span> <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_tRNA&quot;</span><span class="p">]</span>
    <span class="n">is_mRNA</span> <span class="o">=</span> <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_mRNA&quot;</span><span class="p">]</span>

    <span class="c1"># Get list of RNA IDs for each type and tRNA cistron IDs</span>
    <span class="n">all_RNA_ids</span> <span class="o">=</span> <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">ids_rRNA</span> <span class="o">=</span> <span class="n">all_RNA_ids</span><span class="p">[</span><span class="n">is_rRNA</span><span class="p">]</span>
    <span class="n">ids_mRNA</span> <span class="o">=</span> <span class="n">all_RNA_ids</span><span class="p">[</span><span class="n">is_mRNA</span><span class="p">]</span>
    <span class="n">ids_tRNA</span> <span class="o">=</span> <span class="n">all_RNA_ids</span><span class="p">[</span><span class="n">is_tRNA</span><span class="p">]</span>
    <span class="n">ids_tRNA_cistrons</span> <span class="o">=</span> <span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">][</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;is_tRNA&quot;</span><span class="p">]]</span>

    <span class="c1"># Get mass fractions of each RNA type for this condition</span>
    <span class="n">initial_rna_mass</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">get_component_masses</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">)[</span><span class="s2">&quot;rnaMass&quot;</span><span class="p">]</span>
        <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_to_initial_cell_conversion_factor</span>
    <span class="p">)</span>
    <span class="n">ppgpp</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">growth_rate_parameters</span><span class="o">.</span><span class="n">get_ppGpp_conc</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">)</span>
    <span class="n">rna_fractions</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">get_rna_fractions</span><span class="p">(</span><span class="n">ppgpp</span><span class="p">)</span>
    <span class="n">total_mass_rRNA</span> <span class="o">=</span> <span class="n">initial_rna_mass</span> <span class="o">*</span> <span class="n">rna_fractions</span><span class="p">[</span><span class="s2">&quot;rRNA&quot;</span><span class="p">]</span>
    <span class="n">total_mass_tRNA</span> <span class="o">=</span> <span class="n">initial_rna_mass</span> <span class="o">*</span> <span class="n">rna_fractions</span><span class="p">[</span><span class="s2">&quot;tRNA&quot;</span><span class="p">]</span>
    <span class="n">total_mass_mRNA</span> <span class="o">=</span> <span class="n">initial_rna_mass</span> <span class="o">*</span> <span class="n">rna_fractions</span><span class="p">[</span><span class="s2">&quot;mRNA&quot;</span><span class="p">]</span>

    <span class="c1"># Get molecular weights of each RNA. For rRNAs/tRNAs, we only account for</span>
    <span class="c1"># the masses of the mature rRNAs/tRNAs within each RNA, since these RNAs are</span>
    <span class="c1"># almost instantly processed to yield the mature RNAs.</span>
    <span class="n">individual_masses_rRNA</span> <span class="o">=</span> <span class="n">rna_rRNA_mw</span><span class="p">[</span><span class="n">is_rRNA</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_avogadro</span>
    <span class="n">individual_masses_tRNA</span> <span class="o">=</span> <span class="n">rna_tRNA_mw</span><span class="p">[</span><span class="n">is_tRNA</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_avogadro</span>
    <span class="n">individual_masses_mRNA</span> <span class="o">=</span> <span class="n">rna_mw</span><span class="p">[</span><span class="n">is_mRNA</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_avogadro</span>

    <span class="c1"># Set rRNA TU expression assuming equal per-copy transcription</span>
    <span class="c1"># probabilities. The combined expression levels of each rRNA TU are assumed</span>
    <span class="c1"># to be proportional to their expected average copy numbers, which are</span>
    <span class="c1"># dependent on the doubling time and the chromosomal position.</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">doubling_time</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
    <span class="n">coord_rRNA</span> <span class="o">=</span> <span class="n">rna_coord</span><span class="p">[</span><span class="n">is_rRNA</span><span class="p">]</span>
    <span class="n">n_avg_copy_rRNA</span> <span class="o">=</span> <span class="n">get_average_copy_number</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">coord_rRNA</span><span class="p">)</span>
    <span class="n">distribution_rRNA</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">n_avg_copy_rRNA</span><span class="p">)</span>

    <span class="n">total_count_rRNA</span> <span class="o">=</span> <span class="n">totalCountFromMassesAndRatios</span><span class="p">(</span>
        <span class="n">total_mass_rRNA</span><span class="p">,</span> <span class="n">individual_masses_rRNA</span><span class="p">,</span> <span class="n">distribution_rRNA</span>
    <span class="p">)</span>
    <span class="n">counts_rRNA</span> <span class="o">=</span> <span class="n">total_count_rRNA</span> <span class="o">*</span> <span class="n">distribution_rRNA</span>

    <span class="c1"># Get the total mass of tRNAs that are expressed from rRNA TUs and subtract</span>
    <span class="c1"># this mass from the total tRNA mass</span>
    <span class="n">tRNA_masses_in_each_rRNA</span> <span class="o">=</span> <span class="n">rna_tRNA_mw</span><span class="p">[</span><span class="n">is_rRNA</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_avogadro</span>
    <span class="n">total_mass_tRNA_in_rRNAs</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">counts_rRNA</span><span class="p">,</span> <span class="n">tRNA_masses_in_each_rRNA</span><span class="p">)</span>
    <span class="n">total_mass_tRNA</span> <span class="o">-=</span> <span class="n">total_mass_tRNA_in_rRNAs</span>

    <span class="c1"># Get tRNA cistron distribution (see Dong 1996), while setting values for</span>
    <span class="c1"># cistrons that are expressed from rRNAs to zero</span>
    <span class="n">tRNA_distribution</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">get_trna_distribution</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">)</span>
    <span class="n">tRNA_id_to_dist</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">trna_id</span><span class="p">:</span> <span class="n">dist</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">trna_id</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">tRNA_distribution</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">tRNA_distribution</span><span class="p">[</span><span class="s2">&quot;molar_ratio_to_16SrRNA&quot;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">}</span>
    <span class="n">distribution_tRNA_cistrons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ids_tRNA_cistrons</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tRNA_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ids_tRNA_cistrons</span><span class="p">):</span>
        <span class="n">distribution_tRNA_cistrons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tRNA_id_to_dist</span><span class="p">[</span><span class="n">tRNA_id</span><span class="p">]</span>

    <span class="n">tRNA_expressed_from_rRNA_mask</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">cistron_tu_mapping_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">is_rRNA</span>
    <span class="p">)[</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;is_tRNA&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">distribution_tRNA_cistrons</span><span class="p">[</span><span class="n">tRNA_expressed_from_rRNA_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">distribution_tRNA_cistrons</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">distribution_tRNA_cistrons</span><span class="p">)</span>

    <span class="c1"># Approximate distribution of tRNA-including transcripts from tRNA cistron</span>
    <span class="c1"># distribution by using NNLS</span>
    <span class="n">distribution_tRNA_including_transcripts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">fit_trna_expression</span><span class="p">(</span>
        <span class="n">distribution_tRNA_cistrons</span>
    <span class="p">)</span>

    <span class="c1"># Get distribution of tRNA-including transcripts that are not rRNAs</span>
    <span class="n">is_hybrid</span> <span class="o">=</span> <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_rRNA&quot;</span><span class="p">][</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;includes_tRNA&quot;</span><span class="p">]]</span>
    <span class="n">distribution_tRNA</span> <span class="o">=</span> <span class="n">distribution_tRNA_including_transcripts</span><span class="p">[</span><span class="o">~</span><span class="n">is_hybrid</span><span class="p">]</span>
    <span class="n">distribution_tRNA</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">distribution_tRNA</span><span class="p">)</span>

    <span class="c1"># Assign tRNA counts based on this distribution</span>
    <span class="n">total_count_tRNA</span> <span class="o">=</span> <span class="n">totalCountFromMassesAndRatios</span><span class="p">(</span>
        <span class="n">total_mass_tRNA</span><span class="p">,</span> <span class="n">individual_masses_tRNA</span><span class="p">,</span> <span class="n">distribution_tRNA</span>
    <span class="p">)</span>
    <span class="n">counts_tRNA</span> <span class="o">=</span> <span class="n">total_count_tRNA</span> <span class="o">*</span> <span class="n">distribution_tRNA</span>

    <span class="c1"># Assign mRNA counts based on mass and relative abundances (microarrays)</span>
    <span class="n">distribution_mRNA</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">expression</span><span class="p">[</span><span class="n">is_mRNA</span><span class="p">])</span>
    <span class="n">total_count_mRNA</span> <span class="o">=</span> <span class="n">totalCountFromMassesAndRatios</span><span class="p">(</span>
        <span class="n">total_mass_mRNA</span><span class="p">,</span> <span class="n">individual_masses_mRNA</span><span class="p">,</span> <span class="n">distribution_mRNA</span>
    <span class="p">)</span>
    <span class="n">counts_mRNA</span> <span class="o">=</span> <span class="n">total_count_mRNA</span> <span class="o">*</span> <span class="n">distribution_mRNA</span>

    <span class="c1"># Set expression counts in container</span>
    <span class="n">rRNA_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ids_rRNA</span><span class="p">,</span> <span class="n">all_RNA_ids</span><span class="p">)</span>
    <span class="n">tRNA_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ids_tRNA</span><span class="p">,</span> <span class="n">all_RNA_ids</span><span class="p">)</span>
    <span class="n">mRNA_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ids_mRNA</span><span class="p">,</span> <span class="n">all_RNA_ids</span><span class="p">)</span>
    <span class="n">rna_expression_container</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_RNA_ids</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">rna_expression_container</span><span class="p">[</span><span class="n">rRNA_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts_rRNA</span>
    <span class="n">rna_expression_container</span><span class="p">[</span><span class="n">tRNA_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts_tRNA</span>
    <span class="n">rna_expression_container</span><span class="p">[</span><span class="n">mRNA_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts_mRNA</span>

    <span class="n">expression</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">rna_expression_container</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">expression</span></div>



<div class="viewcode-block" id="totalCountIdDistributionProtein">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.totalCountIdDistributionProtein">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">totalCountIdDistributionProtein</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the total counts of proteins from the relative expression of RNA,</span>
<span class="sd">    individual protein mass, and total protein mass. Relies on the math functions</span>
<span class="sd">    netLossRateFromDilutionAndDegradationProtein, proteinDistributionFrommRNA,</span>
<span class="sd">    totalCountFromMassesAndRatios.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - expression (array of floats) - relative frequency distribution of RNA expression</span>
<span class="sd">    - doubling_time (float with units of time) - measured doubling time given the condition</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - total_count_protein (float) - total number of proteins</span>
<span class="sd">    - ids_protein (array of str) - name of each protein with location tag</span>
<span class="sd">    - distribution_protein (array of floats) - distribution for each protein,</span>
<span class="sd">    normalized to 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ids_protein</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">total_mass_protein</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">get_component_masses</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">)[</span><span class="s2">&quot;proteinMass&quot;</span><span class="p">]</span>
        <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_to_initial_cell_conversion_factor</span>
    <span class="p">)</span>
    <span class="n">individual_masses_protein</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;mw&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span>
    <span class="p">)</span>

    <span class="n">mRNA_cistron_expression</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_tu_mapping_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">expression</span><span class="p">)[</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;is_mRNA&quot;</span><span class="p">]</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">distribution_transcripts_by_protein</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">relation</span><span class="o">.</span><span class="n">monomer_to_mRNA_cistron_mapping</span><span class="p">()</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mRNA_cistron_expression</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">translation_efficiencies_by_protein</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">translation_efficiencies_by_monomer</span>
    <span class="p">)</span>
    <span class="n">degradationRates</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;deg_rate&quot;</span><span class="p">]</span>

    <span class="c1"># Find the net protein loss</span>
    <span class="n">netLossRate_protein</span> <span class="o">=</span> <span class="n">netLossRateFromDilutionAndDegradationProtein</span><span class="p">(</span>
        <span class="n">doubling_time</span><span class="p">,</span> <span class="n">degradationRates</span>
    <span class="p">)</span>

    <span class="c1"># Find the protein distribution</span>
    <span class="n">distribution_protein</span> <span class="o">=</span> <span class="n">proteinDistributionFrommRNA</span><span class="p">(</span>
        <span class="n">distribution_transcripts_by_protein</span><span class="p">,</span>
        <span class="n">translation_efficiencies_by_protein</span><span class="p">,</span>
        <span class="n">netLossRate_protein</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Find total protein counts</span>
    <span class="n">total_count_protein</span> <span class="o">=</span> <span class="n">totalCountFromMassesAndRatios</span><span class="p">(</span>
        <span class="n">total_mass_protein</span><span class="p">,</span> <span class="n">individual_masses_protein</span><span class="p">,</span> <span class="n">distribution_protein</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">total_count_protein</span><span class="p">,</span> <span class="n">ids_protein</span><span class="p">,</span> <span class="n">distribution_protein</span></div>



<div class="viewcode-block" id="totalCountIdDistributionRNA">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.totalCountIdDistributionRNA">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">totalCountIdDistributionRNA</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the total counts of RNA from their relative expression,</span>
<span class="sd">    individual mass, and total RNA mass. Relies on the math function</span>
<span class="sd">    totalCountFromMassesAndRatios.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - expression (array of floats) - relative frequency distribution of RNA</span>
<span class="sd">            expression</span>
<span class="sd">    - doubling_time (float with units of time) - measured doubling time given</span>
<span class="sd">            the condition</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - total_count_RNA (float) - total number of RNAs</span>
<span class="sd">    - ids_rnas (array of str) - name of each RNA with location tag</span>
<span class="sd">    - distribution_RNA (array of floats) - distribution for each RNA,</span>
<span class="sd">            normalized to 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">transcription</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span>
    <span class="n">ids_rnas</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">total_mass_RNA</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">get_component_masses</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">)[</span><span class="s2">&quot;rnaMass&quot;</span><span class="p">]</span>
        <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_to_initial_cell_conversion_factor</span>
    <span class="p">)</span>
    <span class="n">mws</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;mw&quot;</span><span class="p">]</span>
    <span class="c1"># Use only the rRNA/tRNA mass for rRNA/tRNA transcription units</span>
    <span class="n">is_rRNA</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_rRNA&quot;</span><span class="p">]</span>
    <span class="n">is_tRNA</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_tRNA&quot;</span><span class="p">]</span>
    <span class="n">mws</span><span class="p">[</span><span class="n">is_rRNA</span><span class="p">]</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;rRNA_mw&quot;</span><span class="p">][</span><span class="n">is_rRNA</span><span class="p">]</span>
    <span class="n">mws</span><span class="p">[</span><span class="n">is_tRNA</span><span class="p">]</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;tRNA_mw&quot;</span><span class="p">][</span><span class="n">is_tRNA</span><span class="p">]</span>
    <span class="n">individual_masses_RNA</span> <span class="o">=</span> <span class="n">mws</span> <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span>

    <span class="n">distribution_RNA</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>

    <span class="n">total_count_RNA</span> <span class="o">=</span> <span class="n">totalCountFromMassesAndRatios</span><span class="p">(</span>
        <span class="n">total_mass_RNA</span><span class="p">,</span> <span class="n">individual_masses_RNA</span><span class="p">,</span> <span class="n">distribution_RNA</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">total_count_RNA</span><span class="p">,</span> <span class="n">ids_rnas</span><span class="p">,</span> <span class="n">distribution_RNA</span></div>



<div class="viewcode-block" id="createBulkContainer">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.createBulkContainer">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">createBulkContainer</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a container that tracks the counts of all bulk molecules. Relies on</span>
<span class="sd">    totalCountIdDistributionRNA and totalCountIdDistributionProtein to set the</span>
<span class="sd">    counts and IDs of all RNAs and proteins.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - expression (array of floats) - relative frequency distribution of RNA expression</span>
<span class="sd">    - doubling_time (float with units of time) - measured doubling time given the condition</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    - bulkContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">            for count of all bulk molecules</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">total_count_RNA</span><span class="p">,</span> <span class="n">ids_rnas</span><span class="p">,</span> <span class="n">distribution_RNA</span> <span class="o">=</span> <span class="n">totalCountIdDistributionRNA</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">doubling_time</span>
    <span class="p">)</span>
    <span class="n">total_count_protein</span><span class="p">,</span> <span class="n">ids_protein</span><span class="p">,</span> <span class="n">distribution_protein</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">totalCountIdDistributionProtein</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">ids_molecules</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>

    <span class="c1"># Construct bulk container</span>
    <span class="n">bulkContainer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">mol_data</span> <span class="k">for</span> <span class="n">mol_data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ids_molecules</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ids_molecules</span><span class="p">)))],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">ids_molecules</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)],</span>
    <span class="p">)</span>

    <span class="c1"># Assign RNA counts based on mass and expression distribution</span>
    <span class="n">counts_RNA</span> <span class="o">=</span> <span class="n">total_count_RNA</span> <span class="o">*</span> <span class="n">distribution_RNA</span>
    <span class="n">rna_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ids_rnas</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">rna_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts_RNA</span>

    <span class="c1"># Assign protein counts based on mass and mRNA counts</span>
    <span class="n">counts_protein</span> <span class="o">=</span> <span class="n">total_count_protein</span> <span class="o">*</span> <span class="n">distribution_protein</span>
    <span class="n">protein_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ids_protein</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">protein_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts_protein</span>

    <span class="k">return</span> <span class="n">bulkContainer</span></div>



<div class="viewcode-block" id="setRibosomeCountsConstrainedByPhysiology">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.setRibosomeCountsConstrainedByPhysiology">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">setRibosomeCountsConstrainedByPhysiology</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">,</span> <span class="n">variable_elongation_translation</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set counts of ribosomal protein subunits based on three constraints:</span>
<span class="sd">    (1) Expected protein distribution doubles in one cell cycle</span>
<span class="sd">    (2) Measured rRNA mass fractions</span>
<span class="sd">    (3) Expected ribosomal protein subunit counts based on RNA expression data</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    bulkContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">            for count of all bulk molecules</span>
<span class="sd">    doubling_time (float with units of time) - doubling time given the condition</span>
<span class="sd">    variable_elongation_translation (bool) - whether there is variable elongation for translation</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - counts of ribosomal protein subunits in bulkContainer</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">active_fraction</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">growth_rate_parameters</span><span class="o">.</span><span class="n">get_fraction_active_ribosome</span><span class="p">(</span>
        <span class="n">doubling_time</span>
    <span class="p">)</span>

    <span class="c1"># Get IDs and stoichiometry of ribosome subunits</span>
    <span class="n">ribosome_30S_subunits</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">get_monomers</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_ids</span><span class="o">.</span><span class="n">s30_full_complex</span>
    <span class="p">)[</span><span class="s2">&quot;subunitIds&quot;</span><span class="p">]</span>
    <span class="n">ribosome_50S_subunits</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">get_monomers</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_ids</span><span class="o">.</span><span class="n">s50_full_complex</span>
    <span class="p">)[</span><span class="s2">&quot;subunitIds&quot;</span><span class="p">]</span>
    <span class="n">ribosome_30S_stoich</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">get_monomers</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_ids</span><span class="o">.</span><span class="n">s30_full_complex</span>
    <span class="p">)[</span><span class="s2">&quot;subunitStoich&quot;</span><span class="p">]</span>
    <span class="n">ribosome_50S_stoich</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">get_monomers</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_ids</span><span class="o">.</span><span class="n">s50_full_complex</span>
    <span class="p">)[</span><span class="s2">&quot;subunitStoich&quot;</span><span class="p">]</span>

    <span class="c1"># Remove rRNA subunits from each array</span>
    <span class="n">monomer_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">remove_rRNA</span><span class="p">(</span><span class="n">subunit_ids</span><span class="p">,</span> <span class="n">subunit_stoich</span><span class="p">):</span>
        <span class="n">is_protein</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">subunit_id</span> <span class="ow">in</span> <span class="n">monomer_ids</span><span class="p">)</span> <span class="k">for</span> <span class="n">subunit_id</span> <span class="ow">in</span> <span class="n">subunit_ids</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">subunit_ids</span><span class="p">[</span><span class="n">is_protein</span><span class="p">],</span> <span class="n">subunit_stoich</span><span class="p">[</span><span class="n">is_protein</span><span class="p">])</span>

    <span class="n">ribosome_30S_subunits</span><span class="p">,</span> <span class="n">ribosome_30S_stoich</span> <span class="o">=</span> <span class="n">remove_rRNA</span><span class="p">(</span>
        <span class="n">ribosome_30S_subunits</span><span class="p">,</span> <span class="n">ribosome_30S_stoich</span>
    <span class="p">)</span>
    <span class="n">ribosome_50S_subunits</span><span class="p">,</span> <span class="n">ribosome_50S_stoich</span> <span class="o">=</span> <span class="n">remove_rRNA</span><span class="p">(</span>
        <span class="n">ribosome_50S_subunits</span><span class="p">,</span> <span class="n">ribosome_50S_stoich</span>
    <span class="p">)</span>

    <span class="c1"># -- CONSTRAINT 1: Expected protein distribution doubling -- #</span>
    <span class="c1">## Calculate minimium number of 30S and 50S subunits required in order to double our expected</span>
    <span class="c1">## protein distribution in one cell cycle</span>
    <span class="n">proteinLengths</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;aa_counts&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">proteinDegradationRates</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;deg_rate&quot;</span><span class="p">]</span>
    <span class="n">protein_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">proteinCounts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">protein_idx</span><span class="p">)</span>

    <span class="n">netLossRate_protein</span> <span class="o">=</span> <span class="n">netLossRateFromDilutionAndDegradationProtein</span><span class="p">(</span>
        <span class="n">doubling_time</span><span class="p">,</span>
        <span class="n">proteinDegradationRates</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">elongation_rates</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">make_elongation_rates</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">growth_rate_parameters</span><span class="o">.</span><span class="n">get_ribosome_elongation_rate</span><span class="p">(</span>
            <span class="n">doubling_time</span>
        <span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">aa</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span><span class="p">),</span>
        <span class="mi">1</span><span class="p">,</span>
        <span class="n">variable_elongation_translation</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">nRibosomesNeeded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
        <span class="n">calculateMinPolymerizingEnzymeByProductDistribution</span><span class="p">(</span>
            <span class="n">proteinLengths</span><span class="p">,</span> <span class="n">elongation_rates</span><span class="p">,</span> <span class="n">netLossRate_protein</span><span class="p">,</span> <span class="n">proteinCounts</span>
        <span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">aa</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">active_fraction</span>
    <span class="p">)</span>

    <span class="c1"># Minimum number of ribosomes needed</span>
    <span class="n">constraint1_ribosome30SCounts</span> <span class="o">=</span> <span class="n">nRibosomesNeeded</span> <span class="o">*</span> <span class="n">ribosome_30S_stoich</span>

    <span class="n">constraint1_ribosome50SCounts</span> <span class="o">=</span> <span class="n">nRibosomesNeeded</span> <span class="o">*</span> <span class="n">ribosome_50S_stoich</span>

    <span class="c1"># -- CONSTRAINT 2: Measured rRNA mass fraction -- #</span>
    <span class="c1"># Get rRNA counts</span>
    <span class="n">rna_data</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span>
    <span class="n">rrna_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">][</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_rRNA&quot;</span><span class="p">]],</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">rRNA_tu_counts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">rrna_idx</span><span class="p">)</span>
    <span class="n">rRNA_cistron_counts</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rRNA_cistron_tu_mapping_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="n">rRNA_tu_counts</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">rRNA_cistron_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;is_rRNA&quot;</span><span class="p">]</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rRNA_23S_counts</span> <span class="o">=</span> <span class="n">rRNA_cistron_counts</span><span class="p">[</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;is_23S_rRNA&quot;</span><span class="p">][</span><span class="n">rRNA_cistron_indexes</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">rRNA_16S_counts</span> <span class="o">=</span> <span class="n">rRNA_cistron_counts</span><span class="p">[</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;is_16S_rRNA&quot;</span><span class="p">][</span><span class="n">rRNA_cistron_indexes</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">rRNA_5S_counts</span> <span class="o">=</span> <span class="n">rRNA_cistron_counts</span><span class="p">[</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;is_5S_rRNA&quot;</span><span class="p">][</span><span class="n">rRNA_cistron_indexes</span><span class="p">]</span>
    <span class="p">]</span>

    <span class="c1">## 16S rRNA is in the 30S subunit</span>
    <span class="n">massFracPredicted_30SCount</span> <span class="o">=</span> <span class="n">rRNA_16S_counts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="c1">## 23S and 5S rRNA are in the 50S subunit</span>
    <span class="n">massFracPredicted_50SCount</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">rRNA_23S_counts</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">rRNA_5S_counts</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

    <span class="n">constraint2_ribosome30SCounts</span> <span class="o">=</span> <span class="n">massFracPredicted_30SCount</span> <span class="o">*</span> <span class="n">ribosome_30S_stoich</span>
    <span class="n">constraint2_ribosome50SCounts</span> <span class="o">=</span> <span class="n">massFracPredicted_50SCount</span> <span class="o">*</span> <span class="n">ribosome_50S_stoich</span>

    <span class="c1"># -- CONSTRAINT 3: Expected ribosomal subunit counts based expression</span>
    <span class="c1">## Calculate fundamental ribosomal subunit count distribution based on RNA expression data</span>
    <span class="c1">## Already calculated and stored in bulkContainer</span>
    <span class="n">ribosome_30S_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ribosome_30S_subunits</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">ribosome30SCounts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">ribosome_30S_idx</span><span class="p">)</span>
    <span class="n">ribosome_50S_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ribosome_50S_subunits</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">ribosome50SCounts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">ribosome_50S_idx</span><span class="p">)</span>

    <span class="c1"># -- SET RIBOSOME FUNDAMENTAL SUBUNIT COUNTS TO MAXIMUM CONSTRAINT -- #</span>
    <span class="n">constraint_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="s2">&quot;Insufficient to double protein counts&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Too small for mass fraction&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Current level OK&quot;</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">rib30lims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">nRibosomesNeeded</span><span class="p">,</span>
            <span class="n">massFracPredicted_30SCount</span><span class="p">,</span>
            <span class="p">(</span><span class="n">ribosome30SCounts</span> <span class="o">/</span> <span class="n">ribosome_30S_stoich</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">rib50lims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">nRibosomesNeeded</span><span class="p">,</span>
            <span class="n">massFracPredicted_50SCount</span><span class="p">,</span>
            <span class="p">(</span><span class="n">ribosome50SCounts</span> <span class="o">/</span> <span class="n">ribosome_50S_stoich</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;30S limit: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">constraint_names</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rib30lims</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="n">rib30lims</span><span class="p">)[</span><span class="mi">0</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;30S actual count: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="p">(</span><span class="n">ribosome30SCounts</span> <span class="o">/</span> <span class="n">ribosome_30S_stoich</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;30S count set to: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">rib30lims</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rib30lims</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="n">rib30lims</span><span class="p">)[</span><span class="mi">0</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;50S limit: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">constraint_names</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rib50lims</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="n">rib50lims</span><span class="p">)[</span><span class="mi">0</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;50S actual count: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="p">(</span><span class="n">ribosome50SCounts</span> <span class="o">/</span> <span class="n">ribosome_50S_stoich</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;50S count set to: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">rib50lims</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rib50lims</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="n">rib50lims</span><span class="p">)[</span><span class="mi">0</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">ribosome_30S_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="n">ribosome30SCounts</span><span class="p">,</span> <span class="n">constraint1_ribosome30SCounts</span><span class="p">),</span>
        <span class="n">constraint2_ribosome30SCounts</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">ribosome_50S_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="n">ribosome50SCounts</span><span class="p">,</span> <span class="n">constraint1_ribosome50SCounts</span><span class="p">),</span>
        <span class="n">constraint2_ribosome50SCounts</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="setRNAPCountsConstrainedByPhysiology">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.setRNAPCountsConstrainedByPhysiology">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">setRNAPCountsConstrainedByPhysiology</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span>
    <span class="n">bulkContainer</span><span class="p">,</span>
    <span class="n">doubling_time</span><span class="p">,</span>
    <span class="n">avgCellDryMassInit</span><span class="p">,</span>
    <span class="n">variable_elongation_transcription</span><span class="p">,</span>
    <span class="n">Km</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set counts of RNA polymerase based on two constraints:</span>
<span class="sd">    (1) Number of RNAP subunits required to maintain steady state of mRNAs</span>
<span class="sd">    (2) Expected RNAP subunit counts based on (mRNA) distribution recorded in</span>
<span class="sd">            bulkContainer</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - bulkContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">            for count of all bulk molecules</span>
<span class="sd">    - doubling_time (float with units of time) - doubling time given the condition</span>
<span class="sd">    - avgCellDryMassInit (float with units of mass) - expected initial dry cell mass</span>
<span class="sd">    - Km (array of floats with units of mol/volume) - Km for each RNA associated</span>
<span class="sd">    with RNases</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - bulkContainer (np.ndarray object) - the counts of RNA polymerase</span>
<span class="sd">            subunits are set according to Constraint 1</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Constraint 2 is not being used -- see final line of this function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># -- CONSTRAINT 1: Expected RNA distribution doubling -- #</span>
    <span class="n">rnaLengths</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;counts_ACGU&quot;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="n">rnaLossRate</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">rna_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">Km</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># RNA loss rate is in units of counts/time, and computed by summing the</span>
        <span class="c1"># contributions of degradation and dilution.</span>
        <span class="n">rnaLossRate</span> <span class="o">=</span> <span class="n">netLossRateFromDilutionAndDegradationRNALinear</span><span class="p">(</span>
            <span class="n">doubling_time</span><span class="p">,</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;deg_rate&quot;</span><span class="p">],</span>
            <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">rna_idx</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Get constants to compute countsToMolar factor</span>
        <span class="n">cellDensity</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">cell_density</span>
        <span class="n">cellVolume</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">avgCellDryMassInit</span> <span class="o">/</span> <span class="n">cellDensity</span> <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">cell_dry_mass_fraction</span>
        <span class="p">)</span>
        <span class="n">countsToMolar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span> <span class="o">*</span> <span class="n">cellVolume</span><span class="p">)</span>

        <span class="c1"># Gompute input arguments for netLossRateFromDilutionAndDegradationRNA()</span>
        <span class="n">rnaConc</span> <span class="o">=</span> <span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">rna_idx</span><span class="p">)</span>
        <span class="n">endoRNase_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">endoRNase_ids</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">endoRNaseConc</span> <span class="o">=</span> <span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">endoRNase_idx</span><span class="p">)</span>
        <span class="n">kcatEndoRNase</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">kcats</span>
        <span class="n">totalEndoRnaseCapacity</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">endoRNaseConc</span> <span class="o">*</span> <span class="n">kcatEndoRNase</span><span class="p">)</span>

        <span class="c1"># RNA loss rate is in units of counts/time, and computed by accounting</span>
        <span class="c1"># for the competitive inhibition of RNase by other RNA targets.</span>
        <span class="n">rnaLossRate</span> <span class="o">=</span> <span class="n">netLossRateFromDilutionAndDegradationRNA</span><span class="p">(</span>
            <span class="n">doubling_time</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">countsToMolar</span><span class="p">)</span> <span class="o">*</span> <span class="n">totalEndoRnaseCapacity</span><span class="p">,</span>
            <span class="n">Km</span><span class="p">,</span>
            <span class="n">rnaConc</span><span class="p">,</span>
            <span class="n">countsToMolar</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Compute number of RNA polymerases required to maintain steady state of mRNA</span>
    <span class="n">elongation_rates</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">make_elongation_rates</span><span class="p">(</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">growth_rate_parameters</span><span class="o">.</span><span class="n">get_rnap_elongation_rate</span><span class="p">(</span>
            <span class="n">doubling_time</span>
        <span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">nt</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span><span class="p">),</span>
        <span class="mi">1</span><span class="p">,</span>
        <span class="n">variable_elongation_transcription</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">nActiveRnapNeeded</span> <span class="o">=</span> <span class="n">calculateMinPolymerizingEnzymeByProductDistributionRNA</span><span class="p">(</span>
        <span class="n">rnaLengths</span><span class="p">,</span> <span class="n">elongation_rates</span><span class="p">,</span> <span class="n">rnaLossRate</span>
    <span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">nt</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>

    <span class="n">nRnapsNeeded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
        <span class="n">nActiveRnapNeeded</span>
        <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">growth_rate_parameters</span><span class="o">.</span><span class="n">get_fraction_active_rnap</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Convert nRnapsNeeded to the number of RNA polymerase subunits required</span>
    <span class="n">rnapIds</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">get_monomers</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_ids</span><span class="o">.</span><span class="n">full_RNAP</span>
    <span class="p">)[</span><span class="s2">&quot;subunitIds&quot;</span><span class="p">]</span>
    <span class="n">rnapStoich</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">get_monomers</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_ids</span><span class="o">.</span><span class="n">full_RNAP</span>
    <span class="p">)[</span><span class="s2">&quot;subunitStoich&quot;</span><span class="p">]</span>
    <span class="n">minRnapSubunitCounts</span> <span class="o">=</span> <span class="n">nRnapsNeeded</span> <span class="o">*</span> <span class="n">rnapStoich</span>

    <span class="c1"># -- CONSTRAINT 2: Expected RNAP subunit counts based on distribution -- #</span>
    <span class="n">rnap_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">rnapIds</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">rnapCounts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">rnap_idx</span><span class="p">)</span>

    <span class="c1">## -- SET RNAP COUNTS TO MAXIMUM CONSTRAINTS -- #</span>
    <span class="n">constraint_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="s2">&quot;Current level OK&quot;</span><span class="p">,</span> <span class="s2">&quot;Insufficient to double RNA distribution&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">rnapLims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">rnapCounts</span> <span class="o">/</span> <span class="n">rnapStoich</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="p">(</span><span class="n">minRnapSubunitCounts</span> <span class="o">/</span> <span class="n">rnapStoich</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;rnap limit: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">constraint_names</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rnapLims</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="n">rnapLims</span><span class="p">)[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rnap actual count: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">rnapCounts</span> <span class="o">/</span> <span class="n">rnapStoich</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()))</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;rnap counts set to: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">rnapLims</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rnapLims</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="n">rnapLims</span><span class="p">)[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">minRnapSubunitCounts</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;RNAP protein counts must be positive.&quot;</span><span class="p">)</span>

    <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">rnap_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">minRnapSubunitCounts</span></div>



<div class="viewcode-block" id="fitExpression">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.fitExpression">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fitExpression</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">,</span> <span class="n">avgCellDryMassInit</span><span class="p">,</span> <span class="n">Km</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines expression and synthesis probabilities for RNA molecules to fit</span>
<span class="sd">    protein levels and RNA degradation rates. Assumes a steady state analysis</span>
<span class="sd">    where the RNA synthesis probability will be the same as the degradation rate.</span>
<span class="sd">    If no Km is given, then RNA degradation is assumed to be linear otherwise</span>
<span class="sd">    degradation is calculated based on saturation with RNases.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - bulkContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">            for expected count based on expression of all bulk molecules</span>
<span class="sd">    - doubling_time (float with units of time) - doubling time</span>
<span class="sd">    - avgCellDryMassInit (float with units of mass) - expected initial dry cell mass</span>
<span class="sd">    - Km (array of floats with units of mol/volume) - Km for each RNA associated</span>
<span class="sd">    with RNases</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - bulkContainer counts of RNA and proteins</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - expression (array of floats) - adjusted expression for each RNA,</span>
<span class="sd">    normalized to 1</span>
<span class="sd">    - synth_prob (array of floats) - synthesis probability for each RNA which</span>
<span class="sd">    accounts for expression and degradation rate, normalized to 1</span>
<span class="sd">    - fit_cistron_expression (array of floats) - target expression levels of</span>
<span class="sd">    each cistron (gene) used to calculate RNA expression levels</span>
<span class="sd">    - cistron_expression_res (array of floats) - the residuals of the NNLS</span>
<span class="sd">    problem solved to calculate RNA expression levels</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - TODO - sets bulkContainer counts and returns values - change to only return values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load required parameters</span>
    <span class="n">transcription</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span>
    <span class="n">translation</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span>
    <span class="n">translation_efficiencies_by_protein</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span>
        <span class="n">translation</span><span class="o">.</span><span class="n">translation_efficiencies_by_monomer</span>
    <span class="p">)</span>
    <span class="n">degradation_rates_protein</span> <span class="o">=</span> <span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;deg_rate&quot;</span><span class="p">]</span>
    <span class="n">net_loss_rate_protein</span> <span class="o">=</span> <span class="n">netLossRateFromDilutionAndDegradationProtein</span><span class="p">(</span>
        <span class="n">doubling_time</span><span class="p">,</span> <span class="n">degradation_rates_protein</span>
    <span class="p">)</span>
    <span class="n">avg_cell_fraction_mass</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">get_component_masses</span><span class="p">(</span><span class="n">doubling_time</span><span class="p">)</span>
    <span class="n">total_mass_RNA</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">avg_cell_fraction_mass</span><span class="p">[</span><span class="s2">&quot;rnaMass&quot;</span><span class="p">]</span>
        <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_to_initial_cell_conversion_factor</span>
    <span class="p">)</span>
    <span class="n">cistron_tu_mapping_matrix</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">cistron_tu_mapping_matrix</span>

    <span class="c1"># Calculate current expression fraction of mRNA transcription units</span>
    <span class="n">rna_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">RNA_counts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">rna_idx</span><span class="p">)</span>
    <span class="n">rna_expression_container</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">RNA_counts</span><span class="p">)</span>

    <span class="n">mRNA_tu_expression_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">rna_expression_container</span><span class="p">[</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_mRNA&quot;</span><span class="p">]]</span>
    <span class="p">)</span>

    <span class="c1"># Calculate current expression levels of each cistron given the RNA</span>
    <span class="c1"># expression levels</span>
    <span class="n">fit_cistron_expression</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">cistron_tu_mapping_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">RNA_counts</span><span class="p">))</span>
    <span class="n">mRNA_cistron_expression_frac</span> <span class="o">=</span> <span class="n">fit_cistron_expression</span><span class="p">[</span>
        <span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;is_mRNA&quot;</span><span class="p">]</span>
    <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Calculate required mRNA expression from monomer counts</span>
    <span class="n">protein_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">counts_protein</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">protein_idx</span><span class="p">)</span>
    <span class="n">mRNA_cistron_distribution_per_protein</span> <span class="o">=</span> <span class="n">mRNADistributionFromProtein</span><span class="p">(</span>
        <span class="n">normalize</span><span class="p">(</span><span class="n">counts_protein</span><span class="p">),</span>
        <span class="n">translation_efficiencies_by_protein</span><span class="p">,</span>
        <span class="n">net_loss_rate_protein</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">mRNA_cistron_distribution</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">relation</span><span class="o">.</span><span class="n">monomer_to_mRNA_cistron_mapping</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
            <span class="n">mRNA_cistron_distribution_per_protein</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Replace mRNA cistron expression with values calculated from monomer counts</span>
    <span class="n">fit_cistron_expression</span><span class="p">[</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;is_mRNA&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">mRNA_cistron_expression_frac</span> <span class="o">*</span> <span class="n">mRNA_cistron_distribution</span>
    <span class="p">)</span>

    <span class="c1"># Use least squares to calculate expression of transcription units required</span>
    <span class="c1"># to generate the given cistron expression levels and the residuals for</span>
    <span class="c1"># the expression of each cistron</span>
    <span class="n">fit_tu_expression</span><span class="p">,</span> <span class="n">cistron_expression_res</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">fit_rna_expression</span><span class="p">(</span>
        <span class="n">fit_cistron_expression</span>
    <span class="p">)</span>
    <span class="n">fit_mRNA_tu_expression</span> <span class="o">=</span> <span class="n">fit_tu_expression</span><span class="p">[</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_mRNA&quot;</span><span class="p">]]</span>

    <span class="n">rna_expression_container</span><span class="p">[</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_mRNA&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">mRNA_tu_expression_frac</span> <span class="o">*</span> <span class="n">normalize</span><span class="p">(</span><span class="n">fit_mRNA_tu_expression</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">expression</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">rna_expression_container</span><span class="p">)</span>

    <span class="c1"># Set number of RNAs based on expression we just set</span>
    <span class="n">mws</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;mw&quot;</span><span class="p">]</span>

    <span class="c1"># Use only the rRNA/tRNA mass for rRNA/tRNA transcription units</span>
    <span class="n">is_rRNA</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_rRNA&quot;</span><span class="p">]</span>
    <span class="n">is_tRNA</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;is_tRNA&quot;</span><span class="p">]</span>
    <span class="n">mws</span><span class="p">[</span><span class="n">is_rRNA</span><span class="p">]</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;rRNA_mw&quot;</span><span class="p">][</span><span class="n">is_rRNA</span><span class="p">]</span>
    <span class="n">mws</span><span class="p">[</span><span class="n">is_tRNA</span><span class="p">]</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;tRNA_mw&quot;</span><span class="p">][</span><span class="n">is_tRNA</span><span class="p">]</span>

    <span class="n">n_rnas</span> <span class="o">=</span> <span class="n">totalCountFromMassesAndRatios</span><span class="p">(</span>
        <span class="n">total_mass_RNA</span><span class="p">,</span> <span class="n">mws</span> <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span><span class="p">,</span> <span class="n">expression</span>
    <span class="p">)</span>
    <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">rna_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_rnas</span> <span class="o">*</span> <span class="n">expression</span>

    <span class="k">if</span> <span class="n">Km</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rnaLossRate</span> <span class="o">=</span> <span class="n">netLossRateFromDilutionAndDegradationRNALinear</span><span class="p">(</span>
            <span class="n">doubling_time</span><span class="p">,</span>
            <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;deg_rate&quot;</span><span class="p">],</span>
            <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">rna_idx</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Get constants to compute countsToMolar factor</span>
        <span class="n">cellDensity</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">cell_density</span>
        <span class="n">dryMassFraction</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">cell_dry_mass_fraction</span>
        <span class="n">cellVolume</span> <span class="o">=</span> <span class="n">avgCellDryMassInit</span> <span class="o">/</span> <span class="n">cellDensity</span> <span class="o">/</span> <span class="n">dryMassFraction</span>
        <span class="n">countsToMolar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span> <span class="o">*</span> <span class="n">cellVolume</span><span class="p">)</span>

        <span class="n">endoRNase_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">endoRNase_ids</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">endoRNaseConc</span> <span class="o">=</span> <span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">endoRNase_idx</span><span class="p">)</span>
        <span class="n">kcatEndoRNase</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">kcats</span>
        <span class="n">totalEndoRnaseCapacity</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">endoRNaseConc</span> <span class="o">*</span> <span class="n">kcatEndoRNase</span><span class="p">)</span>

        <span class="n">rnaLossRate</span> <span class="o">=</span> <span class="n">netLossRateFromDilutionAndDegradationRNA</span><span class="p">(</span>
            <span class="n">doubling_time</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">countsToMolar</span><span class="p">)</span> <span class="o">*</span> <span class="n">totalEndoRnaseCapacity</span><span class="p">,</span>
            <span class="n">Km</span><span class="p">,</span>
            <span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">rna_idx</span><span class="p">),</span>
            <span class="n">countsToMolar</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">synth_prob</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">rnaLossRate</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">min</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">expression</span><span class="p">,</span> <span class="n">synth_prob</span><span class="p">,</span> <span class="n">fit_cistron_expression</span><span class="p">,</span> <span class="n">cistron_expression_res</span></div>



<div class="viewcode-block" id="fitMaintenanceCosts">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.fitMaintenanceCosts">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fitMaintenanceCosts</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits the growth-associated maintenance (GAM) cost associated with metabolism.</span>

<span class="sd">    The energetic costs associated with growth have been estimated utilizing flux-balance analysis</span>
<span class="sd">    and are used with FBA to obtain accurate growth predictions.  In the whole-cell model, some of</span>
<span class="sd">    these costs are explicitly associated with the energetic costs of translation, a biomass</span>
<span class="sd">    assembly process.  Consequently we must estimate the amount of energy utilized by translation</span>
<span class="sd">    per unit of biomass (i.e. dry mass) produced, and subtract that quantity from reported GAM to</span>
<span class="sd">    acquire the modified GAM that we use in the metabolic submodel.</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - amino acid counts associated with protein monomers</span>
<span class="sd">    - average initial dry mass</span>
<span class="sd">    - energetic (GTP) cost of translation (per amino acid polymerized)</span>
<span class="sd">    - observed growth-associated maintenance (GAM)</span>
<span class="sd">    In dimensions of ATP or ATP equivalents consumed per biomass</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - the &quot;dark&quot; ATP, i.e. the modified GAM</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    As more non-metabolic submodels account for energetic costs, this function should be extended</span>
<span class="sd">    to subtract those costs off the observed GAM.</span>

<span class="sd">    There also exists, in contrast, non-growth-associated-maintenance (NGAM), which is relative to</span>
<span class="sd">    total biomass rather than the biomass accumulation rate.  As the name would imply, this</span>
<span class="sd">    accounts for the energetic costs of maintaining the existing biomass.  It is also accounted for</span>
<span class="sd">    in the metabolic submodel.</span>

<span class="sd">    TODO (John): Rewrite as a true function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">aaCounts</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;aa_counts&quot;</span><span class="p">]</span>
    <span class="n">protein_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">proteinCounts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">protein_idx</span><span class="p">)</span>
    <span class="n">nAvogadro</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span>
    <span class="n">avgCellDryMassInit</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_dry_mass_init</span>
    <span class="n">gtpPerTranslation</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">gtp_per_translation</span>
    <span class="n">atp_per_charge</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">2</span>  <span class="c1"># ATP -&gt; AMP is explicitly used in charging reactions so can remove from GAM</span>
    <span class="p">)</span>

    <span class="c1"># GTPs used for translation (recycled, not incorporated into biomass)</span>
    <span class="n">aaMmolPerGDCW</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">aaCounts</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">proteinCounts</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">21</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">aa</span> <span class="o">*</span> <span class="n">nAvogadro</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">avgCellDryMassInit</span><span class="p">))</span>

    <span class="n">aasUsedOverCellCycle</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">aaMmolPerGDCW</span><span class="p">)</span>
    <span class="n">explicit_mmol_maintenance_per_gdcw</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">atp_per_charge</span> <span class="o">+</span> <span class="n">gtpPerTranslation</span>
    <span class="p">)</span> <span class="o">*</span> <span class="n">aasUsedOverCellCycle</span>

    <span class="n">darkATP</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># This has everything we can&#39;t account for</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">growth_associated_maintenance</span>
        <span class="o">-</span> <span class="n">explicit_mmol_maintenance_per_gdcw</span>
    <span class="p">)</span>

    <span class="c1"># We do not want to create energy with growth by having a negative darkATP</span>
    <span class="c1"># value. GAM measurements have some error so it&#39;s possible explicit</span>
    <span class="c1"># accounting could be more accurate or the GAM value used is too low which</span>
    <span class="c1"># would lead to a negative value. Easy fix is setting darkATP = 0 if this</span>
    <span class="c1"># error is raised.</span>
    <span class="k">if</span> <span class="n">darkATP</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;GAM has been adjusted too low. Explicit energy accounting should not exceed GAM.&quot;</span>
            <span class="s2">&quot; Consider setting darkATP to 0 if energy corrections are accurate.&quot;</span>
        <span class="p">)</span>

    <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">darkATP</span> <span class="o">=</span> <span class="n">darkATP</span></div>



<div class="viewcode-block" id="calculateBulkDistributions">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.calculateBulkDistributions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculateBulkDistributions</span><span class="p">(</span>
    <span class="n">sim_data</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">concDict</span><span class="p">,</span> <span class="n">avgCellDryMassInit</span><span class="p">,</span> <span class="n">doubling_time</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds a distribution of copy numbers for macromolecules. While RNA and protein</span>
<span class="sd">    expression can be approximated using well-described statistical	distributions,</span>
<span class="sd">    complexes require absolute copy numbers. To get these distributions, this</span>
<span class="sd">    function instantiates many cells with a reduced set of molecules, forms complexes,</span>
<span class="sd">    and iterates through equilibrium and two-component system processes until</span>
<span class="sd">    metabolite counts reach a steady-state. It then computes the resulting</span>
<span class="sd">    statistical distributions.</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - N_SEEDS (int) - the number of instantiated cells</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - expression (array of floats) - expression for each RNA, normalized to 1</span>
<span class="sd">    - concDict {metabolite (str): concentration (float with units of mol/volume)} -</span>
<span class="sd">    dictionary for concentrations of each metabolite with location tag</span>
<span class="sd">    - avgCellDryMassInit (float with units of mass) - initial dry cell mass</span>
<span class="sd">    - doubling_time (float with units of time) - doubling time for condition</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - bulkAverageContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">            for the mean of the counts of all bulk molecules</span>
<span class="sd">    - bulkDeviationContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">            for the standard deviation of the counts of all bulk molecules</span>
<span class="sd">    - proteinMonomerAverageContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">            for the mean of the counts of all protein monomers</span>
<span class="sd">    - proteinMonomerDeviationContainer (np.ndarray object) - Two columns: &#39;id&#39; for name and &#39;count&#39;</span>
<span class="sd">            for the standard deviation of the counts of all protein monomers</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ids</span>
    <span class="n">totalCount_RNA</span><span class="p">,</span> <span class="n">ids_rnas</span><span class="p">,</span> <span class="n">distribution_RNA</span> <span class="o">=</span> <span class="n">totalCountIdDistributionRNA</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">doubling_time</span>
    <span class="p">)</span>
    <span class="n">totalCount_protein</span><span class="p">,</span> <span class="n">ids_protein</span><span class="p">,</span> <span class="n">distribution_protein</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">totalCountIdDistributionProtein</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">doubling_time</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">ids_complex</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">molecule_names</span>
    <span class="n">ids_equilibrium</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">molecule_names</span>
    <span class="n">ids_twoComponentSystem</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">two_component_system</span><span class="o">.</span><span class="n">molecule_names</span>
    <span class="n">ids_metabolites</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">concDict</span><span class="p">)</span>
    <span class="n">conc_metabolites</span> <span class="o">=</span> <span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">concDict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ids_metabolites</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">allMoleculesIDs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">ids_rnas</span><span class="p">)</span>
        <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">ids_protein</span><span class="p">)</span>
        <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">ids_complex</span><span class="p">)</span>
        <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">ids_equilibrium</span><span class="p">)</span>
        <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">ids_twoComponentSystem</span><span class="p">)</span>
        <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">ids_metabolites</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Data for complexation</span>
    <span class="n">complexationStoichMatrix</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">stoich_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span>
    <span class="p">)</span>
    <span class="c1"># Data for equilibrium binding</span>
    <span class="c1"># equilibriumDerivatives = sim_data.process.equilibrium.derivatives</span>
    <span class="c1"># equilibriumDerivativesJacobian = sim_data.process.equilibrium.derivativesJacobian</span>

    <span class="c1"># Data for metabolites</span>
    <span class="n">cellDensity</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">cell_density</span>
    <span class="n">cellVolume</span> <span class="o">=</span> <span class="n">avgCellDryMassInit</span> <span class="o">/</span> <span class="n">cellDensity</span> <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">cell_dry_mass_fraction</span>

    <span class="c1"># Construct bulk container</span>

    <span class="c1"># We want to know something about the distribution of the copy numbers of</span>
    <span class="c1"># macromolecules in the cell.  While RNA and protein expression can be</span>
    <span class="c1"># approximated using well-described statistical distributions, we need</span>
    <span class="c1"># absolute copy numbers to form complexes.  To get a distribution, we must</span>
    <span class="c1"># instantiate many cells, form complexes, and finally compute the</span>
    <span class="c1"># statistics we will use in the fitting operations.</span>

    <span class="n">bulk_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">internal_state</span><span class="o">.</span><span class="n">bulk_molecules</span><span class="o">.</span><span class="n">bulk_data</span><span class="o">.</span><span class="n">struct_array</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">bulkContainer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">mol_data</span> <span class="k">for</span> <span class="n">mol_data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bulk_ids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bulk_ids</span><span class="p">)))],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)],</span>
    <span class="p">)</span>

    <span class="n">rna_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ids_rnas</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">protein_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ids_protein</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">complexation_molecules_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ids_complex</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">equilibrium_molecules_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ids_equilibrium</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">two_component_system_molecules_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">ids_twoComponentSystem</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">metabolites_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">ids_metabolites</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">all_molecules_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">allMoleculesIDs</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>

    <span class="n">allMoleculeCounts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N_SEEDS</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">allMoleculesIDs</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">proteinMonomerCounts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N_SEEDS</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids_protein</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bulk distribution seed:&quot;</span><span class="p">)</span>

    <span class="c1"># Instantiate cells to find average copy numbers of macromolecules</span>
    <span class="k">for</span> <span class="n">seed</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_SEEDS</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;seed = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seed</span><span class="p">))</span>

        <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">all_molecules_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">rna_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">totalCount_RNA</span> <span class="o">*</span> <span class="n">distribution_RNA</span>

        <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">protein_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">totalCount_protein</span> <span class="o">*</span> <span class="n">distribution_protein</span>

        <span class="n">proteinMonomerCounts</span><span class="p">[</span><span class="n">seed</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">protein_idx</span><span class="p">)</span>
        <span class="n">complexationMoleculeCounts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">complexation_molecules_idx</span><span class="p">)</span>

        <span class="c1"># Form complexes</span>
        <span class="n">time_step</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">31</span>  <span class="c1"># don&#39;t stop until all complexes are formed.</span>
        <span class="n">complexation_rates</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">complexation</span><span class="o">.</span><span class="n">rates</span>
        <span class="n">system</span> <span class="o">=</span> <span class="n">StochasticSystem</span><span class="p">(</span><span class="n">complexationStoichMatrix</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">complexation_result</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span>
            <span class="n">time_step</span><span class="p">,</span> <span class="n">complexationMoleculeCounts</span><span class="p">,</span> <span class="n">complexation_rates</span>
        <span class="p">)</span>

        <span class="n">updatedCompMoleculeCounts</span> <span class="o">=</span> <span class="n">complexation_result</span><span class="p">[</span><span class="s2">&quot;outcome&quot;</span><span class="p">]</span>
        <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">complexation_molecules_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">updatedCompMoleculeCounts</span>

        <span class="n">metDiffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">metabolites_idx</span><span class="p">))</span>
        <span class="n">nIters</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Iterate processes until metabolites converge to a steady-state</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">metDiffs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">metCounts</span> <span class="o">=</span> <span class="n">conc_metabolites</span> <span class="o">*</span> <span class="n">cellVolume</span> <span class="o">*</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span>
            <span class="n">metCounts</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
            <span class="n">metCounts</span><span class="o">.</span><span class="n">checkNoUnit</span><span class="p">()</span>
            <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">metabolites_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">metCounts</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>

            <span class="c1"># Find reaction fluxes from equilibrium process</span>
            <span class="c1"># Do not use jit to avoid compiling time (especially when running</span>
            <span class="c1"># in parallel since sim_data needs to be pickled and reconstructed</span>
            <span class="c1"># each time)</span>
            <span class="n">rxnFluxes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">fluxes_and_molecules_to_SS</span><span class="p">(</span>
                <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">equilibrium_molecules_idx</span><span class="p">],</span>
                <span class="n">cellVolume</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">),</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">mol</span><span class="p">),</span>
                <span class="n">random_state</span><span class="p">,</span>
                <span class="n">jit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">equilibrium_molecules_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">stoich_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
                <span class="n">rxnFluxes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">equilibrium_molecules_idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Find changes from two component system</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">moleculeCountChanges</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">two_component_system</span><span class="o">.</span><span class="n">molecules_to_ss</span><span class="p">(</span>
                    <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">two_component_system_molecules_idx</span><span class="p">],</span>
                    <span class="n">cellVolume</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">),</span>
                    <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">mmol</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">two_component_system_molecules_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">moleculeCountChanges</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">metDiffs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">metabolites_idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">metCounts</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">()</span>
            <span class="p">)</span>

            <span class="n">nIters</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">nIters</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Equilibrium reactions are not converging!&quot;</span><span class="p">)</span>

        <span class="n">allMoleculeCounts</span><span class="p">[</span><span class="n">seed</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">all_molecules_idx</span><span class="p">)</span>

    <span class="c1"># Update counts in bulk objects container</span>
    <span class="n">bulkAverageContainer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">mol_data</span> <span class="k">for</span> <span class="n">mol_data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bulk_ids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bulk_ids</span><span class="p">)))],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="n">bulkDeviationContainer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">mol_data</span> <span class="k">for</span> <span class="n">mol_data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bulk_ids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bulk_ids</span><span class="p">)))],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">bulk_ids</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="n">monomer_ids</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">translation</span><span class="o">.</span><span class="n">monomer_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">proteinMonomerAverageContainer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">mol_data</span> <span class="k">for</span> <span class="n">mol_data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">monomer_ids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">monomer_ids</span><span class="p">)))],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">monomer_ids</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="n">proteinMonomerDeviationContainer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">mol_data</span> <span class="k">for</span> <span class="n">mol_data</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">monomer_ids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">monomer_ids</span><span class="p">)))],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">monomer_ids</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)],</span>
    <span class="p">)</span>

    <span class="n">bulkAverageContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">all_molecules_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">allMoleculeCounts</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">bulkDeviationContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">all_molecules_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">allMoleculeCounts</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">proteinMonomerAverageContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proteinMonomerCounts</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">proteinMonomerDeviationContainer</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proteinMonomerCounts</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">bulkAverageContainer</span><span class="p">,</span>
        <span class="n">bulkDeviationContainer</span><span class="p">,</span>
        <span class="n">proteinMonomerAverageContainer</span><span class="p">,</span>
        <span class="n">proteinMonomerDeviationContainer</span><span class="p">,</span>
    <span class="p">)</span></div>



<span class="c1"># Math functions</span>


<div class="viewcode-block" id="totalCountFromMassesAndRatios">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.totalCountFromMassesAndRatios">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">totalCountFromMassesAndRatios</span><span class="p">(</span><span class="n">totalMass</span><span class="p">,</span> <span class="n">individualMasses</span><span class="p">,</span> <span class="n">distribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to determine the expected total counts for a group of molecules</span>
<span class="sd">    in order to achieve a total mass with a given distribution of individual</span>
<span class="sd">    molecules.</span>

<span class="sd">    Math:</span>
<span class="sd">            Total mass = dot(mass, count)</span>

<span class="sd">            Fraction of i:</span>
<span class="sd">            f = count / Total counts</span>

<span class="sd">            Substituting:</span>
<span class="sd">            Total mass = dot(mass, f * Total counts)</span>
<span class="sd">            Total mass = Total counts * dot(mass, f)</span>

<span class="sd">            Total counts = Total mass / dot(mass, f)</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - totalMass (float with mass units): total mass of the group of molecules</span>
<span class="sd">    - individualMasses (array of floats with mass units): mass for individual</span>
<span class="sd">    molecules in the group</span>
<span class="sd">    - distribution (array of floats): distribution of individual molecules,</span>
<span class="sd">    normalized to 1</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - counts (float): total counts (does not need to be a whole number)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distribution</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">individualMasses</span><span class="p">,</span> <span class="n">distribution</span><span class="p">)</span> <span class="o">*</span> <span class="n">totalMass</span>
    <span class="k">return</span> <span class="n">units</span><span class="o">.</span><span class="n">strip_empty_units</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span></div>



<div class="viewcode-block" id="proteinDistributionFrommRNA">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.proteinDistributionFrommRNA">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">proteinDistributionFrommRNA</span><span class="p">(</span>
    <span class="n">distribution_mRNA</span><span class="p">,</span> <span class="n">translation_efficiencies</span><span class="p">,</span> <span class="n">netLossRate</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    dP_i / dt = k * M_i * e_i - P_i * Loss_i</span>

<span class="sd">    At steady state:</span>
<span class="sd">    P_i = k * M_i * e_i / Loss_i</span>

<span class="sd">    Fraction of mRNA for ith gene is defined as:</span>
<span class="sd">    f_i = M_i / M_total</span>

<span class="sd">    Substituting in:</span>
<span class="sd">    P_i = k * f_i * e_i * M_total / Loss_i</span>

<span class="sd">    Normalizing P_i by summing over all i cancels out k and M_total</span>
<span class="sd">    assuming constant translation rate.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - distribution_mRNA (array of floats) - distribution for each mRNA,</span>
<span class="sd">    normalized to 1</span>
<span class="sd">    - translation_efficiencies (array of floats) - translational efficiency for each mRNA,</span>
<span class="sd">    normalized to 1</span>
<span class="sd">    - netLossRate (array of floats with units of 1/time) - rate of loss for each protein</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    - array of floats for the distribution of each protein, normalized to 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distribution_mRNA</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">translation_efficiencies</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">distributionUnnormed</span> <span class="o">=</span> <span class="p">(</span>
        <span class="mi">1</span> <span class="o">/</span> <span class="n">netLossRate</span> <span class="o">*</span> <span class="n">distribution_mRNA</span> <span class="o">*</span> <span class="n">translation_efficiencies</span>
    <span class="p">)</span>
    <span class="n">distributionNormed</span> <span class="o">=</span> <span class="n">distributionUnnormed</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distributionUnnormed</span><span class="p">)</span>
    <span class="n">distributionNormed</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
    <span class="n">distributionNormed</span><span class="o">.</span><span class="n">checkNoUnit</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">distributionNormed</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span></div>



<div class="viewcode-block" id="mRNADistributionFromProtein">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.mRNADistributionFromProtein">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mRNADistributionFromProtein</span><span class="p">(</span>
    <span class="n">distribution_protein</span><span class="p">,</span> <span class="n">translation_efficiencies</span><span class="p">,</span> <span class="n">netLossRate</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    dP_i / dt = k * M_i * e_i - P_i * Loss_i</span>

<span class="sd">    At steady state:</span>
<span class="sd">    M_i = Loss_i * P_i / (k * e_i)</span>

<span class="sd">    Fraction of protein for ith gene is defined as:</span>
<span class="sd">    f_i = P_i / P_total</span>

<span class="sd">    Substituting in:</span>
<span class="sd">    M_i = Loss_i * f_i * P_total / (k * e_i)</span>

<span class="sd">    Normalizing M_i by summing over all i cancels out k and P_total</span>
<span class="sd">    assuming a constant translation rate.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - distribution_protein (array of floats) - distribution for each protein,</span>
<span class="sd">    normalized to 1</span>
<span class="sd">    - translation_efficiencies (array of floats) - translational efficiency for each mRNA,</span>
<span class="sd">    normalized to 1</span>
<span class="sd">    - netLossRate (array of floats with units of 1/time) - rate of loss for each protein</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    - array of floats for the distribution of each mRNA, normalized to 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distribution_protein</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">distributionUnnormed</span> <span class="o">=</span> <span class="n">netLossRate</span> <span class="o">*</span> <span class="n">distribution_protein</span> <span class="o">/</span> <span class="n">translation_efficiencies</span>
    <span class="n">distributionNormed</span> <span class="o">=</span> <span class="n">distributionUnnormed</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distributionUnnormed</span><span class="p">)</span>
    <span class="n">distributionNormed</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
    <span class="n">distributionNormed</span><span class="o">.</span><span class="n">checkNoUnit</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">distributionNormed</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span></div>



<div class="viewcode-block" id="calculateMinPolymerizingEnzymeByProductDistribution">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.calculateMinPolymerizingEnzymeByProductDistribution">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculateMinPolymerizingEnzymeByProductDistribution</span><span class="p">(</span>
    <span class="n">productLengths</span><span class="p">,</span> <span class="n">elongationRates</span><span class="p">,</span> <span class="n">netLossRate</span><span class="p">,</span> <span class="n">productCounts</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the number of ribosomes required to maintain steady state.</span>

<span class="sd">    dP/dt = production rate - loss rate</span>
<span class="sd">    dP/dt = e_r * (1/L) * R - (k_loss * P)</span>

<span class="sd">    At steady state: dP/dt = 0</span>
<span class="sd">    R = sum over i ((L_i / e_r) * k_loss_i * P_i)</span>

<span class="sd">    Multiplying both sides by volume gives an equation in terms of counts.</span>

<span class="sd">    P = protein concentration</span>
<span class="sd">    e_r = polypeptide elongation rate per ribosome</span>
<span class="sd">    L = protein length</span>
<span class="sd">    R = ribosome concentration</span>
<span class="sd">    k_loss = net protein loss rate</span>
<span class="sd">    i = ith protein</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - productLengths (array of ints with units of amino_acids) - L, protein lengths</span>
<span class="sd">    - elongationRates (array of ints with units of amino_acid/time) e_r, polypeptide elongation rate</span>
<span class="sd">    - netLossRate (array of floats with units of 1/time) - k_loss, protein loss rate</span>
<span class="sd">    - productCounts (array of floats) - P, protein counts</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - float with dimensionless units for the number of ribosomes required to</span>
<span class="sd">    maintain steady state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nPolymerizingEnzymeNeeded</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">productLengths</span> <span class="o">/</span> <span class="n">elongationRates</span> <span class="o">*</span> <span class="n">netLossRate</span> <span class="o">*</span> <span class="n">productCounts</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">nPolymerizingEnzymeNeeded</span></div>



<div class="viewcode-block" id="calculateMinPolymerizingEnzymeByProductDistributionRNA">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.calculateMinPolymerizingEnzymeByProductDistributionRNA">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculateMinPolymerizingEnzymeByProductDistributionRNA</span><span class="p">(</span>
    <span class="n">productLengths</span><span class="p">,</span> <span class="n">elongationRates</span><span class="p">,</span> <span class="n">netLossRate</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the number of RNA polymerases required to maintain steady state of mRNA.</span>

<span class="sd">    dR/dt = production rate - loss rate</span>
<span class="sd">    dR/dt = e_r * (1/L) * RNAp - k_loss</span>

<span class="sd">    At steady state: dR/dt = 0</span>
<span class="sd">    RNAp = sum over i ((L_i / e_r) * k_loss_i)</span>

<span class="sd">    Multiplying both sides by volume gives an equation in terms of counts.</span>

<span class="sd">    R = mRNA transcript concentration</span>
<span class="sd">    e_r = transcript elongation rate per RNAp</span>
<span class="sd">    L = transcript length</span>
<span class="sd">    RNAp = RNAp concentration</span>
<span class="sd">    k_loss = net transcript loss rate (unit: concentration / time)</span>
<span class="sd">    i = ith transcript</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - productLengths (array of ints with units of nucleotides) - L, transcript lengths</span>
<span class="sd">    - elongationRates (array of ints with units of nucleotide/time) - e_r, transcript elongation rate</span>
<span class="sd">    - netLossRate (array of floats with units of 1/time) - k_loss, transcript loss rate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    - float with dimensionless units for the number of RNA polymerases required to</span>
<span class="sd">    maintain steady state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nPolymerizingEnzymeNeeded</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">productLengths</span> <span class="o">/</span> <span class="n">elongationRates</span> <span class="o">*</span> <span class="n">netLossRate</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">nPolymerizingEnzymeNeeded</span></div>



<div class="viewcode-block" id="netLossRateFromDilutionAndDegradationProtein">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.netLossRateFromDilutionAndDegradationProtein">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">netLossRateFromDilutionAndDegradationProtein</span><span class="p">(</span><span class="n">doublingTime</span><span class="p">,</span> <span class="n">degradationRates</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute total loss rate (summed contributions of degradation and dilution).</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - doublingTime (float with units of time) - doubling time of the cell</span>
<span class="sd">    - degradationRates (array of floats with units of 1/time) - protein degradation rate</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - array of floats with units of 1/time for the total loss rate for each protein</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">doublingTime</span> <span class="o">+</span> <span class="n">degradationRates</span></div>



<div class="viewcode-block" id="netLossRateFromDilutionAndDegradationRNA">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.netLossRateFromDilutionAndDegradationRNA">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">netLossRateFromDilutionAndDegradationRNA</span><span class="p">(</span>
    <span class="n">doublingTime</span><span class="p">,</span> <span class="n">totalEndoRnaseCountsCapacity</span><span class="p">,</span> <span class="n">Km</span><span class="p">,</span> <span class="n">rnaConc</span><span class="p">,</span> <span class="n">countsToMolar</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute total loss rate (summed impact of degradation and dilution).</span>
<span class="sd">    Returns the loss rate in units of (counts/time) in preparation for use in</span>
<span class="sd">    the steady state analysis in fitExpression() and</span>
<span class="sd">    setRNAPCountsConstrainedByPhysiology()</span>
<span class="sd">    (see calculateMinPolymerizingEnzymeByProductDistributionRNA()).</span>

<span class="sd">    Derived from steady state analysis of Michaelis-Menten enzyme kinetics with</span>
<span class="sd">    competitive inhibition: for a given RNA, all other RNAs compete for RNase.</span>

<span class="sd">    V_i = k_cat * [ES_i]</span>
<span class="sd">    v_i = k_cat * [E]0 * ([S_i]/Km_i) / (1 + sum over j genes([S_j] / Km_j))</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - doublingTime (float with units of time) - doubling time of the cell</span>
<span class="sd">    - totalEndoRnaseCountsCapacity (float with units of 1/time) total kinetic</span>
<span class="sd">    capacity of all RNases in the cell</span>
<span class="sd">    - Km (array of floats with units of mol/volume) - Michaelis-Menten constant</span>
<span class="sd">    for each RNA</span>
<span class="sd">    - rnaConc (array of floats with units of mol/volume) - concentration for each RNA</span>
<span class="sd">    - countsToMolar (float with units of mol/volume) - conversion between counts and molar</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - array of floats with units of 1/time for the total loss rate for each RNA</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fracSaturated</span> <span class="o">=</span> <span class="n">rnaConc</span> <span class="o">/</span> <span class="n">Km</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rnaConc</span> <span class="o">/</span> <span class="n">Km</span><span class="p">))</span>
    <span class="n">rnaCounts</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">countsToMolar</span><span class="p">)</span> <span class="o">*</span> <span class="n">rnaConc</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">doublingTime</span><span class="p">)</span> <span class="o">*</span> <span class="n">rnaCounts</span> <span class="o">+</span> <span class="p">(</span>
        <span class="n">totalEndoRnaseCountsCapacity</span> <span class="o">*</span> <span class="n">fracSaturated</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="netLossRateFromDilutionAndDegradationRNALinear">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.netLossRateFromDilutionAndDegradationRNALinear">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">netLossRateFromDilutionAndDegradationRNALinear</span><span class="p">(</span>
    <span class="n">doublingTime</span><span class="p">,</span> <span class="n">degradationRates</span><span class="p">,</span> <span class="n">rnaCounts</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute total loss rate (summed contributions of degradation and dilution).</span>
<span class="sd">    Returns the loss rate in units of (counts/time) in preparation for use in</span>
<span class="sd">    the steady state analysis in fitExpression() and</span>
<span class="sd">    setRNAPCountsConstrainedByPhysiology()</span>
<span class="sd">    (see calculateMinPolymerizingEnzymeByProductDistributionRNA()).</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - doublingTime (float with units of time) - doubling time of the cell</span>
<span class="sd">    - degradationRates (array of floats with units of 1/time) - degradation rate</span>
<span class="sd">    for each RNA</span>
<span class="sd">    - rnaCounts (array of floats) - counts for each RNA</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - array of floats with units of 1/time for the total loss rate for each RNA</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">doublingTime</span> <span class="o">+</span> <span class="n">degradationRates</span><span class="p">)</span> <span class="o">*</span> <span class="n">rnaCounts</span></div>



<div class="viewcode-block" id="expressionFromConditionAndFoldChange">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.expressionFromConditionAndFoldChange">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">expressionFromConditionAndFoldChange</span><span class="p">(</span><span class="n">transcription</span><span class="p">,</span> <span class="n">condPerturbations</span><span class="p">,</span> <span class="n">tfFCs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjusts expression of RNA based on fold changes from basal for a given</span>
<span class="sd">    condition. Since fold changes are reported for individual RNA cistrons, the</span>
<span class="sd">    changes are applied to the basal expression levels of each cistron and the</span>
<span class="sd">    resulting vector is mapped back to RNA expression through nonnegative least</span>
<span class="sd">    squares. For genotype perturbations, the expression of all RNAs that include</span>
<span class="sd">    the given cistron are set to the given value.</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - transcription: Instance of the Transcription class from</span>
<span class="sd">            reconstruction.ecoli.dataclasses.process.transcription</span>
<span class="sd">    - condPerturbations {cistron ID (str): fold change (float)} -</span>
<span class="sd">            dictionary of fold changes for cistrons based on the given condition</span>
<span class="sd">    - tfFCs {cistron ID (str): fold change (float)} -</span>
<span class="sd">            dictionary of fold changes for cistrons based on transcription factors</span>
<span class="sd">            in the given condition</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - expression (array of floats) - adjusted expression for each RNA,</span>
<span class="sd">    normalized to 1</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - TODO (Travis) - Might not properly handle if an RNA is adjusted from both a</span>
<span class="sd">    perturbation and a transcription factor, currently RNA self regulation is not</span>
<span class="sd">    included in tfFCs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cistron_ids</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">cistron_expression</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">fit_cistron_expression</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Gather indices and fold changes for each cistron that will be adjusted</span>
    <span class="n">cistron_id_to_index</span> <span class="o">=</span> <span class="p">{</span><span class="n">cistron_id</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cistron_id</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cistron_ids</span><span class="p">)}</span>
    <span class="n">cistron_indexes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cistron_fcs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Compile indexes and fold changes of each cistron</span>
    <span class="k">for</span> <span class="n">cistron_id</span><span class="p">,</span> <span class="n">fc_value</span> <span class="ow">in</span> <span class="n">tfFCs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">cistron_id</span> <span class="ow">in</span> <span class="n">condPerturbations</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">cistron_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cistron_id_to_index</span><span class="p">[</span><span class="n">cistron_id</span><span class="p">])</span>
        <span class="n">cistron_fcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fc_value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">apply_fcs_to_expression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">fcs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applys the fold-change values to an expression vector while keeping the</span>
<span class="sd">        sum of expression values at one.</span>

<span class="sd">        Args:</span>
<span class="sd">                expression (np.ndarray of floats): Original expression vector of</span>
<span class="sd">                        cistrons or RNAs</span>
<span class="sd">                indexes (List of floats): Indexes of cistrons/RNAs that the</span>
<span class="sd">                        fold-changes should be applied to</span>
<span class="sd">                fcs (List of floats): Fold-changes of cistron/RNA expression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">fc</span> <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">fc</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">fcs</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">idx</span> <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">fc</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">fcs</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">]</span>

        <span class="c1"># Adjust expression based on fold change and normalize</span>
        <span class="n">indexes_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">expression</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">indexes_bool</span><span class="p">[</span><span class="n">indexes</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">fcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fcs</span><span class="p">)</span>
        <span class="n">scaleTheRestBy</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">expression</span><span class="p">[</span><span class="n">indexes</span><span class="p">]</span> <span class="o">*</span> <span class="n">fcs</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">expression</span><span class="p">[</span><span class="n">indexes</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">expression</span><span class="p">[</span><span class="n">indexes_bool</span><span class="p">]</span> <span class="o">*=</span> <span class="n">fcs</span>
        <span class="n">expression</span><span class="p">[</span><span class="o">~</span><span class="n">indexes_bool</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scaleTheRestBy</span>

        <span class="k">return</span> <span class="n">expression</span>

    <span class="n">cistron_expression</span> <span class="o">=</span> <span class="n">apply_fcs_to_expression</span><span class="p">(</span>
        <span class="n">cistron_expression</span><span class="p">,</span> <span class="n">cistron_indexes</span><span class="p">,</span> <span class="n">cistron_fcs</span>
    <span class="p">)</span>

    <span class="c1"># Use NNLS to map new cistron expression to RNA expression</span>
    <span class="n">expression</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">fit_rna_expression</span><span class="p">(</span><span class="n">cistron_expression</span><span class="p">)</span>
    <span class="n">expression</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>

    <span class="c1"># Apply genotype perturbations to all RNAs that contain each cistron</span>
    <span class="n">rna_indexes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rna_fcs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cistron_perturbation_indexes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cistron_perturbation_values</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">cistron_id</span><span class="p">,</span> <span class="n">perturbation_value</span> <span class="ow">in</span> <span class="n">condPerturbations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">rna_indexes_with_cistron</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">cistron_id_to_rna_indexes</span><span class="p">(</span><span class="n">cistron_id</span><span class="p">)</span>
        <span class="n">rna_indexes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rna_indexes_with_cistron</span><span class="p">)</span>
        <span class="n">rna_fcs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">perturbation_value</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">rna_indexes_with_cistron</span><span class="p">))</span>
        <span class="n">cistron_perturbation_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cistron_id_to_index</span><span class="p">[</span><span class="n">cistron_id</span><span class="p">])</span>
        <span class="n">cistron_perturbation_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">perturbation_value</span><span class="p">)</span>

    <span class="n">expression</span> <span class="o">=</span> <span class="n">apply_fcs_to_expression</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">rna_indexes</span><span class="p">,</span> <span class="n">rna_fcs</span><span class="p">)</span>
    <span class="c1"># Also apply perturbations to cistrons for bookkeeping purposes</span>
    <span class="n">cistron_expression</span> <span class="o">=</span> <span class="n">apply_fcs_to_expression</span><span class="p">(</span>
        <span class="n">cistron_expression</span><span class="p">,</span> <span class="n">cistron_perturbation_indexes</span><span class="p">,</span> <span class="n">cistron_perturbation_values</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">expression</span><span class="p">,</span> <span class="n">cistron_expression</span></div>



<div class="viewcode-block" id="fitPromoterBoundProbability">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.fitPromoterBoundProbability">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fitPromoterBoundProbability</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the probabilities (P) that each transcription factor will bind</span>
<span class="sd">    to its target RNA. This function initially calculates these probabilities</span>
<span class="sd">    from the bulk average counts of the TFs and ligands calculated from</span>
<span class="sd">    previous steps. Then, values of parameters alpha and r in the equation</span>
<span class="sd">    below are fit such that the computed RNA synthesis probabilities converge</span>
<span class="sd">    to the measured RNA synthesis probabilities.</span>

<span class="sd">    v_{synth, j} = \alpha_j + \sum_{i} P_{T,i}*r_{ij}</span>

<span class="sd">    Due to constraints applied in the optimization, both v and P need to</span>
<span class="sd">    be shifted from their initial values.</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - Bulk average counts of transcription factors and associated ligands</span>
<span class="sd">    for each condition (in cell_specs)</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - cell_specs {condition (str): dict} - information about each condition</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - Probabilities of TFs binding to their promoters</span>
<span class="sd">    - RNA synthesis probabilities</span>
<span class="sd">    - cell_specs[&#39;basal&#39;][&#39;r_vector&#39;]: Fit parameters on how the recruitment of</span>
<span class="sd">    a TF affects the expression of a gene. High (positive) values of r indicate</span>
<span class="sd">    that the TF binding increases the probability that the gene is expressed.</span>
<span class="sd">    - cell_specs[&#39;basal&#39;][&#39;r_columns&#39;]: mapping of column name to index in r</span>

<span class="sd">    Notes</span>
<span class="sd">    --------</span>
<span class="sd">    See supplementary materials on transcription regulation for details on</span>
<span class="sd">    the parameters being fit.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_vector_k</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct vector k that contains existing fit transcription</span>
<span class="sd">        probabilities of RNAs in each relevant condition, normalized by the</span>
<span class="sd">        average copy number of the gene encoding the RNA while the cell grows</span>
<span class="sd">        in that condition.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        - k: List of RNA synthesis probabilities for each RNA and condition,</span>
<span class="sd">        normalized by gene copy number.</span>
<span class="sd">        - kInfo: List of dictionaries that hold information on values of k -</span>
<span class="sd">        kInfo[i][&quot;condition&quot;] and kInfo[i][&quot;idx&quot;] hold what condition and RNA</span>
<span class="sd">        index the probability k[i] refers to, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">k</span><span class="p">,</span> <span class="n">kInfo</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">rnaId</span><span class="p">,</span> <span class="n">rnaCoordinate</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;replication_coordinate&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Get list of TFs that regulate this RNA</span>
            <span class="n">tfs</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">relation</span><span class="o">.</span><span class="n">rna_id_to_regulating_tfs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rnaId</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">conditions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span>
            <span class="n">tfsWithData</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Take only those TFs with active/inactive conditions data</span>
            <span class="c1"># TODO (Gwanggyu): cache this list of conditions for each RNA</span>
            <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">tfs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Add conditions for selected TFs</span>
                <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__active&quot;</span><span class="p">)</span>
                <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__inactive&quot;</span><span class="p">)</span>
                <span class="n">tfsWithData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">conditions</span><span class="p">:</span>
                <span class="c1"># Skip basal conditions, unless the RNA is not regulated by any TFs</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tfsWithData</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;basal&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Get specific doubling time for this condition</span>
                <span class="n">tau</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="s2">&quot;doubling_time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>

                <span class="c1"># Calculate average copy number of gene for this condition</span>
                <span class="n">n_avg_copy</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">get_average_copy_number</span><span class="p">(</span>
                    <span class="n">tau</span><span class="p">,</span> <span class="n">rnaCoordinate</span>
                <span class="p">)</span>

                <span class="c1"># Compute synthesis probability per gene copy</span>
                <span class="n">prob_per_copy</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                    <span class="o">/</span> <span class="n">n_avg_copy</span>
                <span class="p">)</span>

                <span class="c1"># Gather RNA synthesis probabilities for each RNA per condition</span>
                <span class="n">k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prob_per_copy</span><span class="p">)</span>
                <span class="n">kInfo</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;condition&quot;</span><span class="p">:</span> <span class="n">condition</span><span class="p">,</span> <span class="s2">&quot;idx&quot;</span><span class="p">:</span> <span class="n">idx</span><span class="p">})</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">kInfo</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_matrix_G</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">pPromoterBound</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct matrix G that contains probabilities of pPromoterBound as</span>
<span class="sd">        elements. Each row of the matrix is named &quot;[RNA]__[condition]&quot;, where</span>
<span class="sd">        there are two conditions [active/inactive] for each TF that regulates</span>
<span class="sd">        the expression of the given RNA. For RNAs that are not regulated by</span>
<span class="sd">        any TFs, a single row named &quot;[RNA]__basal&quot; represents the RNA. Each</span>
<span class="sd">        column is named &quot;[RNA]__[TF]&quot;, for each TF that regulates the</span>
<span class="sd">        expression of the given RNA. Each element is set to the value in</span>
<span class="sd">        pPromoterBound that corresponds to the condition given by the row,</span>
<span class="sd">        and the TF given by the column. For each RNA, there is an additional</span>
<span class="sd">        column named &quot;[RNA]__alpha&quot;, and all elements in this column that</span>
<span class="sd">        corresponds to the rows for the RNA are set to 1.</span>

<span class="sd">        Inputs</span>
<span class="sd">        ------</span>
<span class="sd">        - pPromoterBound: Probabilities that a given TF is bound to its</span>
<span class="sd">        promoter in a given condition, calculated from bulk average</span>
<span class="sd">        concentrations of the TF and its associated ligands.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        - G: Matrix of values in pPromoterBound, rearranged based on each RNA</span>
<span class="sd">        - row_name_to_index: Dict[str, int] of row names of G to row index</span>
<span class="sd">        - col_name_to_index: Dict[str, int] of column names of G to column index</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gI</span><span class="p">,</span> <span class="n">gJ</span><span class="p">,</span> <span class="n">gV</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">row_name_to_index</span><span class="p">,</span> <span class="n">col_name_to_index</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rnaId</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]):</span>
            <span class="n">rnaIdNoLoc</span> <span class="o">=</span> <span class="n">rnaId</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># Remove compartment ID from RNA ID</span>

            <span class="c1"># Get list of TFs that regulate this RNA</span>
            <span class="n">tfs</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">relation</span><span class="o">.</span><span class="n">rna_id_to_regulating_tfs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rnaId</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">conditions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span>
            <span class="n">tfsWithData</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Take only those TFs with active/inactive conditions data</span>
            <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">tfs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Add conditions for selected TFs</span>
                <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__active&quot;</span><span class="p">)</span>
                <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__inactive&quot;</span><span class="p">)</span>
                <span class="n">tfsWithData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">conditions</span><span class="p">:</span>
                <span class="c1"># Skip basal conditions, unless the RNA is not regulated by any TFs</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tfsWithData</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;basal&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Add row for each condition specific to each RNA</span>
                <span class="n">row_name</span> <span class="o">=</span> <span class="n">rnaIdNoLoc</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">condition</span>
                <span class="n">row_name_to_index</span><span class="p">[</span><span class="n">row_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_name_to_index</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">tfsWithData</span><span class="p">:</span>
                    <span class="c1"># Add column for each TF that regulates each RNA</span>
                    <span class="n">col_name</span> <span class="o">=</span> <span class="n">rnaIdNoLoc</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">tf</span>

                    <span class="c1"># TODO (Gwanggyu): Are these checks necessary?</span>
                    <span class="k">if</span> <span class="n">col_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col_name_to_index</span><span class="p">:</span>
                        <span class="n">col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_name_to_index</span><span class="p">)</span>

                    <span class="n">gI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_name_to_index</span><span class="p">[</span><span class="n">row_name</span><span class="p">])</span>
                    <span class="n">gJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
                    <span class="n">gV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span>
                    <span class="p">)</span>  <span class="c1"># Probability that TF is bound in given condition</span>

                <span class="c1"># Add alpha column for each RNA</span>
                <span class="n">col_name</span> <span class="o">=</span> <span class="n">rnaIdNoLoc</span> <span class="o">+</span> <span class="s2">&quot;__alpha&quot;</span>

                <span class="k">if</span> <span class="n">col_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col_name_to_index</span><span class="p">:</span>
                    <span class="n">col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_name_to_index</span><span class="p">)</span>

                <span class="n">gI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_name_to_index</span><span class="p">[</span><span class="n">row_name</span><span class="p">])</span>
                <span class="n">gJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
                <span class="n">gV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="n">gI</span><span class="p">,</span> <span class="n">gJ</span><span class="p">,</span> <span class="n">gV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gI</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gJ</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gV</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">row_name_to_index</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_name_to_index</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">G</span><span class="p">[</span><span class="n">gI</span><span class="p">,</span> <span class="n">gJ</span><span class="p">]</span> <span class="o">=</span> <span class="n">gV</span>

        <span class="k">return</span> <span class="n">G</span><span class="p">,</span> <span class="n">row_name_to_index</span><span class="p">,</span> <span class="n">col_name_to_index</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_matrix_Z</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">col_name_to_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct matrix Z that connects all possible TF combinations with</span>
<span class="sd">        each TF. Each row of the matrix corresponds to an RNA-(TF combination)</span>
<span class="sd">        pair, and each column corresponds to an RNA-TF pair, with an additional</span>
<span class="sd">        RNA-alpha column for each RNA (identical to matrix G). Matrix values</span>
<span class="sd">        are set to one if the TF specified by the column is &quot;active&quot; in the</span>
<span class="sd">        combination specified by the row or if the column is an RNA-alpha</span>
<span class="sd">        column, and zero otherwise.</span>

<span class="sd">        Inputs</span>
<span class="sd">        ------</span>
<span class="sd">        - col_name_to_index: Dict[str, int] of column names of G to column index</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        - Z: Matrix of zeros and ones, specifying which TFs in the columns</span>
<span class="sd">        correspond to combinations in the rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">zI</span><span class="p">,</span> <span class="n">zJ</span><span class="p">,</span> <span class="n">zV</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">row_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">rna_id</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]:</span>
            <span class="n">rna_id_no_loc</span> <span class="o">=</span> <span class="n">rna_id</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># Remove compartment ID from RNA ID</span>

            <span class="c1"># Get list of TFs that regulate this RNA</span>
            <span class="n">tfs</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">relation</span><span class="o">.</span><span class="n">rna_id_to_regulating_tfs</span><span class="p">[</span><span class="n">rna_id</span><span class="p">]</span>
            <span class="n">tfs_with_data</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Get column index of the RNA&#39;s alpha column</span>
            <span class="n">col_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_name_to_index</span><span class="p">[</span><span class="n">rna_id_no_loc</span> <span class="o">+</span> <span class="s2">&quot;__alpha&quot;</span><span class="p">]]</span>

            <span class="c1"># Take only those TFs with active/inactive conditions data</span>
            <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">tfs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">tfs_with_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>

                <span class="c1"># Get column index of the RNA-TF pair</span>
                <span class="n">col_idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_name_to_index</span><span class="p">[</span><span class="n">rna_id_no_loc</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">tf</span><span class="p">])</span>

            <span class="n">n_tfs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tfs_with_data</span><span class="p">)</span>

            <span class="c1"># For all possible combinations of TFs</span>
            <span class="k">for</span> <span class="n">n_combinations</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tfs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span>
                    <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_tfs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">n_combinations</span>
                <span class="p">):</span>
                    <span class="c1"># Always include alpha column</span>
                    <span class="n">zI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_idx</span><span class="p">)</span>
                    <span class="n">zJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">zV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

                    <span class="c1"># Set matrix value to one if the TF specified by the column is</span>
                    <span class="c1"># present in the combination of TFs specified by the row</span>
                    <span class="k">for</span> <span class="n">col_idx</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
                        <span class="n">zI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_idx</span><span class="p">)</span>
                        <span class="n">zJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_idxs</span><span class="p">[</span><span class="n">col_idx</span><span class="p">])</span>
                        <span class="n">zV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

                    <span class="n">row_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Build matrix Z</span>
        <span class="n">zI</span><span class="p">,</span> <span class="n">zJ</span><span class="p">,</span> <span class="n">zV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zI</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zJ</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zV</span><span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">zI</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">zJ</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">Z</span><span class="p">[</span><span class="n">zI</span><span class="p">,</span> <span class="n">zJ</span><span class="p">]</span> <span class="o">=</span> <span class="n">zV</span>

        <span class="k">return</span> <span class="n">Z</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_matrix_T</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">col_name_to_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct matrix T that specifies the direction of regulation for each</span>
<span class="sd">        RNA-TF pair.</span>

<span class="sd">        Inputs</span>
<span class="sd">        ------</span>
<span class="sd">        - col_name_to_index: Dict[str, int] of column names of G to column index</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        - T: Diagonal matrix. Diagonal value is +1 if the direction of</span>
<span class="sd">        regulation by the TF-RNA pair specified by the row is positive, -1 if</span>
<span class="sd">        this is negative, and 0 if the row is an RNA_alpha row.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tI</span><span class="p">,</span> <span class="n">tJ</span><span class="p">,</span> <span class="n">tV</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">row_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">rnaId</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]:</span>
            <span class="n">rnaIdNoLoc</span> <span class="o">=</span> <span class="n">rnaId</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># Remove compartment ID from RNA ID</span>

            <span class="c1"># Get list of TFs that regulate this RNA</span>
            <span class="n">tfs</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">relation</span><span class="o">.</span><span class="n">rna_id_to_regulating_tfs</span><span class="p">[</span><span class="n">rnaId</span><span class="p">]</span>
            <span class="n">tfsWithData</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Get list of constituent cistron IDs</span>
            <span class="n">constituent_cistron_ids</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_id_to_cistron_indexes</span><span class="p">(</span><span class="n">rnaId</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="c1"># Take only those TFs with active/inactive conditions data</span>
            <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">tfs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">tfsWithData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">tfsWithData</span><span class="p">:</span>
                <span class="c1"># Calculate the consensus regulation direction of the TF on the</span>
                <span class="c1"># cistrons that constitute this transcription unit</span>
                <span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_direction</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cistron_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">cistron_id</span> <span class="ow">in</span> <span class="n">constituent_cistron_ids</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="n">consensus_direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">directions</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Add row for TF and find column for TF in col_name_to_index</span>
                <span class="n">col_name</span> <span class="o">=</span> <span class="n">rnaIdNoLoc</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">tf</span>

                <span class="c1"># Set matrix value to regulation direction (+1 or -1)</span>
                <span class="n">tI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_idx</span><span class="p">)</span>
                <span class="n">tJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
                <span class="n">tV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">consensus_direction</span><span class="p">)</span>
                <span class="n">row_idx</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Add RNA_alpha rows and columns, and set matrix value to zero</span>
            <span class="n">col_name</span> <span class="o">=</span> <span class="n">rnaIdNoLoc</span> <span class="o">+</span> <span class="s2">&quot;__alpha&quot;</span>

            <span class="n">tI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_idx</span><span class="p">)</span>
            <span class="n">tJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
            <span class="n">tV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">row_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">tI</span><span class="p">,</span> <span class="n">tJ</span><span class="p">,</span> <span class="n">tV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tI</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tJ</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tV</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">tI</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tJ</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">T</span><span class="p">[</span><span class="n">tI</span><span class="p">,</span> <span class="n">tJ</span><span class="p">]</span> <span class="o">=</span> <span class="n">tV</span>

        <span class="k">return</span> <span class="n">T</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_matrix_H</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="p">,</span> <span class="n">col_name_to_index</span><span class="p">,</span> <span class="n">pPromoterBound</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">fixedTFs</span><span class="p">,</span> <span class="n">cell_specs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct matrix H that contains values of vector r as elements.</span>
<span class="sd">        Each row of the matrix is named &quot;[RNA]__[condition]&quot;, where</span>
<span class="sd">        there are two conditions [active/inactive] for each TF that regulates</span>
<span class="sd">        the expression of the given RNA. For RNAs that are not regulated by</span>
<span class="sd">        any TFs, a single row named &quot;[RNA]__basal&quot; represents the RNA. Each</span>
<span class="sd">        column is named &quot;[TF]__[condition]&quot;, for each TF that regulates the</span>
<span class="sd">        expression of the given RNA, and each condition given for the RNA.</span>
<span class="sd">        Each element is set to the optimized value in r that corresponds to</span>
<span class="sd">        the RNA given by the row, and the TF given by the column. For each RNA,</span>
<span class="sd">        there is an additional column named &quot;[RNA]__alpha&quot;, and all elements in</span>
<span class="sd">        this column are set to the value of parameter alpha for the RNA</span>
<span class="sd">        optimized in r.</span>

<span class="sd">        Inputs</span>
<span class="sd">        ------</span>
<span class="sd">        - col_name_to_index: Dict[str, int] of column names of G to column index</span>
<span class="sd">        - pPromoterBound: Probabilities that a given TF is bound to its</span>
<span class="sd">        promoter in a given condition, calculated from bulk average</span>
<span class="sd">        concentrations of the TF and its associated ligands.</span>
<span class="sd">        - r: Optimized values of \Delta r (the effect of TF on RNAP</span>
<span class="sd">        recruitment) and alpha (basal recruitment of RNAP)</span>
<span class="sd">        - fixedTFs: List of TFs whose activities do not change with the</span>
<span class="sd">        nutrient conditions</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        - H: Matrix of values in optimized r, rearranged for each RNA and</span>
<span class="sd">        condition</span>
<span class="sd">        - pInit: Vector of values in pPromoterBound, rearranged to the ordering</span>
<span class="sd">        of the columns of H</span>
<span class="sd">        - pAlphaIdxs: Indexes of columns that correspond to alpha&#39;s in H and pInit</span>
<span class="sd">        - pNotAlphaIdxs: Indexes of columns that correspond to r&#39;s in H and pInit</span>
<span class="sd">        - fixedTFIdxs: Indexes of columns that correspond to fixed TFs in H and pInit</span>
<span class="sd">        - pPromoterBoundIdxs: Dictionary of indexes to pInit.</span>
<span class="sd">        - H_col_name_to_index: Dict[str, int] of column names of H to column index</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">col_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">col_name_to_index</span><span class="p">,</span> <span class="n">r</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="n">pPromoterBoundIdxs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">condition</span><span class="p">,</span> <span class="p">{})</span> <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">pPromoterBound</span><span class="p">])</span>
        <span class="n">hI</span><span class="p">,</span> <span class="n">hJ</span><span class="p">,</span> <span class="n">hV</span><span class="p">,</span> <span class="n">pInitI</span><span class="p">,</span> <span class="n">pInitV</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">H_row_name_to_index</span><span class="p">,</span> <span class="n">H_col_name_to_index</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">rnaId</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]):</span>
            <span class="n">rnaIdNoLoc</span> <span class="o">=</span> <span class="n">rnaId</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># Remove compartment ID from RNA ID</span>

            <span class="n">tfs</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">relation</span><span class="o">.</span><span class="n">rna_id_to_regulating_tfs</span><span class="p">[</span><span class="n">rnaId</span><span class="p">]</span>
            <span class="n">conditions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">]</span>
            <span class="n">tfsWithData</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Take only those TFs with active/inactive conditions data</span>
            <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">tfs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># Add conditions for selected TFs</span>
                <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__active&quot;</span><span class="p">)</span>
                <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__inactive&quot;</span><span class="p">)</span>
                <span class="n">tfsWithData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">conditions</span><span class="p">:</span>
                <span class="c1"># Skip basal conditions, unless the RNA is not regulated by any TFs</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tfsWithData</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">condition</span> <span class="o">==</span> <span class="s2">&quot;basal&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Add row for each condition specific to each RNA</span>
                <span class="n">row_name</span> <span class="o">=</span> <span class="n">rnaIdNoLoc</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">condition</span>
                <span class="n">H_row_name_to_index</span><span class="p">[</span><span class="n">row_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H_row_name_to_index</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">tfsWithData</span><span class="p">:</span>
                    <span class="c1"># Add column for each TF and condition</span>
                    <span class="n">col_name</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">condition</span>

                    <span class="k">if</span> <span class="n">col_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">H_col_name_to_index</span><span class="p">:</span>
                        <span class="n">H_col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H_col_name_to_index</span><span class="p">)</span>

                    <span class="n">hI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H_row_name_to_index</span><span class="p">[</span><span class="n">row_name</span><span class="p">])</span>
                    <span class="n">hJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H_col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>

                    <span class="c1"># Handle the case of the TF being knocked out (admittedly not the cleanest solution)</span>
                    <span class="n">tf_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
                        <span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">counts</span><span class="p">(</span><span class="n">cell_specs</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">],</span> <span class="n">tf_idx</span><span class="p">)</span>
                        <span class="o">==</span> <span class="mi">0</span>
                    <span class="p">):</span>
                        <span class="n">hV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># TF is knocked out in the given condition</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">hV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">rDict</span><span class="p">[</span><span class="n">rnaIdNoLoc</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">tf</span><span class="p">]</span>
                        <span class="p">)</span>  <span class="c1"># Optimized r value for TF-RNA pair</span>

                    <span class="c1"># Rearrange values in pPromoterBound in the same order</span>
                    <span class="c1"># given by the columns of H</span>
                    <span class="n">pInitI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H_col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
                    <span class="n">pInitV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pPromoterBound</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="n">tf</span><span class="p">])</span>
                    <span class="n">pPromoterBoundIdxs</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="n">H_col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span>

                <span class="c1"># Add alpha column for each RNA</span>
                <span class="n">col_name</span> <span class="o">=</span> <span class="n">rnaIdNoLoc</span> <span class="o">+</span> <span class="s2">&quot;__alpha&quot;</span>

                <span class="k">if</span> <span class="n">col_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">H_col_name_to_index</span><span class="p">:</span>
                    <span class="n">H_col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H_col_name_to_index</span><span class="p">)</span>

                <span class="c1"># Add optimized value of alpha in r to H</span>
                <span class="n">hI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H_row_name_to_index</span><span class="p">[</span><span class="n">row_name</span><span class="p">])</span>
                <span class="n">hJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H_col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
                <span class="n">hV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rDict</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>

                <span class="c1"># Set corresponding value in pInit to one</span>
                <span class="n">pInitI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H_col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
                <span class="n">pInitV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="c1"># Save indices to update promoter binding for active TFs in combined conditions</span>
        <span class="k">for</span> <span class="n">condition</span><span class="p">,</span> <span class="n">tfs</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_active_tfs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">tfs</span><span class="p">:</span>
                <span class="n">col_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tf</span><span class="si">}</span><span class="s2">__</span><span class="si">{</span><span class="n">tf</span><span class="si">}</span><span class="s2">__active&quot;</span>
                <span class="n">pPromoterBoundIdxs</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="n">H_col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span>

        <span class="c1"># Save indices to update promoter binding for inactive TFs in combined conditions</span>
        <span class="k">for</span> <span class="n">condition</span><span class="p">,</span> <span class="n">tfs</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_inactive_tfs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">tfs</span><span class="p">:</span>
                <span class="n">col_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tf</span><span class="si">}</span><span class="s2">__</span><span class="si">{</span><span class="n">tf</span><span class="si">}</span><span class="s2">__inactive&quot;</span>
                <span class="n">pPromoterBoundIdxs</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="n">H_col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span>

        <span class="c1"># Build vector pInit and matrix H</span>
        <span class="n">pInit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pInitI</span><span class="p">)))</span>
        <span class="n">pInit</span><span class="p">[</span><span class="n">pInitI</span><span class="p">]</span> <span class="o">=</span> <span class="n">pInitV</span>

        <span class="n">hI</span><span class="p">,</span> <span class="n">hJ</span><span class="p">,</span> <span class="n">hV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hI</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hJ</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hV</span><span class="p">)</span>
        <span class="n">Hshape</span> <span class="o">=</span> <span class="p">(</span><span class="n">hI</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hJ</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Hshape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">H</span><span class="p">[</span><span class="n">hI</span><span class="p">,</span> <span class="n">hJ</span><span class="p">]</span> <span class="o">=</span> <span class="n">hV</span>

        <span class="c1"># Get indexes of alpha and non-alpha columns in pInit and H</span>
        <span class="n">pAlphaIdxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">idx</span>
                <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">H_col_name_to_index</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">col_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;__alpha&quot;</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">pNotAlphaIdxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">idx</span>
                <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">H_col_name_to_index</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">col_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;__alpha&quot;</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Get indexes of columns that correspond to fixed TFs</span>
        <span class="n">fixedTFIdxs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">H_col_name_to_index</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">secondElem</span> <span class="o">=</span> <span class="n">col_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">secondElem</span> <span class="ow">in</span> <span class="n">fixedTFs</span><span class="p">:</span>
                <span class="n">fixedTFIdxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">fixedTFIdxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fixedTFIdxs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">H</span><span class="p">,</span>
            <span class="n">pInit</span><span class="p">,</span>
            <span class="n">pAlphaIdxs</span><span class="p">,</span>
            <span class="n">pNotAlphaIdxs</span><span class="p">,</span>
            <span class="n">fixedTFIdxs</span><span class="p">,</span>
            <span class="n">pPromoterBoundIdxs</span><span class="p">,</span>
            <span class="n">H_col_name_to_index</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_matrix_pdiff</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">H_col_name_to_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct matrix Pdiff that specifies the indexes of corresponding</span>
<span class="sd">        TFs and conditions.</span>

<span class="sd">        Inputs</span>
<span class="sd">        ------</span>
<span class="sd">        - H_col_name_to_index: Dict[str, int] of column names of H to column index</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        - Pdiff: Matrix with [TF] as rows and [TF]_[condition] as columns.</span>
<span class="sd">        Matrix value is set to 1 when the TF of the column matches with the TF</span>
<span class="sd">        of the row, and the condition is TF__active. Matrix value is set to -1</span>
<span class="sd">        when the TF of the column matches with the TF of the row, and the</span>
<span class="sd">        condition is TF__inactive.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">PdiffI</span><span class="p">,</span> <span class="n">PdiffJ</span><span class="p">,</span> <span class="n">PdiffV</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">rowIdx</span><span class="p">,</span> <span class="n">tf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">)):</span>
            <span class="c1"># For each TF, find condition [TF]__[TF]__active and set element to 1</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__active&quot;</span>
            <span class="n">col_name</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">condition</span>
            <span class="n">PdiffI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rowIdx</span><span class="p">)</span>
            <span class="n">PdiffJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H_col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
            <span class="n">PdiffV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Find condition [TF]__[TF]__inactive and set element to -1</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__inactive&quot;</span>
            <span class="n">col_name</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">condition</span>
            <span class="n">PdiffI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rowIdx</span><span class="p">)</span>
            <span class="n">PdiffJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H_col_name_to_index</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
            <span class="n">PdiffV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Build matrix Pdiff</span>
        <span class="n">PdiffI</span><span class="p">,</span> <span class="n">PdiffJ</span><span class="p">,</span> <span class="n">PdiffV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">PdiffI</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">PdiffJ</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">PdiffV</span><span class="p">)</span>
        <span class="n">Pdiffshape</span> <span class="o">=</span> <span class="p">(</span><span class="n">PdiffI</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">H_col_name_to_index</span><span class="p">))</span>
        <span class="n">Pdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Pdiffshape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">Pdiff</span><span class="p">[</span><span class="n">PdiffI</span><span class="p">,</span> <span class="n">PdiffJ</span><span class="p">]</span> <span class="o">=</span> <span class="n">PdiffV</span>

        <span class="k">return</span> <span class="n">Pdiff</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fromArray</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pPromoterBound</span><span class="p">,</span> <span class="n">pPromoterBoundIdxs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates values in pPromoterBound with fit probabilities.</span>

<span class="sd">        Inputs</span>
<span class="sd">        ------</span>
<span class="sd">        - p: Vector of probabilities optimized in the current step.</span>
<span class="sd">        - pPromoterBoundIdxs: Dictionary of indexes to p</span>

<span class="sd">        Modifies</span>
<span class="sd">        --------</span>
<span class="sd">        Values in pPromoterBound - probabilities that each transcription factor</span>
<span class="sd">        is bound to its promoter for each growth condition</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pPromoterBoundIdxs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pPromoterBoundIdxs</span><span class="p">[</span><span class="n">condition</span><span class="p">]):</span>
                <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">pPromoterBoundIdxs</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="n">tf</span><span class="p">]]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">updateSynthProb</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="n">kInfo</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates RNA synthesis probabilities with fit values of P and R. The</span>
<span class="sd">        expected average copy number of genes for the condition are multiplied</span>
<span class="sd">        to the per-copy probabilities.</span>

<span class="sd">        Inputs</span>
<span class="sd">        ------</span>
<span class="sd">        - kInfo: List of dictionaries that hold information on values of k -</span>
<span class="sd">        kInfo[i][&quot;condition&quot;] and kInfo[i][&quot;idx&quot;] hold what condition and RNA</span>
<span class="sd">        index the probability k[i] refers to, respectively.</span>
<span class="sd">        - k: RNA synthesis probabilities computed from fit P and R.</span>

<span class="sd">        Modifies</span>
<span class="sd">        --------</span>
<span class="sd">        - RNA synthesis probabilities</span>

<span class="sd">        Notes</span>
<span class="sd">        --------</span>
<span class="sd">        These values are used to calculate pre-set probabilities for</span>
<span class="sd">        pools of mRNA, tRNA, and rRNA, and the genes that encode RNAP and</span>
<span class="sd">        ribosome subunits.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get replication coordinates of each RNA</span>
        <span class="n">replication_coordinate</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span>
            <span class="s2">&quot;replication_coordinate&quot;</span>
        <span class="p">]</span>

        <span class="c1"># Update sim_data values with fit values</span>
        <span class="k">for</span> <span class="n">D</span><span class="p">,</span> <span class="n">k_value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kInfo</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="s2">&quot;condition&quot;</span><span class="p">]</span>
            <span class="n">rna_idx</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="s2">&quot;idx&quot;</span><span class="p">]</span>

            <span class="c1"># Get coordinate of RNA</span>
            <span class="n">rnaCoordinate</span> <span class="o">=</span> <span class="n">replication_coordinate</span><span class="p">[</span><span class="n">rna_idx</span><span class="p">]</span>

            <span class="c1"># Get specific doubling time for this condition</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="s2">&quot;doubling_time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>

            <span class="c1"># Calculate average copy number of gene for this condition</span>
            <span class="n">n_avg_copy</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">get_average_copy_number</span><span class="p">(</span>
                <span class="n">tau</span><span class="p">,</span> <span class="n">rnaCoordinate</span>
            <span class="p">)</span>

            <span class="c1"># Multiply copy number by k_value to get synthesis probability</span>
            <span class="c1"># (if k_value is negative clip at zero)</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">condition</span><span class="p">][</span><span class="n">rna_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k_value</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_avg_copy</span>
            <span class="p">)</span>

        <span class="c1"># Normalize values such that probabilities for each condition sum to one</span>
        <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span> <span class="o">/=</span> <span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_synth_prob</span><span class="p">[</span><span class="n">condition</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="p">)</span>

    <span class="c1"># Initialize pPromoterBound using mean TF and ligand concentrations</span>
    <span class="n">pPromoterBound</span> <span class="o">=</span> <span class="n">calculatePromoterBoundProbability</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">)</span>
    <span class="n">pInit0</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">lastNorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="n">fixedTFs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">tf_to_tf_type</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;2CS&quot;</span><span class="p">:</span>
            <span class="n">fixedTFs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">tf_to_tf_type</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;1CS&quot;</span>
            <span class="ow">and</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">[</span><span class="n">tf</span><span class="p">][</span><span class="s2">&quot;active nutrients&quot;</span><span class="p">]</span>
            <span class="o">==</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">[</span><span class="n">tf</span><span class="p">][</span><span class="s2">&quot;inactive nutrients&quot;</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">fixedTFs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>

    <span class="c1"># Build vector of existing fit transcription probabilities</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">kInfo</span> <span class="o">=</span> <span class="n">build_vector_k</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">)</span>

    <span class="c1"># Repeat for a fixed maximum number of iterations</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">PROMOTER_MAX_ITERATIONS</span><span class="p">):</span>
        <span class="c1"># Build matrices used in optimizing R</span>
        <span class="n">G</span><span class="p">,</span> <span class="n">G_row_name_to_index</span><span class="p">,</span> <span class="n">G_col_name_to_index</span> <span class="o">=</span> <span class="n">build_matrix_G</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="p">,</span> <span class="n">pPromoterBound</span>
        <span class="p">)</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">build_matrix_Z</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">G_col_name_to_index</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">build_matrix_T</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">G_col_name_to_index</span><span class="p">)</span>

        <span class="c1"># Optimize R such that transcription initiation probabilities computed</span>
        <span class="c1"># from existing values of P in matrix G are close to fit values.</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Vector of r&#39;s and alpha&#39;s</span>

        <span class="c1"># Objective: minimize difference between k and G @ R</span>
        <span class="n">objective_r</span> <span class="o">=</span> <span class="n">Minimize</span><span class="p">(</span>
            <span class="n">norm</span><span class="p">(</span><span class="n">G</span> <span class="o">@</span> <span class="p">(</span><span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span> <span class="o">-</span> <span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="n">PROMOTER_NORM_TYPE</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Optimization constraints</span>
        <span class="c1"># 1) 0 &lt;= Z @ R &lt;= 1 : Assuming P = 1 for all TFs, all possible</span>
        <span class="c1"># combinations of TFs should yield a valid transcription probability</span>
        <span class="c1"># value between zero and one.</span>
        <span class="c1"># 2) T @ R &gt;= 0 : Values of r for positive regulation should be positive,</span>
        <span class="c1"># and values of r for negative regulation should be negative.</span>
        <span class="n">constraint_r</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">Z</span> <span class="o">@</span> <span class="p">(</span><span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">R</span><span class="p">),</span>
            <span class="n">Z</span> <span class="o">@</span> <span class="p">(</span><span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">PROMOTER_SCALING</span><span class="p">,</span>
            <span class="n">T</span> <span class="o">@</span> <span class="p">(</span><span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="c1"># Solve optimization problem</span>
        <span class="n">prob_r</span> <span class="o">=</span> <span class="n">Problem</span><span class="p">(</span><span class="n">objective_r</span><span class="p">,</span> <span class="n">constraint_r</span><span class="p">)</span>
        <span class="n">prob_r</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;ECOS&quot;</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prob_r</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;optimal_inaccurate&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Solver found an optimum that is inaccurate.&quot;</span>
                <span class="s2">&quot; Try increasing max_iters or adjusting tolerances.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">prob_r</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="s2">&quot;optimal&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Solver could not find optimal value&quot;</span><span class="p">)</span>

        <span class="c1"># Get optimal value of R</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">r</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ECOS_0_TOLERANCE</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">0</span>  <span class="c1"># Adjust to 0 for small values from solver tolerance</span>
        <span class="p">)</span>

        <span class="c1"># Use optimal value of R to construct matrix H and vector Pdiff</span>
        <span class="p">(</span>
            <span class="n">H</span><span class="p">,</span>
            <span class="n">pInit</span><span class="p">,</span>
            <span class="n">pAlphaIdxs</span><span class="p">,</span>
            <span class="n">pNotAlphaIdxs</span><span class="p">,</span>
            <span class="n">fixedTFIdxs</span><span class="p">,</span>
            <span class="n">pPromoterBoundIdxs</span><span class="p">,</span>
            <span class="n">H_col_name_to_index</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">build_matrix_H</span><span class="p">(</span>
            <span class="n">sim_data</span><span class="p">,</span> <span class="n">G_col_name_to_index</span><span class="p">,</span> <span class="n">pPromoterBound</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">fixedTFs</span><span class="p">,</span> <span class="n">cell_specs</span>
        <span class="p">)</span>
        <span class="n">pdiff</span> <span class="o">=</span> <span class="n">build_matrix_pdiff</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">H_col_name_to_index</span><span class="p">)</span>

        <span class="c1"># On first iteration, save the value of the initial p</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pInit0</span> <span class="o">=</span> <span class="n">pInit</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Optimize P such that the transcription probabilities computed from</span>
        <span class="c1"># current values of R in matrix H are close to fit values.</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Construct a boolean vector that marks column indexes of H</span>
        <span class="c1"># corresponding to alpha&#39;s and fixed TFs</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">D</span><span class="p">[</span><span class="n">pAlphaIdxs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">D</span><span class="p">[</span><span class="n">fixedTFIdxs</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Mask initial p with boolean vector constructed above</span>
        <span class="n">Drhs</span> <span class="o">=</span> <span class="n">pInit0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">Drhs</span><span class="p">[</span><span class="n">D</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Objective: minimize difference between k (fit RNAP initiation</span>
        <span class="c1"># probabilities) and H @ P (computed initiation probabilities) while</span>
        <span class="c1"># also minimizing deviation of P from the original value calculated</span>
        <span class="c1"># from mean TF and ligand concentrations</span>
        <span class="n">objective_p</span> <span class="o">=</span> <span class="n">Minimize</span><span class="p">(</span>
            <span class="n">norm</span><span class="p">(</span><span class="n">H</span> <span class="o">@</span> <span class="p">(</span><span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">P</span><span class="p">)</span> <span class="o">-</span> <span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="n">PROMOTER_NORM_TYPE</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">PROMOTER_REG_COEFF</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">pInit0</span><span class="p">,</span> <span class="n">PROMOTER_NORM_TYPE</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Constraints</span>
        <span class="c1"># 1) 0 &lt;= P &lt;= 1 : All DNA-bound probabilities should be between zero</span>
        <span class="c1"># and one.</span>
        <span class="c1"># 2) D @ P == Drhs : Values of P that correspond to alpha&#39;s and fixed TFs</span>
        <span class="c1"># should not change.</span>
        <span class="c1"># 3) pdiff @ P &gt;= PROMOTER_PDIFF_THRESHOLD : There must be at least a</span>
        <span class="c1"># certain difference between binding probabilities of a TF in conditions</span>
        <span class="c1"># TF__active and TF__inactive</span>
        <span class="n">constraint_p</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">P</span><span class="p">,</span>
            <span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">P</span> <span class="o">&lt;=</span> <span class="n">PROMOTER_SCALING</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">D</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">P</span><span class="p">)</span> <span class="o">==</span> <span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">Drhs</span><span class="p">,</span>
            <span class="n">pdiff</span> <span class="o">@</span> <span class="p">(</span><span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">P</span><span class="p">)</span>
            <span class="o">&gt;=</span> <span class="n">PROMOTER_SCALING</span> <span class="o">*</span> <span class="n">PROMOTER_PDIFF_THRESHOLD</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="c1"># Solve optimization problem</span>
        <span class="n">prob_p</span> <span class="o">=</span> <span class="n">Problem</span><span class="p">(</span><span class="n">objective_p</span><span class="p">,</span> <span class="n">constraint_p</span><span class="p">)</span>
        <span class="n">prob_p</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span><span class="s2">&quot;ECOS&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prob_p</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="s2">&quot;optimal_inaccurate&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;Solver found an optimum that is inaccurate.&quot;</span>
                <span class="s2">&quot; Try increasing max_iters or adjusting tolerances.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">prob_p</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="s2">&quot;optimal&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Solver could not find optimal value&quot;</span><span class="p">)</span>

        <span class="c1"># Get optimal value of P</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Adjust for solver tolerance over bounds to get proper probabilities</span>
        <span class="n">p</span><span class="p">[</span><span class="n">p</span> <span class="o">&lt;</span> <span class="n">ECOS_0_TOLERANCE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">p</span><span class="p">[</span><span class="n">p</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ECOS_0_TOLERANCE</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Update pPromoterBound with fit p</span>
        <span class="n">fromArray</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pPromoterBound</span><span class="p">,</span> <span class="n">pPromoterBoundIdxs</span><span class="p">)</span>

        <span class="c1"># Break from loop if parameters have converged</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span><span class="p">,</span> <span class="n">PROMOTER_NORM_TYPE</span><span class="p">)</span> <span class="o">-</span> <span class="n">lastNorm</span><span class="p">)</span>
            <span class="o">&lt;</span> <span class="n">PROMOTER_CONVERGENCE_THRESHOLD</span>
        <span class="p">):</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lastNorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span><span class="p">,</span> <span class="n">PROMOTER_NORM_TYPE</span><span class="p">)</span>

    <span class="c1"># Update sim_data with fit bound probabilities and RNAP initiation</span>
    <span class="c1"># probabilities computed from these bound probabilities</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">pPromoterBound</span> <span class="o">=</span> <span class="n">pPromoterBound</span>
    <span class="n">updateSynthProb</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">,</span> <span class="n">kInfo</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

    <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;r_vector&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;r_columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G_col_name_to_index</span></div>



<div class="viewcode-block" id="fitLigandConcentrations">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.fitLigandConcentrations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fitLigandConcentrations</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Using the fit values of pPromoterBound, updates the set concentrations of</span>
<span class="sd">    ligand metabolites and the kd&#39;s of the ligand-TF binding reactions.</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - Fitted pPromoterBound: probabilities that a TF will bind to its promoter,</span>
<span class="sd">    fit by function fitPromoterBoundProbability().</span>

<span class="sd">    Inputs</span>
<span class="sd">    ------</span>
<span class="sd">    - cell_specs {condition (str): dict} - information about each condition</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - Set concentrations of metabolites that are ligands in 1CS</span>
<span class="sd">    - kd&#39;s of equilibrium reactions in 1CS</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cellDensity</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">cell_density</span>
    <span class="n">pPromoterBound</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">pPromoterBound</span>

    <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">):</span>
        <span class="c1"># Skip TFs that are not 1CS or are linked to genotypic perturbations</span>
        <span class="k">if</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">tf_to_tf_type</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;1CS&quot;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">[</span><span class="n">tf</span><span class="p">][</span>
                    <span class="s2">&quot;active genotype perturbations&quot;</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">[</span><span class="n">tf</span><span class="p">][</span>
                    <span class="s2">&quot;inactive genotype perturbations&quot;</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">activeKey</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__active&quot;</span>
        <span class="n">inactiveKey</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;__inactive&quot;</span>

        <span class="c1"># Determine if metabolite-bound form of the TF is the active form</span>
        <span class="n">boundId</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">active_to_bound</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span>
        <span class="n">negativeSignal</span> <span class="o">=</span> <span class="n">tf</span> <span class="o">!=</span> <span class="n">boundId</span>  <span class="c1"># True if unbound form is the active TF</span>

        <span class="c1"># Calculate kd of bound TF</span>
        <span class="n">fwdRate</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">get_fwd_rate</span><span class="p">(</span><span class="n">boundId</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">)</span>
        <span class="n">revRate</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">get_rev_rate</span><span class="p">(</span><span class="n">boundId</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">)</span>
        <span class="n">kd</span> <span class="o">=</span> <span class="n">revRate</span> <span class="o">/</span> <span class="n">fwdRate</span>

        <span class="c1"># Get the metabolite that binds to the TF and its stoich coefficient</span>
        <span class="n">metabolite</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">get_metabolite</span><span class="p">(</span><span class="n">boundId</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">)</span>
        <span class="n">metaboliteCoeff</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">get_metabolite_coeff</span><span class="p">(</span>
            <span class="n">boundId</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Calculate the concentrations of the metabolite under conditions where</span>
        <span class="c1"># TF is active and inactive</span>
        <span class="n">metabolite_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
            <span class="n">metabolite</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">[</span><span class="n">activeKey</span><span class="p">][</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">activeCellVolume</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cell_specs</span><span class="p">[</span><span class="n">activeKey</span><span class="p">][</span><span class="s2">&quot;avgCellDryMassInit&quot;</span><span class="p">]</span>
            <span class="o">/</span> <span class="n">cellDensity</span>
            <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">cell_dry_mass_fraction</span>
        <span class="p">)</span>
        <span class="n">activeCountsToMolar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span> <span class="o">*</span> <span class="n">activeCellVolume</span><span class="p">)</span>
        <span class="n">activeSignalConc</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">activeCountsToMolar</span>
            <span class="o">*</span> <span class="n">counts</span><span class="p">(</span><span class="n">cell_specs</span><span class="p">[</span><span class="n">activeKey</span><span class="p">][</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">],</span> <span class="n">metabolite_idx</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="n">inactiveCellVolume</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cell_specs</span><span class="p">[</span><span class="n">inactiveKey</span><span class="p">][</span><span class="s2">&quot;avgCellDryMassInit&quot;</span><span class="p">]</span>
            <span class="o">/</span> <span class="n">cellDensity</span>
            <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">cell_dry_mass_fraction</span>
        <span class="p">)</span>
        <span class="n">inactiveCountsToMolar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span> <span class="o">*</span> <span class="n">inactiveCellVolume</span><span class="p">)</span>
        <span class="n">inactiveSignalConc</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">inactiveCountsToMolar</span>
            <span class="o">*</span> <span class="n">counts</span><span class="p">(</span><span class="n">cell_specs</span><span class="p">[</span><span class="n">inactiveKey</span><span class="p">][</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">],</span> <span class="n">metabolite_idx</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>

        <span class="c1"># Update kd with fitted values of P and the bulk average concentrations</span>
        <span class="c1"># of the metabolite, and use this fitted kd to recalculate the set</span>
        <span class="c1"># amounts of the metabolite in metabolism</span>
        <span class="n">p_active</span> <span class="o">=</span> <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">activeKey</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span>
        <span class="n">p_inactive</span> <span class="o">=</span> <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">inactiveKey</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">negativeSignal</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p_inactive</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Inf ligand concentration from p_inactive = 0.&quot;</span>
                    <span class="s2">&quot; Check results from fitPromoterBoundProbability and Kd values.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p_active</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">:</span>
                <span class="n">kdNew</span> <span class="o">=</span> <span class="n">kd</span>  <span class="c1"># Concentration of metabolite-bound TF is negligible</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kdNew</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">activeSignalConc</span><span class="o">**</span><span class="n">metaboliteCoeff</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_active</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_active</span><span class="p">)</span>
                <span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">metaboliteCoeff</span><span class="p">)</span>

            <span class="c1"># Reset metabolite concentration with fitted P and kd</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span><span class="o">.</span><span class="n">concentration_updates</span><span class="o">.</span><span class="n">molecule_set_amounts</span><span class="p">[</span>
                <span class="n">metabolite</span>
            <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">kdNew</span><span class="o">**</span><span class="n">metaboliteCoeff</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_inactive</span><span class="p">)</span> <span class="o">/</span> <span class="n">p_inactive</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span>
                <span class="mf">1.0</span> <span class="o">/</span> <span class="n">metaboliteCoeff</span>
            <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p_active</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Inf ligand concentration from p_active = 1.&quot;</span>
                    <span class="s2">&quot; Check results from fitPromoterBoundProbability and Kd values.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">p_inactive</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">:</span>
                <span class="n">kdNew</span> <span class="o">=</span> <span class="n">kd</span>  <span class="c1"># Concentration of metabolite-bound TF is negligible</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kdNew</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">inactiveSignalConc</span><span class="o">**</span><span class="n">metaboliteCoeff</span><span class="p">)</span>
                    <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_inactive</span><span class="p">)</span>
                    <span class="o">/</span> <span class="n">p_inactive</span>
                <span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">metaboliteCoeff</span><span class="p">)</span>

            <span class="c1"># Reset metabolite concentration with fitted P and kd</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">metabolism</span><span class="o">.</span><span class="n">concentration_updates</span><span class="o">.</span><span class="n">molecule_set_amounts</span><span class="p">[</span>
                <span class="n">metabolite</span>
            <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">kdNew</span><span class="o">**</span><span class="n">metaboliteCoeff</span> <span class="o">*</span> <span class="n">p_active</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_active</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span>
                <span class="mf">1.0</span> <span class="o">/</span> <span class="n">metaboliteCoeff</span>
            <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>

        <span class="c1"># Fit reverse rate in line with fitted kd</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">set_rev_rate</span><span class="p">(</span><span class="n">boundId</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">,</span> <span class="n">kdNew</span> <span class="o">*</span> <span class="n">fwdRate</span><span class="p">)</span></div>



<div class="viewcode-block" id="calculatePromoterBoundProbability">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.calculatePromoterBoundProbability">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculatePromoterBoundProbability</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the probability that a transcription factor is bound to its</span>
<span class="sd">    associated promoter for all simulated growth conditions. The bulk</span>
<span class="sd">    average concentrations calculated for TFs and their ligands are used to</span>
<span class="sd">    compute the probabilities based on the type (0CS, 1CS, 2CS) of the TF.</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - Bulk average counts of transcription factors and associated ligands</span>
<span class="sd">    for each condition (in cell_specs)</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    - pPromoterBound: Probability that a transcription factor is bound to</span>
<span class="sd">    its promoter, per growth condition and TF. Each probability is indexed by</span>
<span class="sd">    pPromoterBound[condition][TF].</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pPromoterBound</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Initialize return value</span>
    <span class="n">cellDensity</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">cell_density</span>
    <span class="n">init_to_average</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_to_initial_cell_conversion_factor</span>

    <span class="c1"># Matrix to determine number of promoters each TF can bind to in a given condition</span>
    <span class="n">tf_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">tf</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">)}</span>
    <span class="n">cistron_id_to_tu_indexes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">cistron_id</span><span class="p">:</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_id_to_rna_indexes</span><span class="p">(</span><span class="n">cistron_id</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cistron_id</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">cistron_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="n">regulation_i</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">regulation_j</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">regulation_v</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tf</span><span class="p">,</span> <span class="n">cistrons</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_fold_change</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">tf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tf_idx</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">cistron</span> <span class="ow">in</span> <span class="n">cistrons</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tu_index</span> <span class="ow">in</span> <span class="n">cistron_id_to_tu_indexes</span><span class="p">[</span><span class="n">cistron</span><span class="p">]:</span>
                <span class="n">regulation_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf_idx</span><span class="p">[</span><span class="n">tf</span><span class="p">])</span>
                <span class="n">regulation_j</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tu_index</span><span class="p">)</span>
                <span class="n">regulation_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">regulation</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span>
        <span class="p">(</span><span class="n">regulation_v</span><span class="p">,</span> <span class="p">(</span><span class="n">regulation_i</span><span class="p">,</span> <span class="n">regulation_j</span><span class="p">)),</span>
        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tf_idx</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">)),</span>
    <span class="p">)</span>
    <span class="n">rna_coords</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;replication_coordinate&quot;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">conditionKey</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cell_specs</span><span class="p">):</span>
        <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">condition_to_doubling_time</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">min</span><span class="p">)</span>
        <span class="n">n_avg_copy</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">replication</span><span class="o">.</span><span class="n">get_average_copy_number</span><span class="p">(</span>
            <span class="n">tau</span><span class="p">,</span> <span class="n">rna_coords</span>
        <span class="p">)</span>
        <span class="n">n_promoter_targets</span> <span class="o">=</span> <span class="n">regulation</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">n_avg_copy</span><span class="p">)</span>

        <span class="n">cellVolume</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;avgCellDryMassInit&quot;</span><span class="p">]</span>
            <span class="o">/</span> <span class="n">cellDensity</span>
            <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">cell_dry_mass_fraction</span>
        <span class="p">)</span>
        <span class="n">countsToMolar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span> <span class="o">*</span> <span class="n">cellVolume</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">):</span>
            <span class="n">tfType</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">tf_to_tf_type</span><span class="p">[</span><span class="n">tf</span><span class="p">]</span>
            <span class="n">curr_tf_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
                <span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">tf_counts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span>
                <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">],</span> <span class="n">curr_tf_idx</span>
            <span class="p">)</span>
            <span class="n">tf_targets</span> <span class="o">=</span> <span class="n">n_promoter_targets</span><span class="p">[</span><span class="n">tf_idx</span><span class="p">[</span><span class="n">tf</span><span class="p">]]</span>
            <span class="n">limited_tf_counts</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">tf_counts</span> <span class="o">*</span> <span class="n">init_to_average</span> <span class="o">/</span> <span class="n">tf_targets</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tfType</span> <span class="o">==</span> <span class="s2">&quot;0CS&quot;</span><span class="p">:</span>
                <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">limited_tf_counts</span>  <span class="c1"># If TF exists, the promoter is always bound to the TF</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="n">tfType</span> <span class="o">==</span> <span class="s2">&quot;1CS&quot;</span><span class="p">:</span>
                <span class="n">boundId</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">active_to_bound</span><span class="p">[</span>
                    <span class="n">tf</span>
                <span class="p">]</span>  <span class="c1"># ID of TF bound to ligand</span>
                <span class="n">kd</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">get_rev_rate</span><span class="p">(</span>
                    <span class="n">boundId</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span>
                <span class="p">)</span> <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">get_fwd_rate</span><span class="p">(</span><span class="n">boundId</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span><span class="p">)</span>

                <span class="n">signal</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">get_metabolite</span><span class="p">(</span>
                    <span class="n">boundId</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span>
                <span class="p">)</span>  <span class="c1"># ID of ligand that binds to TF</span>
                <span class="n">signalCoeff</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">get_metabolite_coeff</span><span class="p">(</span>
                    <span class="n">boundId</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span>
                <span class="p">)</span>  <span class="c1"># Stoichiometric coefficient of ligand</span>

                <span class="c1"># Get bulk average concentrations of ligand and TF</span>
                <span class="n">signal_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
                    <span class="n">signal</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">signalConc</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">countsToMolar</span>
                    <span class="o">*</span> <span class="n">counts</span><span class="p">(</span>
                        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">],</span> <span class="n">signal_idx</span>
                    <span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
                <span class="n">tfConc</span> <span class="o">=</span> <span class="p">(</span><span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">tf_counts</span><span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>

                <span class="c1"># If TF is active in its bound state</span>
                <span class="k">if</span> <span class="n">tf</span> <span class="o">==</span> <span class="n">boundId</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tfConc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">limited_tf_counts</span>
                            <span class="o">*</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">p_promoter_bound_SKd</span><span class="p">(</span>
                                <span class="n">signalConc</span><span class="p">,</span> <span class="n">kd</span><span class="p">,</span> <span class="n">signalCoeff</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="c1"># If TF is active in its unbound state</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tfConc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="mf">1.0</span>
                            <span class="o">-</span> <span class="n">limited_tf_counts</span>
                            <span class="o">*</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span><span class="o">.</span><span class="n">p_promoter_bound_SKd</span><span class="p">(</span>
                                <span class="n">signalConc</span><span class="p">,</span> <span class="n">kd</span><span class="p">,</span> <span class="n">signalCoeff</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">elif</span> <span class="n">tfType</span> <span class="o">==</span> <span class="s2">&quot;2CS&quot;</span><span class="p">:</span>
                <span class="c1"># Get bulk average concentrations of active and inactive TF</span>
                <span class="n">activeTfConc</span> <span class="o">=</span> <span class="p">(</span><span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">tf_counts</span><span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
                <span class="n">inactiveTf</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">two_component_system</span><span class="o">.</span><span class="n">active_to_inactive_tf</span><span class="p">[</span>
                        <span class="n">tf</span> <span class="o">+</span> <span class="s2">&quot;[c]&quot;</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="n">inactive_tf_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
                    <span class="n">inactiveTf</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">][</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">inactiveTfConc</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">countsToMolar</span>
                    <span class="o">*</span> <span class="n">counts</span><span class="p">(</span>
                        <span class="n">cell_specs</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="s2">&quot;bulkAverageContainer&quot;</span><span class="p">],</span>
                        <span class="n">inactive_tf_idx</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">activeTfConc</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">inactiveTfConc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pPromoterBound</span><span class="p">[</span><span class="n">conditionKey</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">limited_tf_counts</span>
                        <span class="o">*</span> <span class="n">activeTfConc</span>
                        <span class="o">/</span> <span class="p">(</span><span class="n">activeTfConc</span> <span class="o">+</span> <span class="n">inactiveTfConc</span><span class="p">)</span>
                    <span class="p">)</span>

    <span class="c1"># Check for any inconsistencies that could lead to feasbility issues when fitting</span>
    <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">pPromoterBound</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;inactive&quot;</span> <span class="ow">in</span> <span class="n">condition</span><span class="p">:</span>
            <span class="n">tf</span> <span class="o">=</span> <span class="n">condition</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">active_p</span> <span class="o">=</span> <span class="n">pPromoterBound</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tf</span><span class="si">}</span><span class="s2">__active&quot;</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span>
            <span class="n">inactive_p</span> <span class="o">=</span> <span class="n">pPromoterBound</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tf</span><span class="si">}</span><span class="s2">__inactive&quot;</span><span class="p">][</span><span class="n">tf</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">inactive_p</span> <span class="o">&gt;=</span> <span class="n">active_p</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Warning: active condition does not have higher binding&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; probability than inactive condition for </span><span class="si">{</span><span class="n">tf</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">active_p</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">inactive_p</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>

    <span class="k">return</span> <span class="n">pPromoterBound</span></div>



<div class="viewcode-block" id="calculateRnapRecruitment">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.calculateRnapRecruitment">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">calculateRnapRecruitment</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">cell_specs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs the basal_prob vector and delta_prob matrix from values of r.</span>
<span class="sd">    The basal_prob vector holds the basal transcription probabilities of each</span>
<span class="sd">    transcription unit. The delta_prob matrix holds the differences in</span>
<span class="sd">    transcription probabilities when transcription factors bind to the</span>
<span class="sd">    promoters of each transcription unit. Both values are stored in sim_data.</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - cell_specs[&#39;basal&#39;]:</span>
<span class="sd">            - [&#39;r_vector&#39;]: Fit parameters on how the recruitment of a TF affects the expression</span>
<span class="sd">            of a gene. High (positive) values of r indicate that the TF binding</span>
<span class="sd">            increases the probability that the gene is expressed.</span>
<span class="sd">            - [&#39;r_columns&#39;]: mapping of column name to index in r</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - Rescales values in basal_prob such that all values are positive</span>
<span class="sd">    - Adds basal_prob and delta_prob arrays to sim_data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;r_vector&quot;</span><span class="p">]</span>
    <span class="n">col_names_to_index</span> <span class="o">=</span> <span class="n">cell_specs</span><span class="p">[</span><span class="s2">&quot;basal&quot;</span><span class="p">][</span><span class="s2">&quot;r_columns&quot;</span><span class="p">]</span>

    <span class="c1"># Get list of transcription units and TF IDs</span>
    <span class="n">transcription</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span>
    <span class="n">transcription_regulation</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription_regulation</span>
    <span class="n">all_TUs</span> <span class="o">=</span> <span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">all_tfs</span> <span class="o">=</span> <span class="n">transcription_regulation</span><span class="o">.</span><span class="n">tf_ids</span>

    <span class="c1"># Initialize basal_prob vector and delta_prob sparse matrix</span>
    <span class="n">basal_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_TUs</span><span class="p">))</span>
    <span class="n">deltaI</span><span class="p">,</span> <span class="n">deltaJ</span><span class="p">,</span> <span class="n">deltaV</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">rna_idx</span><span class="p">,</span> <span class="n">rnaId</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_TUs</span><span class="p">):</span>
        <span class="n">rnaIdNoLoc</span> <span class="o">=</span> <span class="n">rnaId</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># Remove compartment ID from RNA ID</span>

        <span class="c1"># Take only those TFs with active/inactive conditions data</span>
        <span class="k">for</span> <span class="n">tf</span> <span class="ow">in</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">relation</span><span class="o">.</span><span class="n">rna_id_to_regulating_tfs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rnaId</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="n">tf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">tf_to_active_inactive_conditions</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">colName</span> <span class="o">=</span> <span class="n">rnaIdNoLoc</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">tf</span>

            <span class="c1"># Set element in delta to value in r that corresponds to the</span>
            <span class="c1"># transcription unit of the row, and the TF of the column</span>
            <span class="n">deltaI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rna_idx</span><span class="p">)</span>
            <span class="n">deltaJ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_tfs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">tf</span><span class="p">))</span>
            <span class="n">deltaV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">col_names_to_index</span><span class="p">[</span><span class="n">colName</span><span class="p">]])</span>

        <span class="c1"># Add alpha column for each RNA</span>
        <span class="n">colName</span> <span class="o">=</span> <span class="n">rnaIdNoLoc</span> <span class="o">+</span> <span class="s2">&quot;__alpha&quot;</span>

        <span class="c1"># Set element in basal_prob to the transcription unit&#39;s value for alpha</span>
        <span class="n">basal_prob</span><span class="p">[</span><span class="n">rna_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">col_names_to_index</span><span class="p">[</span><span class="n">colName</span><span class="p">]]</span>

    <span class="c1"># Convert to arrays</span>
    <span class="n">deltaI</span><span class="p">,</span> <span class="n">deltaJ</span><span class="p">,</span> <span class="n">deltaV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">deltaI</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">deltaJ</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">deltaV</span><span class="p">)</span>
    <span class="n">delta_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_TUs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_tfs</span><span class="p">))</span>

    <span class="c1"># Adjust any negative basal probabilities to 0</span>
    <span class="n">basal_prob</span><span class="p">[</span><span class="n">basal_prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Add basal_prob vector and delta_prob matrix to sim_data</span>
    <span class="n">transcription_regulation</span><span class="o">.</span><span class="n">basal_prob</span> <span class="o">=</span> <span class="n">basal_prob</span>
    <span class="n">transcription_regulation</span><span class="o">.</span><span class="n">delta_prob</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;deltaI&quot;</span><span class="p">:</span> <span class="n">deltaI</span><span class="p">,</span>
        <span class="s2">&quot;deltaJ&quot;</span><span class="p">:</span> <span class="n">deltaJ</span><span class="p">,</span>
        <span class="s2">&quot;deltaV&quot;</span><span class="p">:</span> <span class="n">deltaV</span><span class="p">,</span>
        <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="n">delta_shape</span><span class="p">,</span>
    <span class="p">}</span></div>



<div class="viewcode-block" id="crc32">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.crc32">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">crc32</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">initial</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a CRC32 checksum of the given ndarrays.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">crc_next</span><span class="p">(</span><span class="n">initial</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">binascii</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">binascii</span><span class="o">.</span><span class="n">crc32</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">initial</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">crc_next</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">initial</span><span class="p">)</span></div>



<div class="viewcode-block" id="setKmCooperativeEndoRNonLinearRNAdecay">
<a class="viewcode-back" href="../../../reference/api/reconstruction/reconstruction.ecoli.fit_sim_data_1.html#reconstruction.ecoli.fit_sim_data_1.setKmCooperativeEndoRNonLinearRNAdecay">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">setKmCooperativeEndoRNonLinearRNAdecay</span><span class="p">(</span><span class="n">sim_data</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">,</span> <span class="n">cache_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits the affinities (Michaelis-Menten constants) for RNAs binding to</span>
<span class="sd">    endoRNAses.</span>

<span class="sd">    EndoRNAses perform the first step of RNA decay by cleaving a whole RNA</span>
<span class="sd">    somewhere inside its extent.  This results in RNA fragments, which are then</span>
<span class="sd">    digested into monomers by exoRNAses. To model endoRNAse activity, we need to</span>
<span class="sd">    determine an affinity (Michaelis-Menten constant) for each RNA that is</span>
<span class="sd">    consistent with experimentally observed half-lives.  The Michaelis-Menten</span>
<span class="sd">    constants must be determined simultaneously, as the RNAs must compete for</span>
<span class="sd">    the active site of the endoRNAse. (See the RnaDegradation Process class for</span>
<span class="sd">    more information about the dynamical model.) The parameters are estimated</span>
<span class="sd">    using a root solver (scipy.optimize.fsolve).  (See the</span>
<span class="sd">    sim_data.process.rna_decay.kmLossFunction method for more information about</span>
<span class="sd">    the optimization problem.)</span>

<span class="sd">    Requires</span>
<span class="sd">    --------</span>
<span class="sd">    - cell density, dry mass fraction, and average initial dry mass</span>
<span class="sd">            Used to calculate the cell volume, which in turn is used to calculate</span>
<span class="sd">            concentrations.</span>
<span class="sd">    - observed RNA degradation rates (half-lives)</span>
<span class="sd">    - endoRNAse counts</span>
<span class="sd">    - endoRNAse catalytic rate constants</span>
<span class="sd">    - RNA counts</span>
<span class="sd">    - boolean options that enable sensitivity analyses (see Notes below)</span>

<span class="sd">    Modifies</span>
<span class="sd">    --------</span>
<span class="sd">    - Michaelis-Menten constants for first-order decay (initially set to zeros)</span>
<span class="sd">    - Several optimization-related values</span>
<span class="sd">            Sensitivity analyses (optional, see Notes below)</span>
<span class="sd">            Terminal values for optimization-related functions</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    - enoRNAse Km values, in units of M</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If certain options are set, a sensitivity analysis will be performed using a</span>
<span class="sd">    range of metaparameters. Outputs will be cached and utilized instead of</span>
<span class="sd">    running the optimization if possible.</span>
<span class="sd">    The function that generates the optimization functions is defined under</span>
<span class="sd">    sim_data but has no dependency on sim_data, and therefore could be moved</span>
<span class="sd">    here or elsewhere. (TODO)</span>

<span class="sd">    TODO (John): Refactor as a pure function.</span>
<span class="sd">    TODO (John): Why is this function called &#39;cooperative&#39;?  It seems to instead</span>
<span class="sd">            assume and model competitive binding.</span>
<span class="sd">    TODO (John): Determine what part (if any) of the &#39;linear&#39; parameter fitting</span>
<span class="sd">            should be retained.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">arrays_differ</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">cellDensity</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">cell_density</span>
    <span class="n">cellVolume</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">avg_cell_dry_mass_init</span>
        <span class="o">/</span> <span class="n">cellDensity</span>
        <span class="o">/</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">mass</span><span class="o">.</span><span class="n">cell_dry_mass_fraction</span>
    <span class="p">)</span>
    <span class="n">countsToMolar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">n_avogadro</span> <span class="o">*</span> <span class="n">cellVolume</span><span class="p">)</span>

    <span class="n">degradable_rna_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">mature_rna_data</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">degradation_rates</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">rna_data</span><span class="p">[</span><span class="s2">&quot;deg_rate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span><span class="p">),</span>
            <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">transcription</span><span class="o">.</span><span class="n">mature_rna_data</span><span class="p">[</span><span class="s2">&quot;deg_rate&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span>
                <span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span>
            <span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">endoRNase_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">endoRNase_ids</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">endoRNaseConc</span> <span class="o">=</span> <span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">endoRNase_idx</span><span class="p">)</span>
    <span class="n">kcatEndoRNase</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">kcats</span>
    <span class="n">totalEndoRnaseCapacity</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">endoRNaseConc</span> <span class="o">*</span> <span class="n">kcatEndoRNase</span><span class="p">)</span>

    <span class="n">endoRnaseRnaIds</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">molecule_groups</span><span class="o">.</span><span class="n">endoRNase_rnas</span>
    <span class="n">isEndoRnase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">endoRnaseRnaIds</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">degradable_rna_ids</span><span class="p">])</span>

    <span class="n">degradable_rna_idx</span> <span class="o">=</span> <span class="n">bulk_name_to_idx</span><span class="p">(</span><span class="n">degradable_rna_ids</span><span class="p">,</span> <span class="n">bulkContainer</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">rna_counts</span> <span class="o">=</span> <span class="n">counts</span><span class="p">(</span><span class="n">bulkContainer</span><span class="p">,</span> <span class="n">degradable_rna_idx</span><span class="p">)</span>
    <span class="n">rna_conc</span> <span class="o">=</span> <span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">rna_counts</span>
    <span class="n">Km_counts</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="n">degradation_rates</span> <span class="o">*</span> <span class="n">totalEndoRnaseCapacity</span><span class="p">)</span> <span class="o">-</span> <span class="n">rna_conc</span><span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">Km_first_order_decay</span> <span class="o">=</span> <span class="n">Km_counts</span>

    <span class="c1"># Residuals can be written as follows: Res = f(Km) = 0, then Km = g(Km)</span>
    <span class="c1"># Compute derivative g(Km) in counts:</span>
    <span class="n">KmQuadratic</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">Km_counts</span><span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rna_counts</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">Km_counts</span><span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()),</span> <span class="mi">2</span>
    <span class="p">)</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">totalEndoRnaseCapacity</span><span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">denominator</span> <span class="o">-</span> <span class="p">(</span><span class="n">rna_counts</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">countsToMolar</span> <span class="o">*</span> <span class="n">Km_counts</span><span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">())</span>
    <span class="p">)</span>
    <span class="n">gDerivative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">KmQuadratic</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Max derivative (counts) = </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">max</span><span class="p">(</span><span class="n">gDerivative</span><span class="p">))</span>

    <span class="c1"># Compute derivative g(Km) in concentrations:</span>
    <span class="n">KmQuadratic</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">Km_counts</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rna_conc</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span> <span class="o">/</span> <span class="n">Km_counts</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="n">totalEndoRnaseCapacity</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span>
        <span class="n">denominator</span> <span class="o">-</span> <span class="p">(</span><span class="n">rna_conc</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span> <span class="o">/</span> <span class="n">Km_counts</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">gDerivative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">KmQuadratic</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Max derivative (concentration) = </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">max</span><span class="p">(</span><span class="n">gDerivative</span><span class="p">))</span>

    <span class="c1"># Sensitivity analysis: alpha (regularization term)</span>
    <span class="n">Alphas</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">sensitivity_analysis_alpha</span><span class="p">:</span>
        <span class="n">Alphas</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

    <span class="n">total_endo_rnase_capacity_mol_l_s</span> <span class="o">=</span> <span class="n">totalEndoRnaseCapacity</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span>
        <span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span>
    <span class="p">)</span>
    <span class="n">rna_conc_mol_l</span> <span class="o">=</span> <span class="n">rna_conc</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
    <span class="n">degradation_rates_s</span> <span class="o">=</span> <span class="n">degradation_rates</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">Alphas</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Alpha = </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">alpha</span><span class="p">)</span>

        <span class="n">loss</span><span class="p">,</span> <span class="n">loss_jac</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">res_aux</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">km_loss_function</span><span class="p">(</span>
            <span class="n">total_endo_rnase_capacity_mol_l_s</span><span class="p">,</span>
            <span class="n">rna_conc_mol_l</span><span class="p">,</span>
            <span class="n">degradation_rates_s</span><span class="p">,</span>
            <span class="n">isEndoRnase</span><span class="p">,</span>
            <span class="n">alpha</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">Km_cooperative_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Km_counts</span><span class="p">),</span> <span class="n">jac</span><span class="o">=</span><span class="n">loss_jac</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>
        <span class="p">)</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">sensitivity_analysis_alpha_residual</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res_aux</span><span class="p">(</span><span class="n">Km_cooperative_model</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>

    <span class="c1"># Sensitivity analysis: kcatEndoRNase</span>
    <span class="n">kcatEndo</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">sensitivity_analysis_kcat_endo</span><span class="p">:</span>
        <span class="n">kcatEndo</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">kcat</span> <span class="ow">in</span> <span class="n">kcatEndo</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Kcat = </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">kcat</span><span class="p">)</span>

        <span class="n">totalEndoRNcap</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">endoRNaseConc</span> <span class="o">*</span> <span class="n">kcat</span><span class="p">)</span>
        <span class="n">loss</span><span class="p">,</span> <span class="n">loss_jac</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">res_aux</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">km_loss_function</span><span class="p">(</span>
            <span class="n">totalEndoRNcap</span><span class="o">.</span><span class="n">asNumber</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span><span class="p">),</span>
            <span class="n">rna_conc_mol_l</span><span class="p">,</span>
            <span class="n">degradation_rates_s</span><span class="p">,</span>
            <span class="n">isEndoRnase</span><span class="p">,</span>
            <span class="n">alpha</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">km_counts_ini</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">totalEndoRNcap</span> <span class="o">/</span> <span class="n">degradation_rates</span><span class="o">.</span><span class="n">asNumber</span><span class="p">())</span> <span class="o">-</span> <span class="n">rna_conc</span>
        <span class="p">)</span><span class="o">.</span><span class="n">asNumber</span><span class="p">()</span>
        <span class="n">Km_cooperative_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>
            <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">km_counts_ini</span><span class="p">),</span> <span class="n">jac</span><span class="o">=</span><span class="n">loss_jac</span><span class="p">)</span><span class="o">.</span><span class="n">x</span>
        <span class="p">)</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">sensitivity_analysis_kcat</span><span class="p">[</span><span class="n">kcat</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Km_cooperative_model</span>
        <span class="p">)</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">sensitivity_analysis_kcat_res_ini</span><span class="p">[</span><span class="n">kcat</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res_aux</span><span class="p">(</span><span class="n">km_counts_ini</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">sensitivity_analysis_kcat_res_opt</span><span class="p">[</span><span class="n">kcat</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res_aux</span><span class="p">(</span><span class="n">Km_cooperative_model</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="c1"># Loss function, and derivative</span>
    <span class="n">loss</span><span class="p">,</span> <span class="n">loss_jac</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">res_aux</span> <span class="o">=</span> <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">km_loss_function</span><span class="p">(</span>
        <span class="n">total_endo_rnase_capacity_mol_l_s</span><span class="p">,</span>
        <span class="n">rna_conc_mol_l</span><span class="p">,</span>
        <span class="n">degradation_rates_s</span><span class="p">,</span>
        <span class="n">isEndoRnase</span><span class="p">,</span>
        <span class="n">alpha</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># The checksum in the filename picks independent caches for distinct cases</span>
    <span class="c1"># such as different Parca options or Parca code in different git branches.</span>
    <span class="c1"># `make clean` will delete the cache files.</span>
    <span class="n">needToUpdate</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">checksum</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">Km_counts</span><span class="p">,</span> <span class="n">isEndoRnase</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>
    <span class="n">km_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;parca-km-</span><span class="si">{</span><span class="n">checksum</span><span class="si">}</span><span class="s2">.cPickle&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">km_filepath</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">km_filepath</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">Km_cache</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># KmCooperativeModel fits a set of Km values to give the expected degradation rates.</span>
        <span class="c1"># It takes 1.5 - 3 minutes to recompute.</span>
        <span class="c1"># R_aux calculates the difference of the degradation rate based on these</span>
        <span class="c1"># Km values and the expected rate so this sum seems like a good test of</span>
        <span class="c1"># whether the cache fits current input data, but cross-check additional</span>
        <span class="c1"># inputs to avoid Issue #996.</span>
        <span class="n">Km_cooperative_model</span> <span class="o">=</span> <span class="n">Km_cache</span><span class="p">[</span><span class="s2">&quot;Km_cooperative_model&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">Km_counts</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Km_cooperative_model</span><span class="o">.</span><span class="n">shape</span>
            <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res_aux</span><span class="p">(</span><span class="n">Km_cooperative_model</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mf">1e-15</span>
            <span class="ow">or</span> <span class="n">arrays_differ</span><span class="p">(</span>
                <span class="n">Km_cache</span><span class="p">[</span><span class="s2">&quot;total_endo_rnase_capacity_mol_l_s&quot;</span><span class="p">],</span>
                <span class="n">total_endo_rnase_capacity_mol_l_s</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="ow">or</span> <span class="n">arrays_differ</span><span class="p">(</span><span class="n">Km_cache</span><span class="p">[</span><span class="s2">&quot;rna_conc_mol_l&quot;</span><span class="p">],</span> <span class="n">rna_conc_mol_l</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">arrays_differ</span><span class="p">(</span><span class="n">Km_cache</span><span class="p">[</span><span class="s2">&quot;degradation_rates_s&quot;</span><span class="p">],</span> <span class="n">degradation_rates_s</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">needToUpdate</span> <span class="o">=</span> <span class="s2">&quot;recompute&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">needToUpdate</span> <span class="o">=</span> <span class="s2">&quot;compute&quot;</span>

    <span class="k">if</span> <span class="n">needToUpdate</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running non-linear optimization to </span><span class="si">{</span><span class="n">needToUpdate</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">km_filepath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Km_counts</span><span class="p">),</span> <span class="n">jac</span><span class="o">=</span><span class="n">loss_jac</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
        <span class="n">Km_cooperative_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">Km_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">Km_cooperative_model</span><span class="o">=</span><span class="n">Km_cooperative_model</span><span class="p">,</span>
            <span class="n">total_endo_rnase_capacity_mol_l_s</span><span class="o">=</span><span class="n">total_endo_rnase_capacity_mol_l_s</span><span class="p">,</span>
            <span class="n">rna_conc_mol_l</span><span class="o">=</span><span class="n">rna_conc_mol_l</span><span class="p">,</span>
            <span class="n">degradation_rates_s</span><span class="o">=</span><span class="n">degradation_rates_s</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">km_filepath</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">Km_cache</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Not running non-linear optimization--using cached result </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">km_filepath</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="c1"># Calculate log Km for loss functions</span>
    <span class="n">log_Km_cooperative_model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Km_cooperative_model</span><span class="p">)</span>
    <span class="n">log_Km_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Km_counts</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">VERBOSE</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loss function (Km inital) = </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">loss</span><span class="p">(</span><span class="n">log_Km_counts</span><span class="p">))))</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Loss function (optimized Km) = </span><span class="si">%f</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">loss</span><span class="p">(</span><span class="n">log_Km_cooperative_model</span><span class="p">)))</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Residuals (Km initial) = </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res</span><span class="p">(</span><span class="n">Km_counts</span><span class="p">))))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Residuals optimized = </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res</span><span class="p">(</span><span class="n">Km_cooperative_model</span><span class="p">))))</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;EndoR residuals (Km initial) = </span><span class="si">%f</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">isEndoRnase</span> <span class="o">*</span> <span class="n">res</span><span class="p">(</span><span class="n">Km_counts</span><span class="p">)))</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;EndoR residuals optimized = </span><span class="si">%f</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">isEndoRnase</span> <span class="o">*</span> <span class="n">res</span><span class="p">(</span><span class="n">Km_cooperative_model</span><span class="p">)))</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Residuals (scaled by Kdeg * RNAcounts) Km initial = </span><span class="si">%f</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res_aux</span><span class="p">(</span><span class="n">Km_counts</span><span class="p">)))</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Residuals (scaled by Kdeg * RNAcounts) optimized = </span><span class="si">%f</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res_aux</span><span class="p">(</span><span class="n">Km_cooperative_model</span><span class="p">)))</span>
        <span class="p">)</span>

    <span class="c1"># Save statistics KM optimization</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">stats_fit</span><span class="p">[</span><span class="s2">&quot;LossKm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">loss</span><span class="p">(</span><span class="n">log_Km_counts</span><span class="p">)))</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">stats_fit</span><span class="p">[</span><span class="s2">&quot;LossKmOpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">loss</span><span class="p">(</span><span class="n">log_Km_cooperative_model</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">stats_fit</span><span class="p">[</span><span class="s2">&quot;ResKm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res</span><span class="p">(</span><span class="n">Km_counts</span><span class="p">)))</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">stats_fit</span><span class="p">[</span><span class="s2">&quot;ResKmOpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res</span><span class="p">(</span><span class="n">Km_cooperative_model</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">stats_fit</span><span class="p">[</span><span class="s2">&quot;ResEndoRNKm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">isEndoRnase</span> <span class="o">*</span> <span class="n">res</span><span class="p">(</span><span class="n">Km_counts</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">stats_fit</span><span class="p">[</span><span class="s2">&quot;ResEndoRNKmOpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">isEndoRnase</span> <span class="o">*</span> <span class="n">res</span><span class="p">(</span><span class="n">Km_cooperative_model</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">stats_fit</span><span class="p">[</span><span class="s2">&quot;ResScaledKm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res_aux</span><span class="p">(</span><span class="n">Km_counts</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">sim_data</span><span class="o">.</span><span class="n">process</span><span class="o">.</span><span class="n">rna_decay</span><span class="o">.</span><span class="n">stats_fit</span><span class="p">[</span><span class="s2">&quot;ResScaledKmOpt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res_aux</span><span class="p">(</span><span class="n">Km_cooperative_model</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">units</span><span class="o">.</span><span class="n">mol</span> <span class="o">/</span> <span class="n">units</span><span class="o">.</span><span class="n">L</span> <span class="o">*</span> <span class="n">Km_cooperative_model</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2026, The Vivarium E. coli Authors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>