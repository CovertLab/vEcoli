# The flat file should be: Binding site name, TF names, TU names
# So like: purR, reg_0001, purR; purR, reg_0002, purC.

import csv
import io
import itertools
import os
import time

from wholecell.io import tsv
from wholecell.utils.filepath import ROOT_PATH

FILE_LOCATION = os.path.realpath(os.path.dirname(__file__))
DATA_DIR = os.path.join(FILE_LOCATION, "data")

# Files
PROMOTERS_FILE = os.path.join(
    DATA_DIR, "ecocyc_promoters.tsv"
)
TF_BINDING_SITES_FILE = os.path.join(
    DATA_DIR, "ecocyc_tf_binding_sites.tsv"
)

OUTPUT_FLAT_FILE = os.path.join(
    ROOT_PATH, "reconstruction", "ecoli", "flat", "tf_binding_sites.tsv"
)

def read_promoters_table():
    promoters = []
    tus = []
    regs = []

    with open(PROMOTERS_FILE, 'rb') as f:
        reader = tsv.reader(f)

        headers = next(reader)
        promoters_index = headers.index("Promoter Name")
        tu_index = headers.index("Component-Of")
        reg_index = headers.index("Regulated-By")

        for line in reader:
            promoters.append(line[promoters_index])
            tu_list = []
            for comp in line[tu_index].split(' // '):
                if comp[:2] == 'TU':
                    tu_list.append(comp)
            tus.append(tu_list)
            reg = line[reg_index]
            if len(reg) > 0:
                regs.append(reg.split(' // '))
            else:
                regs.append([])

    # Only three regs don't have associated TUs, and these three regs aren't found in
    # ecocyc_tf_binding_sites.tsv. So, every reg in ecocyc_tf_binding_sites.tsv has at least one associated
    # TU.
    regs_without_tus = []
    for tu, reg in zip(tus, regs):
        if len(reg) > 0:
            if len(tu) == 0:
                regs_without_tus.append(reg)

    return promoters, tus, regs

def read_tf_binding_sites_table():
    binding_sites = []
    positions = []
    regs = []
    # reg_entities is usually a promoter, but sometimes a TU or a gene
    reg_entities = []
    tfs = []

    with open(TF_BINDING_SITES_FILE, 'rb') as f:
        reader = tsv.reader(f)

        headers = next(reader)
        binding_site_index = headers.index("Transcription Factor Binding Sites")
        position_index = headers.index("Abs-Center-Pos")
        reg_index = headers.index("Involved-In-Regulation")
        reg_entities_index = headers.index("Regulated-Entity")
        tf_index = headers.index("Regulator")

        for line in reader:
            binding_sites.append(line[binding_site_index])
            pos = line[position_index]
            if len(pos) > 0:
                if pos[-2:] == 'd0':
                    pos = pos[:-2]
                positions.append(float(pos))
            else:
                positions.append(None)

            reg = line[reg_index]
            if len(reg) > 0:
                regs.append(reg.split(' // '))
            else:
                regs.append([])

            entity = line[reg_entities_index]
            if len(entity) > 0:
                reg_entities.append(entity.split(' // '))
            else:
                reg_entities.append([])

            tf = line[tf_index]
            if len(tf) > 0:
                tfs.append(tf.split(' // '))
            else:
                tfs.append([])


    return binding_sites, positions, regs, reg_entities, tfs

def build_tf_binding_sites_table(binding_sites, binding_positions, binding_reg_entities, binding_tfs, promoters, promoter_tus):
    binding_tus_or_genes = []

    promoter_to_tus = {p: tu for p, tu in zip(promoters, promoter_tus)}
    for entity_list in binding_reg_entities:
        tus_or_genes = set()
        for x in entity_list:
            tus_or_genes.update(promoter_to_tus.get(x, [x]))
        tus_or_genes = list(tus_or_genes)
        tus_or_genes.sort(key=lambda v: v[0])
        binding_tus_or_genes.append(tus_or_genes)

    binding_positions_rounded = []
    for pos in binding_positions:
        if pos is not None:
            binding_positions_rounded.append(round(pos))
        else:
            binding_positions_rounded.append('')

    def convert_list_to_string(input):
        #goal: list of strings: [a, b] -> '["a", "b"]
        output = '["'
        for a in input[:-1]:
            output += a
            output += '", "'
        output += input[-1]
        output += '"]'
        return output

    # Write to flat file
    with io.open(OUTPUT_FLAT_FILE, "wb") as f:
        print("Writing to {}".format(f.name))
        writer = tsv.writer(f, quotechar="'", lineterminator="\n")
        writer.writerow(["# Generated by {} on {}".format(__file__, time.ctime())])
        writer.writerow(['"binding_site_id"', '"coordinates"', '"binding_TFs"', '"regulated_TUs_or_genes"'])

        for row in zip(binding_sites, binding_positions_rounded, binding_tfs, binding_tus_or_genes):
            writer.writerow([f'"{row[0]}"', f'{row[1]}', convert_list_to_string(row[2]), convert_list_to_string(row[3])])


if __name__ == "__main__":
    # So we have a list of all tfs and all regs.
    # We also have a list of all binding sites, which corresponds to many tfs and many regs.
    # A question is, does every reg from the tfs file, is that represented with a binding site?
    # So now, we take all regs that are both in the tfs file (corresponding to a tf) and with binding sites
    # (corresponding to tfs, promoters, and a binding site).
    # So we can just say, for each binding site, there's a tf-name(s), and tu-name(s). and TFs can bind to them.
    # We can treat regulations separately, since we're modeling them differently, not through these.
    promoters, promoter_tus, _ = read_promoters_table()
    binding_sites, binding_positions, _, binding_reg_entities, binding_tfs = read_tf_binding_sites_table()

    build_tf_binding_sites_table(binding_sites, binding_positions, binding_reg_entities, binding_tfs,
                                 promoters, promoter_tus)
