

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stores &mdash; Vivarium E. coli 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=8d563738"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Processes" href="processes.html" />
    <link rel="prev" title="Welcome to Vivarium E. coli’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Vivarium E. coli
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Stores</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#bulk-molecules">Bulk Molecules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#initialization">Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partitioning">Partitioning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#motivation">Motivation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#steps-and-flows">Steps and Flows</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-non-partitioned-counts">Accessing Non-Partitioned Counts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#indexing">Indexing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#unique-molecules">Unique Molecules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing">Accessing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#listeners">Listeners</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">Initialization</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="composites.html">Composites</a></li>
<li class="toctree-l1"><a class="reference internal" href="experiments.html">Experiments</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflows.html">Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="docs.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="hpc.html">HPC Clusters</a></li>
<li class="toctree-l1"><a class="reference internal" href="gcloud.html">Google Cloud</a></li>
<li class="toctree-l1"><a class="reference internal" href="ci.html">Continuous Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="pycharm.html">PyCharm Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference/api_ref.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Vivarium E. coli</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Stores</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/stores.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="stores">
<h1>Stores<a class="headerlink" href="#stores" title="Link to this heading"></a></h1>
<p>Stores are upgraded dictionaries that store the simulation state. They can
be nested within one another to form a store hierarchy. The core stores in
vEcoli comprise the following simplified store hierarchy:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">bulk</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unique</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">active_replisomes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">active_ribosome</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">active_RNAPs</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">chromosome_domains</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">chromosomal_segments</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">full_chromosomes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DnaA_boxes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">genes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">oriCs</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">promoters</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">RNAs</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">listeners</span></code></p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">mass</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dry_mass</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cell_mass</span></code></p></li>
<li><p>…</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">replication_data</span></code></p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fork_coordinates</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fork_domains</span></code></p></li>
<li><p>…</p></li>
</ul>
</div></blockquote>
</li>
<li><p>…</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>Individual stores in this hierarchy are identified using tuples representing
their path inside the nested hierarchy. For example, the dry mass listener store
has the tuple path <code class="docutils literal notranslate"><span class="pre">(&quot;listeners&quot;,</span> <span class="pre">&quot;mass&quot;,</span> <span class="pre">&quot;dry_mass&quot;)</span></code>. There are three top-level
stores corresponding to the three main types of simulation data: bulk, unique, and
listeners. The following sections provide descriptions for each of these store types
prefaced by a series of relevant attributes including:</p>
<dl class="field-list simple">
<dt class="field-odd">Path<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple path of the store (e.g. for use in process topologies)</p>
</dd>
<dt class="field-even">Updater<span class="colon">:</span></dt>
<dd class="field-even"><p>Function used to apply updates to the store. Click on the linked API
documentation to see the format that updates to the store must be given in.</p>
</dd>
<dt class="field-odd">Divider<span class="colon">:</span></dt>
<dd class="field-odd"><p>Function used to split the store during cell division</p>
</dd>
<dt class="field-even">Serializer<span class="colon">:</span></dt>
<dd class="field-even"><p>Instance of <a class="reference external" href="https://vivarium-core.readthedocs.io/en/latest/reference/api/vivarium.core.registry.html#vivarium.core.registry.Serializer" title="(in Vivarium Core vv1.5.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">vivarium.core.registry.Serializer</span></code></a>
used to serialize store data before being emitted (see <a class="reference internal" href="output.html#serializing-emits"><span class="std std-ref">Serializing Emits</span></a>)</p>
</dd>
<dt class="field-odd">Schema<span class="colon">:</span></dt>
<dd class="field-odd"><p>Helper function to create store schema in process <code class="docutils literal notranslate"><span class="pre">ports_schema</span></code> methods</p>
</dd>
<dt class="field-even">Helpers<span class="colon">:</span></dt>
<dd class="field-even"><p>Other useful helper functions</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The store values that <code class="docutils literal notranslate"><span class="pre">vivarium-core</span></code> shows to processes when running them
are <strong>NOT</strong> copies, so processes must be careful not to unintentionally
modify mutable values. The Numpy arrays in the bulk and unique molecules stores
are made read-only for extra protection (see <code class="docutils literal notranslate"><span class="pre">WRITEABLE</span></code>
flag in <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.flags.html#numpy.ndarray.flags" title="(in NumPy v2.3)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.ndarray.flags</span></code></a>).</p>
</div>
<section id="bulk-molecules">
<span id="bulk"></span><h2>Bulk Molecules<a class="headerlink" href="#bulk-molecules" title="Link to this heading"></a></h2>
<dl class="field-list simple">
<dt class="field-odd">Path<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(&quot;bulk&quot;,)</span></code></p>
</dd>
<dt class="field-even">Updater<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.bulk_numpy_updater" title="ecoli.library.schema.bulk_numpy_updater"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.bulk_numpy_updater()</span></code></a></p>
</dd>
<dt class="field-odd">Divider<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.divide_bulk" title="ecoli.library.schema.divide_bulk"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.divide_bulk()</span></code></a></p>
</dd>
<dt class="field-even">Serializer<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.get_bulk_counts" title="ecoli.library.schema.get_bulk_counts"><code class="xref py py-class docutils literal notranslate"><span class="pre">ecoli.library.schema.get_bulk_counts</span></code></a></p>
</dd>
<dt class="field-odd">Schema<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.numpy_schema" title="ecoli.library.schema.numpy_schema"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.numpy_schema()</span></code></a></p>
</dd>
<dt class="field-even">Helpers<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.bulk_name_to_idx" title="ecoli.library.schema.bulk_name_to_idx"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.bulk_name_to_idx()</span></code></a>,
<a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.counts" title="ecoli.library.schema.counts"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.counts()</span></code></a></p>
</dd>
</dl>
<p>Bulk molecules are named as such because they represent species for
which all molecules are treated as interchangeable (e.g. water). The bulk
molecules store holds a
<a class="reference external" href="https://numpy.org/doc/stable/user/basics.rec.html">structured Numpy array</a>
with the following named fields:</p>
<blockquote>
<div><ol class="arabic simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">id</span></code> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>): Names of bulk molecules pulled from <a class="reference external" href="https://ecocyc.org/">EcoCyc</a></dt><dd><p>Each end with a bracketed “location tag” (e.g. <code class="docutils literal notranslate"><span class="pre">[c]</span></code>) containing
one of the abbreviations defined in the
<code class="docutils literal notranslate"><span class="pre">reconstruction/ecoli/flat/compartments.tsv</span></code> file (see
<a class="reference external" href="http://brg.ai.sri.com/CCO/downloads/cco.html">Cell Component Ontology</a>)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">count</span></code> (<a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.int64" title="(in NumPy v2.3)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.int64</span></code></a>): Counts of bulk molecules</dt><dd><p>Note that the <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess.evolve_state" title="ecoli.processes.partition.PartitionedProcess.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a>
method of <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess" title="ecoli.processes.partition.PartitionedProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionedProcess</span></code></a> does not see the full
structured array with named fields through its bulk port and instead sees a 1D array of
partitioned counts from the allocator (see <a class="reference internal" href="#partitioning"><span class="std std-ref">Partitioning</span></a>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">{}_submass</span></code> (<a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.float64" title="(in NumPy v2.3)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.float64</span></code></a>): Field for each submass</dt><dd><p>Eight submasses are rRNA, tRNA, mRNA, miscRNA, nonspecific_RNA, protein, metabolite, water, DNA</p>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
<section id="initialization">
<span id="id1"></span><h3>Initialization<a class="headerlink" href="#initialization" title="Link to this heading"></a></h3>
<p>To create the initial value for this store, the model will go through
the following three options in order of preference:</p>
<blockquote>
<div><ol class="arabic simple">
<li><dl class="simple">
<dt>Load custom initial state</dt><dd><p>Set <code class="docutils literal notranslate"><span class="pre">initial_state</span></code> option for
<a class="reference internal" href="reference/api/ecoli/ecoli.experiments.ecoli_master_sim.html#ecoli.experiments.ecoli_master_sim.EcoliSim" title="ecoli.experiments.ecoli_master_sim.EcoliSim"><code class="xref py py-class docutils literal notranslate"><span class="pre">EcoliSim</span></code></a>
(see <a class="reference internal" href="experiments.html#json-config"><span class="std std-ref">JSON Config Files</span></a>)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Load from saved state JSON</dt><dd><p>Set <code class="docutils literal notranslate"><span class="pre">initial_state_file</span></code> option for
<a class="reference internal" href="reference/api/ecoli/ecoli.experiments.ecoli_master_sim.html#ecoli.experiments.ecoli_master_sim.EcoliSim" title="ecoli.experiments.ecoli_master_sim.EcoliSim"><code class="xref py py-class docutils literal notranslate"><span class="pre">EcoliSim</span></code></a></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Generate from <code class="docutils literal notranslate"><span class="pre">sim_data</span></code></dt><dd><p><a class="reference internal" href="reference/api/ecoli/ecoli.library.sim_data.html#ecoli.library.sim_data.LoadSimData.generate_initial_state" title="ecoli.library.sim_data.LoadSimData.generate_initial_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">generate_initial_state()</span></code></a>
uses the <code class="docutils literal notranslate"><span class="pre">sim_data</span></code> object generated by the ParCa to calculate
initial state</p>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
</section>
<section id="partitioning">
<span id="id2"></span><h3>Partitioning<a class="headerlink" href="#partitioning" title="Link to this heading"></a></h3>
<section id="motivation">
<h4>Motivation<a class="headerlink" href="#motivation" title="Link to this heading"></a></h4>
<p>To support the use of independent sub-models for different biological processes
(e.g. FBA for metabolism, Gillespie for complexation, etc.), the model allows
processes to run mostly independently. At a high level, over the course of a
single simulation step, each process will see the simulation state as it was
before any other process has run. Each process will then calculate an update
to apply to the simulation state and all updates will be simultaneously
applied once all processes have run.</p>
<p>This setup has a potential problem: two processes may both decide to deplete
the count of the same molecule, resulting in a final count that is negative.
To prevent this from happening, the model forces processes to first request
counts of bulk molecules via special process-specific <code class="docutils literal notranslate"><span class="pre">request</span></code> stores. These
stores are read by an allocator process
(<a class="reference internal" href="reference/api/ecoli/ecoli.processes.allocator.html#ecoli.processes.allocator.Allocator" title="ecoli.processes.allocator.Allocator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Allocator</span></code></a>). The allocator process
then divides the bulk molecules so that each process sees a functional count
proportional to its request.</p>
<p>For example, if process A requests 100 of molecule X and process B requests
400 of molecule X but the cell only has 400 molecules of X, the allocator
will divide the molecules as follows:</p>
<ul class="simple">
<li><p>Process A: <span class="math notranslate nohighlight">\(\frac{100}{100 + 400} * 400 = 80\)</span> molecules of X</p></li>
<li><p>Process B: <span class="math notranslate nohighlight">\(\frac{400}{100 + 400} * 400 = 320\)</span> molecules of X</p></li>
</ul>
</section>
<section id="steps-and-flows">
<h4>Steps and Flows<a class="headerlink" href="#steps-and-flows" title="Link to this heading"></a></h4>
<p>In our model, many processes are dependent on one another even outside this
request/allocate partitioning scheme. For example, in each simulation time step,
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.metabolism.html#ecoli.processes.metabolism.Metabolism" title="ecoli.processes.metabolism.Metabolism"><code class="xref py py-class docutils literal notranslate"><span class="pre">Metabolism</span></code></a> must wait for
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.polypeptide_elongation.html#ecoli.processes.polypeptide_elongation.PolypeptideElongation" title="ecoli.processes.polypeptide_elongation.PolypeptideElongation"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolypeptideElongation</span></code></a>
to finish calculating the counts of amino acids, GTP, etc. consumed
before it can solve the FBA problem to optimize growth.</p>
<p>To allow processes to run in a pre-specified order within
each timestep, we can make use of a subclass of the typical Vivarium
<a class="reference external" href="https://vivarium-core.readthedocs.io/en/latest/reference/api/vivarium.core.process.html#vivarium.core.process.Process" title="(in Vivarium Core vv1.5.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> class:
<a class="reference external" href="https://vivarium-core.readthedocs.io/en/latest/reference/api/vivarium.core.process.html#vivarium.core.process.Step" title="(in Vivarium Core vv1.5.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Step</span></code></a>. Almost all “processes” in the model
are actually instances of <a class="reference external" href="https://vivarium-core.readthedocs.io/en/latest/reference/api/vivarium.core.process.html#vivarium.core.process.Step" title="(in Vivarium Core vv1.5.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Step</span></code></a>. These Steps
are configured to run in user-configured “execution layers” by way of a <code class="docutils literal notranslate"><span class="pre">flow</span></code>
that is included in the simulation configuration (see
<a class="reference internal" href="reference/api/ecoli/ecoli.experiments.ecoli_master_sim.html#module-ecoli.experiments.ecoli_master_sim" title="ecoli.experiments.ecoli_master_sim"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ecoli_master_sim</span></code></a>).</p>
<p>A <code class="docutils literal notranslate"><span class="pre">flow</span></code> is a dictionary that specifies the dependencies for each Step. For
example, if a user wants Step B to run only after Step A has updated the
simulation state, the user can include Step A as a dependency of Step B:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;Step B&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;Step A&quot;</span><span class="p">,)]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Steps can have multiple dependencies (e.g. <code class="docutils literal notranslate"><span class="pre">[(&quot;Step</span> <span class="pre">A&quot;,),</span> <span class="pre">(&quot;Step</span> <span class="pre">B&quot;,)]</span></code>)
and each dependency must be in the form of a tuple path. All processes are
top-level stores so these paths are usually just <code class="docutils literal notranslate"><span class="pre">(&quot;process</span> <span class="pre">name&quot;,)</span></code>.</p>
<p>Vivarium will parse the <code class="docutils literal notranslate"><span class="pre">flow</span></code> to construct a directed acyclic graph
and figure out the order in which to run steps by stratifying them into
execution layers. For example, consider the following <code class="docutils literal notranslate"><span class="pre">flow</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;Step B&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;Step A&quot;</span><span class="p">,)],</span>
    <span class="s2">&quot;Step C&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;Step A&quot;</span><span class="p">,)],</span>
    <span class="s2">&quot;Step D&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;Step C&quot;</span><span class="p">,)]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Vivarium will parse this into the following sequence of execution layers:</p>
<ol class="arabic simple">
<li><p>Step A</p></li>
<li><p>Step B and Step C (order does not matter)</p></li>
<li><p>Step D</p></li>
</ol>
<p>Each timestep, Step A will run and update the simulation state, Steps B and C
will run with a view of the state that was updated by Step A, and finally
Step D will run with a view of the state that was updated by every other step.</p>
</section>
<section id="implementation">
<span id="id3"></span><h4>Implementation<a class="headerlink" href="#implementation" title="Link to this heading"></a></h4>
<p>All partitioned processes are instances of the
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess" title="ecoli.processes.partition.PartitionedProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionedProcess</span></code></a> class. This both
serves to identify the processes that require partitioning and also implements
a standard <code class="docutils literal notranslate"><span class="pre">next_update</span></code> method that allows these processes to be run on
their own.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In instances of <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess" title="ecoli.processes.partition.PartitionedProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionedProcess</span></code></a>,
all ports connected to the bulk molecule store <strong>MUST</strong> be called
<code class="docutils literal notranslate"><span class="pre">bulk</span></code> to be properly partitioned. Conversely, ports that are not meant
to be partitioned should <strong>NEVER</strong> be called <code class="docutils literal notranslate"><span class="pre">bulk</span></code> in any
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess" title="ecoli.processes.partition.PartitionedProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionedProcess</span></code></a>.</p>
</div>
<p>In the model, each partitioned process is used to create two separate steps:
a <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.Requester" title="ecoli.processes.partition.Requester"><code class="xref py py-class docutils literal notranslate"><span class="pre">Requester</span></code></a> and an
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.Evolver" title="ecoli.processes.partition.Evolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Evolver</span></code></a>. For each execution layer
in the <code class="docutils literal notranslate"><span class="pre">flow</span></code> given to <a class="reference internal" href="reference/api/ecoli/ecoli.experiments.ecoli_master_sim.html#ecoli.experiments.ecoli_master_sim.EcoliSim" title="ecoli.experiments.ecoli_master_sim.EcoliSim"><code class="xref py py-class docutils literal notranslate"><span class="pre">EcoliSim</span></code></a>,
<a class="reference internal" href="reference/api/ecoli/ecoli.composites.ecoli_master.html#ecoli.composites.ecoli_master.Ecoli" title="ecoli.composites.ecoli_master.Ecoli"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ecoli</span></code></a> will create Requesters, Evolvers,
and other required Steps and arrange them to be executed in the following order:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>Requesters:</dt><dd><p>Each calls the
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess.calculate_request" title="ecoli.processes.partition.PartitionedProcess.calculate_request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calculate_request()</span></code></a>
method of a <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess" title="ecoli.processes.partition.PartitionedProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionedProcess</span></code></a>
in said layer and writes its requests to a process-specific <code class="docutils literal notranslate"><span class="pre">request</span></code> store</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Allocator:</dt><dd><p>Once all Requesters in said layer have finished writing their requests, an
instance of <a class="reference internal" href="reference/api/ecoli/ecoli.processes.allocator.html#ecoli.processes.allocator.Allocator" title="ecoli.processes.allocator.Allocator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Allocator</span></code></a>
reads all the written <code class="docutils literal notranslate"><span class="pre">request</span></code> stores and proportionally allocates bulk
molecules to processes, writing allocated counts to process-specific
<code class="docutils literal notranslate"><span class="pre">allocate</span></code> stores</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Evolvers:</dt><dd><p>Each swaps the Numpy structured array of unpartitioned bulk counts in the
<code class="docutils literal notranslate"><span class="pre">bulk</span></code> port with the 1D array of allocated counts in the corresponding
<code class="docutils literal notranslate"><span class="pre">allocate</span></code> store, calls the
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess.evolve_state" title="ecoli.processes.partition.PartitionedProcess.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a>
method of its <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess" title="ecoli.processes.partition.PartitionedProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionedProcess</span></code></a>,
and returns updates to the bulk molecule counts and unique molecule stores</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Unique updater:</dt><dd><p>An instance of
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.unique_update.html#ecoli.processes.unique_update.UniqueUpdate" title="ecoli.processes.unique_update.UniqueUpdate"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueUpdate</span></code></a> that tells the
unique molecule updaters to apply accumulated updates
(see <a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.UniqueNumpyUpdater" title="ecoli.library.schema.UniqueNumpyUpdater"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniqueNumpyUpdater</span></code></a> for why we accumulate
updates and wait to apply them after all Evolvers in an execution layer have run)</p>
</dd>
</dl>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.Requester" title="ecoli.processes.partition.Requester"><code class="xref py py-class docutils literal notranslate"><span class="pre">Requester</span></code></a> and
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.Evolver" title="ecoli.processes.partition.Evolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Evolver</span></code></a> for each partitioned process
share the same <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess" title="ecoli.processes.partition.PartitionedProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionedProcess</span></code></a>
instance. This allows instance variables to be updated and shared between the
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess.calculate_request" title="ecoli.processes.partition.PartitionedProcess.calculate_request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calculate_request()</span></code></a>
and <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess.evolve_state" title="ecoli.processes.partition.PartitionedProcess.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a>
methods of each <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess" title="ecoli.processes.partition.PartitionedProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionedProcess</span></code></a>.</p>
</div>
</section>
<section id="accessing-non-partitioned-counts">
<h4>Accessing Non-Partitioned Counts<a class="headerlink" href="#accessing-non-partitioned-counts" title="Link to this heading"></a></h4>
<p>There are certain partitioned processes that require access to the total, non-partitioned
counts of certain bulk molecules in their
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess.evolve_state" title="ecoli.processes.partition.PartitionedProcess.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a> methods. For example,
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.polypeptide_elongation.html#ecoli.processes.polypeptide_elongation.PolypeptideElongation" title="ecoli.processes.polypeptide_elongation.PolypeptideElongation"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolypeptideElongation</span></code></a> needs to know
the total counts to all amino acids to accurately implement tRNA charging. To give these
processes access to non-partitioned counts, an additional port is added to
their <code class="docutils literal notranslate"><span class="pre">ports_schema</span></code> methods and topologies that is also connected to the
bulk molecules store. By convention, this port is called <code class="docutils literal notranslate"><span class="pre">bulk_total</span></code> to
differentiate it from the partitioned <code class="docutils literal notranslate"><span class="pre">bulk</span></code> port. As noted in <a class="reference internal" href="#implementation"><span class="std std-ref">Implementation</span></a>,
Evolvers overwrite the port named <code class="docutils literal notranslate"><span class="pre">bulk</span></code> with the allocated bulk counts. Due to being
named <code class="docutils literal notranslate"><span class="pre">bulk_total</span></code> instead of <code class="docutils literal notranslate"><span class="pre">bulk</span></code>, the non-partitioned port value is left
untouched and allows the Evolver to read non-partitioned counts at will.</p>
</section>
</section>
<section id="indexing">
<h3>Indexing<a class="headerlink" href="#indexing" title="Link to this heading"></a></h3>
<p>Processes typically use the <a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.bulk_name_to_idx" title="ecoli.library.schema.bulk_name_to_idx"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.bulk_name_to_idx()</span></code></a> helper function
to get the indices for a set of molecules (e.g. all NTPs). These indices are typically cached
as instance attributes (e.g. <code class="docutils literal notranslate"><span class="pre">self.ntp_idx</span></code>) in the <code class="docutils literal notranslate"><span class="pre">calculate_request</span></code> method of a
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess" title="ecoli.processes.partition.PartitionedProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionedProcess</span></code></a>. This way, we can ensure
that all the necessary indices are retrieved the very first time the
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.Requester" title="ecoli.processes.partition.Requester"><code class="xref py py-class docutils literal notranslate"><span class="pre">Requester</span></code></a> for that process is
run, making it available to the <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.Evolver" title="ecoli.processes.partition.Evolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Evolver</span></code></a>
(which shares the same <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess" title="ecoli.processes.partition.PartitionedProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">PartitionedProcess</span></code></a>)
and subsequent runs of the Requester. See the branch beginning <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">self.proton_idx</span> <span class="pre">is</span> <span class="pre">None</span></code>
in <a class="reference internal" href="reference/api/ecoli/ecoli.processes.polypeptide_elongation.html#ecoli.processes.polypeptide_elongation.PolypeptideElongation.calculate_request" title="ecoli.processes.polypeptide_elongation.PolypeptideElongation.calculate_request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calculate_request()</span></code></a>
for an example.</p>
<p>Though counts can be directly retrieved from the Numpy structured array (e.g.
<code class="docutils literal notranslate"><span class="pre">states[&quot;bulk&quot;][&quot;count&quot;][self.ntp_idx]</span></code>), this method of access does not work
for <a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.Evolver" title="ecoli.processes.partition.Evolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Evolver</span></code></a> (i.e. inside the
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess.evolve_state" title="ecoli.processes.partition.PartitionedProcess.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a> method)
because they automatically replace the non-partitioned Numpy structured array
of bulk counts with the 1D array of partitioned bulk counts for that process
(see <a class="reference internal" href="#implementation"><span class="std std-ref">Implementation</span></a>). To standardize count access across the
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess.calculate_request" title="ecoli.processes.partition.PartitionedProcess.calculate_request"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calculate_request()</span></code></a> and
<a class="reference internal" href="reference/api/ecoli/ecoli.processes.partition.html#ecoli.processes.partition.PartitionedProcess.evolve_state" title="ecoli.processes.partition.PartitionedProcess.evolve_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">evolve_state()</span></code></a> methods,
the helper function <a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.counts" title="ecoli.library.schema.counts"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.counts()</span></code></a> can handle both of
these scenarios and also guarantees that the returned counts can be safely
edited without unintentionally mutating the source array.</p>
</section>
</section>
<section id="unique-molecules">
<h2>Unique Molecules<a class="headerlink" href="#unique-molecules" title="Link to this heading"></a></h2>
<dl class="field-list simple">
<dt class="field-odd">Path<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(&quot;unique&quot;,)</span></code></p>
</dd>
<dt class="field-even">Updater<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.UniqueNumpyUpdater.updater" title="ecoli.library.schema.UniqueNumpyUpdater.updater"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ecoli.library.schema.UniqueNumpyUpdater.updater()</span></code></a></p>
</dd>
<dt class="field-odd">Dividers<span class="colon">:</span></dt>
<dd class="field-odd"><p>See <a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.UNIQUE_DIVIDERS" title="ecoli.library.schema.UNIQUE_DIVIDERS"><code class="xref py py-data docutils literal notranslate"><span class="pre">ecoli.library.schema.UNIQUE_DIVIDERS</span></code></a></p>
</dd>
<dt class="field-even">Serializer<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.get_unique_fields" title="ecoli.library.schema.get_unique_fields"><code class="xref py py-class docutils literal notranslate"><span class="pre">ecoli.library.schema.get_unique_fields</span></code></a></p>
</dd>
<dt class="field-odd">Schema<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.numpy_schema" title="ecoli.library.schema.numpy_schema"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.numpy_schema()</span></code></a></p>
</dd>
<dt class="field-even">Helpers<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.attrs" title="ecoli.library.schema.attrs"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.attrs()</span></code></a></p>
</dd>
</dl>
<p>Unique molecules are named as such because they represent species for
which individual molecules are not treated as interchangeable (e.g.
different RNA molecules may have different sequences). The unique molecules
store holds substores for each unique molecule (e.g. <code class="docutils literal notranslate"><span class="pre">(&quot;unique&quot;,</span> <span class="pre">&quot;RNAs&quot;)</span></code>,
<code class="docutils literal notranslate"><span class="pre">(&quot;unique&quot;,</span> <span class="pre">&quot;active_RNAPs&quot;)</span></code>). Each unique molecule substore contains a
<a class="reference external" href="https://numpy.org/doc/stable/user/basics.rec.html">structured Numpy array</a>
with a variety of named fields, each representing an attribute of interest
for that class of unique molecules (e.g. <code class="docutils literal notranslate"><span class="pre">coordinates</span></code> for a <code class="docutils literal notranslate"><span class="pre">gene</span></code> unique
molecule). All unique molecules will have the following named fields:</p>
<blockquote>
<div><ol class="arabic simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unique_index</span></code> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>): Unique identifier for each unique molecule</dt><dd><p>When processes add new unique molecules, you can let
<a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.UniqueNumpyUpdater.updater" title="ecoli.library.schema.UniqueNumpyUpdater.updater"><code class="xref py py-meth docutils literal notranslate"><span class="pre">updater</span></code></a>
generate the new unique indices. If you need to reference the unique
indices of new molecules in the same process AND timestep in which they
are generated, see <a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.create_unique_indices" title="ecoli.library.schema.create_unique_indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ecoli.library.schema.create_unique_indices()</span></code></a>.
Note that unique indices are only unique within a single cell.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">_entryState</span></code> (<a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.int8" title="(in NumPy v2.3)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.int8</span></code></a>): 1 for active row, 0 for inactive row</dt><dd><p>When unique molecules are deleted (e.g. RNA degradation), all of their data,
including the <code class="docutils literal notranslate"><span class="pre">_entryState</span></code> field, is set to 0. When unique molecues are
added (e.g. RNA transcription), the updater places the data for these new
molecules into the rows that are identified as inactive by the helper function
<a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.get_free_indices" title="ecoli.library.schema.get_free_indices"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.get_free_indices()</span></code></a>, which also grows the array
if necessary.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">massDiff_{}</span></code> (<a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.float64" title="(in NumPy v2.3)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">numpy.float64</span></code></a>): Field for each dynamic submass</dt><dd><p>The eight submasses are rRNA, tRNA, mRNA, miscRNA, nonspecific_RNA, protein,
metabolite, water, and DNA. An example of a dynamic submass is the constantly
changing protein mass of the polypeptide associated with an actively
translating ribosome.</p>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unique molecules are instances of <a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.MetadataArray" title="ecoli.library.schema.MetadataArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataArray</span></code></a>,
a subclass of Numpy arrays that adds a <code class="docutils literal notranslate"><span class="pre">metadata</span></code> attribute. This attribute
is used to store the next unique index to be assigned to a new unique molecule.
If you wish to add a custom unique molecule type, after you have
created a structured Numpy array with at least the above attributes,
create a <a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.MetadataArray" title="ecoli.library.schema.MetadataArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetadataArray</span></code></a> instance from it using
<code class="docutils literal notranslate"><span class="pre">MetadataArray(array,</span> <span class="pre">next_unique_index)</span></code>, where <code class="docutils literal notranslate"><span class="pre">array</span></code> is your structured
Numpy array and <code class="docutils literal notranslate"><span class="pre">next_unique_index</span></code> is the next unique index to be assigned.</p>
</div>
<section id="id5">
<h3>Initialization<a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<p>See <a class="reference internal" href="#initialization"><span class="std std-ref">Initialization</span></a>.</p>
</section>
<section id="accessing">
<h3>Accessing<a class="headerlink" href="#accessing" title="Link to this heading"></a></h3>
<p>Processes use the <a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.attrs" title="ecoli.library.schema.attrs"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.attrs()</span></code></a> helper function to access
any number of attributes for all active (<code class="docutils literal notranslate"><span class="pre">_entryState</span></code> is 1) unique molecules
of a given type (e.g. RNA, active RNAP, etc.).</p>
</section>
</section>
<section id="listeners">
<h2>Listeners<a class="headerlink" href="#listeners" title="Link to this heading"></a></h2>
<dl class="field-list simple">
<dt class="field-odd">Path<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">(&quot;listeners&quot;,)</span></code></p>
</dd>
<dt class="field-even">Updater<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://vivarium-core.readthedocs.io/en/latest/reference/api/vivarium.core.registry.html#vivarium.core.registry.update_set" title="(in Vivarium Core vv1.5.3)"><code class="xref py py-func docutils literal notranslate"><span class="pre">update_set()</span></code></a></p>
</dd>
<dt class="field-odd">Divider<span class="colon">:</span></dt>
<dd class="field-odd"><p>None (leave value as is upon division)</p>
</dd>
<dt class="field-even">Serializer<span class="colon">:</span></dt>
<dd class="field-even"><p>None by default (leave value as is) but will automatically
use registered serializers for data that is of a type that cannot be
automatically serialized to JSON by <code class="docutils literal notranslate"><span class="pre">orjson</span></code>. For example,
listeners holding values with Unum units will be serialized by
<a class="reference internal" href="reference/api/ecoli/ecoli.library.serialize.html#ecoli.library.serialize.UnumSerializer" title="ecoli.library.serialize.UnumSerializer"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnumSerializer</span></code></a>, which is
registered in <code class="docutils literal notranslate"><span class="pre">ecoli/__init__.py</span></code>. See <a class="reference internal" href="output.html#serializing-emits"><span class="std std-ref">Serializing Emits</span></a>.</p>
</dd>
<dt class="field-odd">Schema<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.listener_schema" title="ecoli.library.schema.listener_schema"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.listener_schema()</span></code></a></p>
</dd>
<dt class="field-even">Helpers<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<p>The listeners store contains many substores that hold data which is saved
for downstream analyses. For example, the <code class="docutils literal notranslate"><span class="pre">(&quot;listeners&quot;,</span> <span class="pre">&quot;mass&quot;)</span></code> substore
contains substores for various masses of interest, such as <code class="docutils literal notranslate"><span class="pre">cell_mass</span></code>,
<code class="docutils literal notranslate"><span class="pre">dry_mass</span></code>, <code class="docutils literal notranslate"><span class="pre">protein_mass</span></code>, etc.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>When possible, we recommend that you put all stores whose data
you wish to save inside the listeners store. This is to ensure
consistency across the model and helps keep stores organized.</p>
</div>
<section id="id6">
<h3>Initialization<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<p>Listener stores are initialized at the start of a simulation with the
default values specified in the
<a class="reference external" href="https://vivarium-core.readthedocs.io/en/latest/reference/api/vivarium.core.process.html#vivarium.core.process.Process.ports_schema" title="(in Vivarium Core vv1.5.3)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ports_schema()</span></code></a> methods of
the processes that connect to them. Refer to
<a class="reference internal" href="reference/api/ecoli/ecoli.library.schema.html#ecoli.library.schema.listener_schema" title="ecoli.library.schema.listener_schema"><code class="xref py py-func docutils literal notranslate"><span class="pre">ecoli.library.schema.listener_schema()</span></code></a> for information about how
to configure this default value as well as attach useful metadata to
specific listener values.</p>
<p>Listener stores must contain data of the same type (or data that is serialized
to the same type) for the duration of a simulation. This is becuase the Parquet
storage format (see <a class="reference internal" href="output.html#parquet-emitter"><span class="std std-ref">Parquet Emitter</span></a>) is a columnar format that requires
columns to have static data types. Some leeway is allowed for <code class="docutils literal notranslate"><span class="pre">None</span></code> (null)
values in nested types. For example, <code class="docutils literal notranslate"><span class="pre">[]</span></code> and <code class="docutils literal notranslate"><span class="pre">[0]</span></code> both work fine for a
column containing 1D lists of integers.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Double check the data type of default values for listeners. For example,
a listener of float values with a default value of <code class="docutils literal notranslate"><span class="pre">0</span></code> will incorrectly
coerce all subsequent values to integers in the saved output. The correct
default value in this case is <code class="docutils literal notranslate"><span class="pre">0.0</span></code>.</p>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to Vivarium E. coli’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="processes.html" class="btn btn-neutral float-right" title="Processes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021-2025, The Vivarium E. coli Authors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>